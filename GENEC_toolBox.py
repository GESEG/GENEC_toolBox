## @package GENEC_toolBox
# \brief Set of tools developed to process the files generated by the Geneva stellar evolution code
#        and generate plots.
#
# GENEC_toolBox is meant to help you handling the files generated by the Geneva stellar evolution code
# or the SYCLIST tool.
# It processes the files and provides the possibility to plot any variable as a function of any other one.
# In the future, it will also provide several analysis processing. As of today, it provides only the possibility
# to compute the lifetime in the various burning phases.
#
# - Evolution files (.wg, .dat, grids format) are loaded with loadE(), loadEFromList(), or loadEFromDir().
# - Structure files (*.v*) are loaded with loadS(), loadSFromList(), or loadSFromDir().
# - Cluster / isochrones files generated by SYCLIST are loaded with loadC(),
#     loadCFromList(), or loadCFromDir().
#
# The variables available for plotting can be printed with VarEvol(), VarStruc(), or VarCluster().
# New variables can be determined by using the command Get_Var() and Set_Var(),
#    see example in the comments of the latter. After Set_Var(), the variable is available for plotting.
#
# The x axis variable is set by defX().
# The plot command is Plot() for normal plots,
# and Plot_colour() for plots with a line colour-coded by the value of another variable.
# In cluster mode, histograms can be plotted with the command Histo().
#
# Several pre-programmed plots exist, as:
# - HRD_plot(): HR diagram in L vs Teff. With the optionnal parameter corr=True, L vs Teffcorr.
#               With optional parameter spectro=True, sHRD.
# - CMD(): colour-magnitude diagram, with a large choice of colours
# - rhoT(): T vs rho diagram, and in evol mode, T_c vs rho_c
# - YTeff(): Teff vs He4_c
# - gTeff(): Teff vs g_surf
# - Abund(): plot of the abundances. In evol mode, with input parameter 's' for surface, 'c' for centre.
#          In struc mode, abundance profiles with input parameter 'p'.
# - NCNO(): N/C vs N/O diagram.
# - eps(): plots the energy generation zones for H, He, C, and neutrinos (struc mode only).
# - Coeff(): plots the diffusion coefficients.
# - Nablas(): plots the three Nablas (ad,rad, and mu) in structure mode.
# - j_profiles(): plots the profile of the specific angular momentum j_r as well as j_Kerr, j_Schwarzschild, and j_Kerr,max.
# - Kippen(): Kippenhahn diagram for a given model.
#           With the optional parameter burn=True, addition of the burning zones from an existing *.burn file.
# - plotRatio(): plots the ratio between two variables or one variable and the given index of a second one
# - Summary_plots(): draws a set of plots on 4 windows based on Raphael Hirschi's dhr14.py.
#
# For any questions or suggestions, contact sylvia.ekstrom@unige.ch

import os
import sys
import glob
from scipy import interpolate
import math
import numpy as np
import matplotlib.ticker as mptick
import matplotlib.pyplot as plt
import matplotlib.colors as colors
from matplotlib import rc
from matplotlib import rcParams
rc('font',**{'family':'serif','serif':['Times New Roman']})
rcParams['text.latex.preamble']=[r"\usepackage{amsmath}"]
import ConfigParser
from matplotlib.collections import LineCollection
import matplotlib.cm as cm
import time
import subprocess
rcParams['figure.subplot.left'] = 0.2
rcParams['figure.subplot.bottom'] = 0.2
rcParams['ps.usedistiller'] = 'Xpdf'
rcParams['xtick.direction'] = 'in'
rcParams['ytick.direction'] = 'in'

class GtB_version():
    GtB_version = '8.1.0'

class Cst():
    """Physical and astrophysical constants used by GENEC_toolBox"""
    Msol = 1.9885e33
    Rsol = 6.9951e10
    Lsol = 3.828e33
    Zsol = 1.40e-2
    Teffsol = 5778.
    c = 2.99792458e10
    G = 6.6738e-8
    k = 1.3806488e-16
    sigma = 5.670373e-5
    Avo = 6.02214129e23
    a = 4.*sigma/c
    R_gaz = k*Avo
    year=3.15569252e7
    Hsol = 0.720e0
    C12sol = 2.283152454926108e-3
    C13sol = 2.770743611425104e-5
    Nsol = 6.587580293386503e-4
    Osol = 5.718475172229120e-3
    Hsol_starevol = 0.717638811
    Zsol_starevol = 0.013452590

class FormatError(EnvironmentError):
    pass

class Rendering():
    """Lists the available colours and line styles for plots:
          Colours:
             iris map: Blue, Turquoise, MediumForestGreen, Gold1, DarkOrange,
                       Red, Magenta, MediumOrchid4, Black, Gray
             contrast map: Black, Red, Green, Blue, Cyan,
                           Magenta, Orange, Olive, Pink, Brown.
          Line styles:
             'cycle_colour', 'cycle_all', '-', '--', ':', '-.'.
          Points styles:
             'cycle_colour', 'cycle_all', 'o', '^', '*', 's', 'p', 'v', 'd', '>', '<'.
       List of variables for which the axis needs to be inverted by default:
          'ageadv', 'H1c', 'He4c', 'M_V', 'Teff', 'Teffcorr'."""
    Colours_list = {}
    Colours_list['contrast'] = [[(0.,0.,0.),(1.,0.,0.),(0.,0.8,0.),(0.,0.,1.),(0.,0.8,1.),(1.,0.,1.),(1.,0.4,0.),(0.2,0.4,0.),(1.,0.6,0.6),(0.4,0.2,0.2),(0.6,0.6,0.6)], \
                               ['black','red','green','blue','cyan','magenta','orange','olive','pink','brown','grey']]
    Colours_list['iris'] = [[(0.,0.,0.),(0.,0.,1.),(0.,0.8,1.),(0.,0.8,0.),(1.,0.8,0.),(1.,0.4,0.),(1.,0.,0.),(1.,0.,1.),(0.6,0.,0.8),(0.6,0.6,0.6)], \
                           ['black','blue','cyan','green','yellow','orange','red','magenta','purple','grey']]
    Line_list = ['-', (0,(8,1)), '--', ':',(0,(1,1,3,1)),(0,(1,1,8,1))]
    Point_list = ['o','^','*','s','p','v','d','>','<']
    Authorised_LineStyle=['cycle_colour','cycle_all']+Line_list
    Authorised_PointStyle=['cycle_colour','cycle_all']+Point_list
    Authorised_Colours = ['cycle', 'b', 'c', 'g', 'k', 'm', 'r', 'w', 'y']+colors.cnames.keys()
    Inversed_by_default = ['ageadv','H1c','He4c','Teff','Teffcorr','Teff_lgd','gsurf','gpol','gmean','fwg','Mbol','M_V','M_B']
    Noised = []
    for var in Inversed_by_default:
        noisedVar = var+'_noised'
        Noised.append(noisedVar)
    Inversed_by_default = Inversed_by_default + Noised

class readList():
    """Lists the columns and their descriptions in the various files that can be read,
          according to the specific mode and formats."""
    Evol_fmt = ['o2013','tgrids','tools','nami','bin','preMS']
    Evol_formats = {}
    Evol_formats['o2013'] = {'varList':[['line',0],['t',1],['M',2],['L',3],['Teffcorr',4],['Teff',17],['GammaEdd',59],['Mccrel',16],['rhoc',19],['Tc',20],['H1s',5],['He3s',7],['He4s',6],\
                    ['C12s',8],['C13s',9],['N14s',10],['O16s',11],['O17s',12],['O18s',13],['Ne20s',14],['Ne22s',15],['Al26s',42],['H1c',21],['He3c',23],['He4c',22],['Be7c',32],['B8c',33],\
                    ['C12c',24],['C13c',25],['N14c',26],['O16c',27],['O17c',28],['O18c',29],['Ne20c',30],['Ne22c',31],['Al26c',43],\
                    ['Vsurf',57],['Vcrit1',55],['Vcrit2',56],['OOc',38],['Omega_surf',39],['Omega_cen',40],['oblat',41],['rot_corr',44],['jspe3',48],\
                    ['jspe5',49],['GammaOmega',58],['Ltotint',64],['Ltot',109],['mominert',63],['Mdot',18],['dMmech',60],['Mdot_mech',61],['dlelex',62],\
                    ['Erot',65],['Epot',66],['Egaz',67],['Erad',68]],'unitsList':['model num','t [yr]','$M\ [M_\odot]$','$\log(L/L_\odot)$','$\log(T_\mathrm{eff}\ [\mathrm{K}])$',\
                    '$\log(T_\mathrm{eff}\ [\mathrm{K}])$','$\Gamma_\mathrm{Edd}$','$M_\mathrm{cc}/M_\mathrm{tot}$',\
                    r'$\log(\rho_\mathrm{c}\ [\mathrm{g\,cm}^{-3}])$','$\log(T_\mathrm{c}\ [K])$',\
                    '$^1$H [surf. mass frac.]','$^3$He [surf. mass frac.]','$^4$He [surf. mass frac.]',\
                    '$^{12}$C [surf. mass frac.]','$^{13}$C [surf. mass frac.]','$^{14}$N [surf. mass frac.]',\
                    '$^{16}$O [surf. mass frac.]','$^{17}$O [surf. mass frac.]','$^{18}$O [surf. mass frac.]',\
                    '$^{20}$Ne [surf. mass frac.]','$^{22}$Ne [surf. mass frac.]','$^{26}$Al [surf. mass frac.]',\
                    '$^1$H [centr. mass frac.]','$^3$He [centr. mass frac.]','$^4$He [centr. mass frac.]',
                    '$^7$Be [centr. mass frac.]','$^8$B [centr. mass frac.]','$^{12}$C [centr. mass frac.]',\
                    '$^{13}$C [centr. mass frac.]','$^{14}$N [centr. mass frac.]','$^{16}$O [centr. mass frac.]',\
                    '$^{17}$O [centr. mass frac.]','$^{18}$O [centr. mass frac.]','$^{20}$Ne [centr. mass frac.]',\
                    '$^{22}$Ne [centr. mass frac.]','$^{26}$Al [centr. mass frac.]',\
                    '$V_\mathrm{surf}\ [\mathrm{km\,s}^{-1}]$','$V_\mathrm{crit,1}\ [\mathrm{km\,s}^{-1}]$',\
                    '$V_\mathrm{crit,2}\ [\mathrm{km\,s}^{-1}]$','$\Omega/\Omega_\mathrm{crit}$',\
                    '$\Omega_\mathrm{surf}\ [\mathrm{s}^{-1}]$','$\Omega_\mathrm{cen}\ [\mathrm{s}^{-1}]$',\
                    '$R_\mathrm{pol}/R_\mathrm{eq}$','$F_\Omega$',\
                    '$\mathscr{j}_{3M_\odot}\ [10^{16}\,\mathrm{cm}^2\,\mathrm{s}^{-1}]$',\
                    '$\mathscr{j}_{5M_\odot}\ [10^{16}\,\mathrm{cm}^2\,\mathrm{s}^{-1}]$',\
                    '$\Omega/min(\Omega_\mathrm{crit,1},\Omega_\mathrm{crit,2})$',\
                    '$\mathscr{L}_\mathrm{tot,int}\ [10^{53}\,\mathrm{g\,cm}^2\,\mathrm{s}^{-1}]$',\
                    '$\mathscr{L}_\mathrm{tot}\ [10^{53}\,\mathrm{g\,cm}^2\,\mathrm{s}^{-1}]$','$I\ [10^{57}\,\mathrm{g\,cm}^2]$',\
                    '$\log(\dot{M}\ [M_\odot\,\mathrm{yr}^{-1}])$','$\mathrm{d}M_\mathrm{mech}\ [M_\odot]$',\
                    '$(\log(\dot{M})_\mathrm{mech}\ [M_\odot\,\mathrm{yr}^{-1}])$',\
                    '$\Delta\,\mathscr{L}_\mathrm{rad+aniso+mech}\ [10^{53}\,\mathrm{g\,cm}^2\,\mathrm{s}^{-1}]$',\
                    '$E_\mathrm{rot}\ [E_{51}]$','$E_\mathrm{pot}\ [E_{51}]$','$E_\mathrm{th,gaz}\ [E_{51}]$',\
                    '$E_\mathrm{rad}\ [E_{51}]$'],'catList':['model','model','model','surface','surface','surface','surface','centre','centre','centre',
                    'abundances','abundances','abundances','abundances','abundances','abundances','abundances','abundances',\
                    'abundances','abundances','abundances','abundances','abundances','abundances','abundances','abundances',\
                    'abundances','abundances','abundances','abundances','abundances','abundances','abundances','abundances',\
                    'abundances','abundances','rotation','rotation','rotation','rotation','rotation','rotation','rotation',\
                    'rotation','rotation','rotation','rotation','rotation','rotation','rotation','winds','winds','winds','winds',\
                    'energetics','energetics','energetics','energetics'],'header':0,'column_number':110}
    Evol_formats['tgrids'] = {'varList':[['line',0],['t',1],['M',2],['L',3],['Teffcorr',4],['Teff',17],['GammaEdd',40],['Mccrel',16],['rhoc',19],['Tc',20],\
                    ['H1s',5],['He4s',6],['C12s',7],['C13s',8],['N14s',9],['O16s',10],['O17s',11],['O18s',12],['Ne20s',13],['Ne22s',14],['Al26s',15],\
                    ['H1c',21],['He4c',22],['C12c',23],['C13c',24],['N14c',25],['O16c',26],['O17c',27],['O18c',28],['Ne20c',29],['Ne22c',30],['Al26c',31],\
                    ['Vsurf',38],['Vcrit1',36],['Vcrit2',37],['OOc',39],['Omega_surf',32],['Omega_cen',33],['oblat',34],['rot_corr',35],['Ltot',42],\
                    ['Mdot',18],['Mdot_mech',41]],'unitsList':['model num','t [yr]','$M\ [M_\odot]$','$\log(L/L_\odot)$','$\log(T_\mathrm{eff}\ [\mathrm{K}])$',\
                    '$\log(T_\mathrm{eff}\ [\mathrm{K}])$','$\Gamma_\mathrm{Edd}$','$M_\mathrm{cc}/M_\mathrm{tot}$',\
                    r'$\log(\rho_\mathrm{c}\ [\mathrm{g\,cm}^{-3}])$','$\log(T_\mathrm{c}\ [K])$',\
                    '$^1$H [surf. mass frac.]','$^4$He [surf. mass frac.]',\
                    '$^{12}$C [surf. mass frac.]','$^{13}$C [surf. mass frac.]','$^{14}$N [surf. mass frac.]',\
                    '$^{16}$O [surf. mass frac.]','$^{17}$O [surf. mass frac.]','$^{18}$O [surf. mass frac.]',\
                    '$^{20}$Ne [surf. mass frac.]','$^{22}$Ne [surf. mass frac.]','$^{26}$Al [surf. mass frac.]',\
                    '$^1$H [centr. mass frac.]','$^4$He [centr. mass frac.]','$^{12}$C [centr. mass frac.]',\
                    '$^{13}$C [centr. mass frac.]','$^{14}$N [centr. mass frac.]','$^{16}$O [centr. mass frac.]',\
                    '$^{17}$O [centr. mass frac.]','$^{18}$O [centr. mass frac.]','$^{20}$Ne [centr. mass frac.]',\
                    '$^{22}$Ne [centr. mass frac.]','$^{26}$Al [centr. mass frac.]','$V_\mathrm{surf}\ [\mathrm{km\,s}^{-1}]$',\
                    '$V_\mathrm{crit,1}\ [\mathrm{km\,s}^{-1}]$','$V_\mathrm{crit,2}\ [\mathrm{km\,s}^{-1}]$',\
                    '$\Omega/\Omega_\mathrm{crit}$','$\Omega_\mathrm{surf}\ [\mathrm{s}^{-1}]$',\
                    '$\Omega_\mathrm{cen}\ [\mathrm{s}^{-1}]$','$R_\mathrm{pol}/R_\mathrm{eq}$','$F_\Omega$',
                    '$\mathscr{L}_\mathrm{tot}\ [10^{53}\,\mathrm{g\,cm}^2\,\mathrm{s}^{-1}]$',\
                    '$\log(\dot{M}\ [M_\odot\,\mathrm{yr}^{-1}])$','$\mathrm{d}M_\mathrm{mech}\ [M_\odot]$'],\
                    'catList':['model','model','model','surface','surface','surface','surface','centre','centre','centre',
                    'abundances','abundances','abundances','abundances','abundances','abundances','abundances','abundances',\
                    'abundances','abundances','abundances','abundances','abundances','abundances','abundances','abundances',\
                    'abundances','abundances','abundances','abundances','abundances','abundances','rotation','rotation',\
                    'rotation','rotation','rotation','rotation','rotation','rotation','rotation','winds','winds'],'header':3,'column_number':43}
    Evol_formats['tools'] = {'varList':[['line',0],['t',1],['M',2],['L',3],['Teffcorr',4],['Teff',17],['GammaEdd',40],['Rpol',44],['gpol',43],\
                    ['Mccrel',16],['rhoc',19],['Tc',20],['H1s',5],['He4s',6],['C12s',7],['C13s',8],['N14s',9],['O16s',10],['O17s',11],\
                    ['O18s',12],['Ne20s',13],['Ne22s',14],['Al26s',15],['H1c',21],['He4c',22],['C12c',23],['C13c',24],['N14c',25],['O16c',26],\
                    ['O17c',27],['O18c',28],['Ne20c',29],['Ne22c',30],['Al26c',31],['Vsurf',38],['Vcrit1',36],['Vcrit2',37],['OOc',39],\
                    ['Omega_surf',32],['Omega_cen',33],['oblat',34],['rot_corr',35],['Ltot',42],['Mdot',18],['Mdot_mech',41],['M_bol',45],\
                    ['M_V',46],['UB',47],['BV',48],['VR',49],['VI',50],['JK',51],['HK',52],['VK',53],['BC',54]],\
                    'unitsList':['model num','t [yr]','$M\ [M_\odot]$','$\log(L/L_\odot)$','$\log(T_\mathrm{eff}\ [\mathrm{K}])$',\
                    '$\log(T_\mathrm{eff}\ [\mathrm{K}])$','$\Gamma_\mathrm{Edd}$','$R_\mathrm{pol}\ [R_\odot]$',\
                    '$\log(g_\mathrm{pol}\ [\mathrm{cm\,s}^{-2}])$','$M_\mathrm{cc}/M_\mathrm{tot}$',\
                    r'$\log(\rho_\mathrm{c}\ [\mathrm{g\,cm}^{-3}])$','$\log(T_\mathrm{c}\ [K])$',\
                    '$^1$H [surf. mass frac.]','$^4$He [surf. mass frac.]',\
                    '$^{12}$C [surf. mass frac.]','$^{13}$C [surf. mass frac.]','$^{14}$N [surf. mass frac.]',\
                    '$^{16}$O [surf. mass frac.]','$^{17}$O [surf. mass frac.]','$^{18}$O [surf. mass frac.]',\
                    '$^{20}$Ne [surf. mass frac.]','$^{22}$Ne [surf. mass frac.]','$^{26}$Al [surf. mass frac.]',\
                    '$^1$H [centr. mass frac.]','$^4$He [centr. mass frac.]','$^{12}$C [centr. mass frac.]',\
                    '$^{13}$C [centr. mass frac.]','$^{14}$N [centr. mass frac.]','$^{16}$O [centr. mass frac.]',\
                    '$^{17}$O [centr. mass frac.]','$^{18}$O [centr. mass frac.]','$^{20}$Ne [centr. mass frac.]',\
                    '$^{22}$Ne [centr. mass frac.]','$^{26}$Al [centr. mass frac.]','$V_\mathrm{surf}\ [\mathrm{km\,s}^{-1}]$',\
                    '$V_\mathrm{crit,1}\ [\mathrm{km\,s}^{-1}]$','$V_\mathrm{crit,2}\ [\mathrm{km\,s}^{-1}]$',\
                    '$\Omega/\Omega_\mathrm{crit}$','$\Omega_\mathrm{surf}\ [\mathrm{s}^{-1}]$',\
                    '$\Omega_\mathrm{cen}\ [\mathrm{s}^{-1}]$','$R_\mathrm{pol}/R_\mathrm{eq}$','$F_\Omega$',\
                    '$\mathscr{L}_\mathrm{tot}\ [10^{53}\,\mathrm{g\,cm}^2\,\mathrm{s}^{-1}]$',\
                    '$\log(\dot{M}\ [M_\odot\,\mathrm{yr}^{-1}])$','$\mathrm{d}M_\mathrm{mech}\ [M_\odot]$',\
                    'M$_\mathrm{bol}$','M$_\mathrm{V}$','U-B','B-V','V-R','V-I','J-K','H-K','V-K','BC'],'catList':['model',\
                    'model','model','surface','surface','surface','surface','surface','surface',\
                    'centre','centre','centre','abundances','abundances','abundances','abundances','abundances','abundances',\
                    'abundances','abundances','abundances','abundances','abundances','abundances','abundances','abundances',\
                    'abundances','abundances','abundances','abundances','abundances','abundances','abundances','abundances',\
                    'rotation','rotation','rotation','rotation','rotation','rotation','rotation','rotation','rotation',\
                    'winds','winds','colours','colours','colours','colours','colours','colours','colours','colours','colours','colours'],\
                    'header':3,'column_number':55}
    Evol_formats['nami'] = {'varList':[['line',0],['t',2],['M',3],['rhom',37],['L',4],['Teff',5],['R',36],['rhoc',6],['Tc',7],['Mccrel',8],['H1c',9],['He3c',10],\
                    ['He4c',11],['C12c',12],['C13c',13],['N14c',14],['O16c',15],['O17c',16],['O18c',17],['Ne20c',18],['Ne22c',19],\
                    ['H1s',20],['He3s',21],['He4s',22],['C12s',23],['C13s',24],['N14s',25],['O16s',26],['O17s',27],['O18s',28],['Ne20s',29],\
                    ['Ne22s',30],['Zsurf',35]],'unitsList':['model num','t [yr]','$M\ [M_\odot]$',r'$\rho_\mathrm{m}\ [\mathrm{g\,cm}^3]$',\
                    '$\log(L/L_\odot)$','$\log(T_\mathrm{eff}\ [\mathrm{K}])$','$R\ [R_\odot]$',r'$\log(\rho_\mathrm{c}\ [\mathrm{g\,cm}^{-3}])$',\
                    '$\log(T_\mathrm{c}\ [K])$','$M_\mathrm{cc}/M_\mathrm{tot}$',\
                    '$^1$H [centr. mass frac.]','$^3$He [centr. mass frac.]','$^4$He [centr. mass frac.]',\
                    '$^{12}$C [centr. mass frac.]','$^{13}$C [centr. mass frac.]','$^{14}$N [centr. mass frac.]',\
                    '$^{16}$O [centr. mass frac.]','$^{17}$O [centr. mass frac.]','$^{18}$O [centr. mass frac.]',\
                    '$^{20}$Ne [centr. mass frac.]','$^{22}$Ne [centr. mass frac.]','$^1$H [surf. mass frac.]',\
                    '$^3$He [surf. mass frac.]','$^4$He [surf. mass frac.]','$^{12}$C [surf. mass frac.]',\
                    '$^{13}$C [surf. mass frac.]','$^{14}$N [surf. mass frac.]','$^{16}$O [surf. mass frac.]',\
                    '$^{17}$O [surf. mass frac.]','$^{18}$O [surf. mass frac.]','$^{20}$Ne [surf. mass frac.]',\
                    '$^{22}$Ne [surf. mass frac.]','$Z_\mathrm{surf}$ [mass frac.]'],\
                    'catList':['model','model','model','model','surface','surface','surface','centre','centre','centre','abundances','abundances',\
                    'abundances','abundances','abundances','abundances','abundances','abundances','abundances','abundances',\
                    'abundances','abundances','abundances','abundances','abundances','abundances','abundances','abundances',\
                    'abundances','abundances','abundances','abundances','abundances'],'header':1,'column_number':38}
    Evol_formats['bin'] = {'varList':[['line',0],['t',1],['M',2],['L',3],['Teffcorr',4],['Teff',24],['GammaEdd',66],['Mccrel',23],\
                    ['rhoc',26],['Tc',27],['H1s',12],['He3s',14],['He4s',13],['C12s',15],['C13s',16],['N14s',17],['O16s',18],\
                    ['O17s',19],['O18s',20],['Ne20s',21],['Ne22s',22],['Al26s',49],['H1c',28],['He3c',30],['He4c',29],['Be7c',39],['B8c',40],\
                    ['C12c',31],['C13c',32],['N14c',33],['O16c',34],['O17c',35],['O18c',36],['Ne20c',37],['Ne22c',38],['Al26c',50],\
                    ['Vsurf',64],['Vcrit1',62],['Vcrit2',63],['OOc',45],['Omega_surf',46],['Omega_cen',47],['oblat',48],['rot_corr',51],['jspe3',55],\
                    ['jspe5',56],['GammaOmega',65],['Ltotint',71],['Ltot',116],['mominert',70],['Mdot',25],['dMmech',67],['Mdot_mech',68],['dlelex',69],\
                    ['Erot',72],['Epot',73],['Egaz',74],['Erad',75],['Period',5],['Sep',6],['q',7],['RRoche1',8],['R1',9],['R1_r2t4',10],['Mdot_bin',11]],\
                    'unitsList':['model num','t [yr]','$M\ [M_\odot]$','$\log(L/L_\odot)$','$\log(T_\mathrm{eff}\ [\mathrm{K}])$',\
                    '$\log(T_\mathrm{eff}\ [\mathrm{K}])$','$\Gamma_\mathrm{Edd}$','$M_\mathrm{cc}/M_\mathrm{tot}$',\
                    r'$\log(\rho_\mathrm{c}\ [\mathrm{g\,cm}^{-3}])$','$\log(T_\mathrm{c}\ [K])$',\
                    '$^1$H [surf. mass frac.]','$^3$He [surf. mass frac.]','$^4$He [surf. mass frac.]',\
                    '$^{12}$C [surf. mass frac.]','$^{13}$C [surf. mass frac.]','$^{14}$N [surf. mass frac.]',\
                    '$^{16}$O [surf. mass frac.]','$^{17}$O [surf. mass frac.]','$^{18}$O [surf. mass frac.]',\
                    '$^{20}$Ne [surf. mass frac.]','$^{22}$Ne [surf. mass frac.]','$^{26}$Al [surf. mass frac.]',\
                    '$^1$H [centr. mass frac.]','$^3$He [centr. mass frac.]','$^4$He [centr. mass frac.]',
                    '$^7$Be [centr. mass frac.]','$^8$B [centr. mass frac.]','$^{12}$C [centr. mass frac.]',\
                    '$^{13}$C [centr. mass frac.]','$^{14}$N [centr. mass frac.]','$^{16}$O [centr. mass frac.]',\
                    '$^{17}$O [centr. mass frac.]','$^{18}$O [centr. mass frac.]','$^{20}$Ne [centr. mass frac.]',\
                    '$^{22}$Ne [centr. mass frac.]','$^{26}$Al [centr. mass frac.]',\
                    '$V_\mathrm{surf}\ [\mathrm{km\,s}^{-1}]$','$V_\mathrm{crit,1}\ [\mathrm{km\,s}^{-1}]$',\
                    '$V_\mathrm{crit,2}\ [\mathrm{km\,s}^{-1}]$','$\Omega/\Omega_\mathrm{crit}$',\
                    '$\Omega_\mathrm{surf}\ [\mathrm{s}^{-1}]$','$\Omega_\mathrm{cen}\ [\mathrm{s}^{-1}]$',\
                    '$R_\mathrm{pol}/R_\mathrm{eq}$','$F_\Omega$',\
                    '$\mathscr{j}_{3M_\odot}\ [10^{16}\,\mathrm{cm}^2\,\mathrm{s}^{-1}]$',\
                    '$\mathscr{j}_{5M_\odot}\ [10^{16}\,\mathrm{cm}^2\,\mathrm{s}^{-1}]$',\
                    '$\Omega/min(\Omega_\mathrm{crit,1},\Omega_\mathrm{crit,2})$',\
                    '$\mathscr{L}_\mathrm{tot,int}\ [10^{53}\,\mathrm{g\,cm}^2\,\mathrm{s}^{-1}]$',\
                    '$\mathscr{L}_\mathrm{tot}\ [10^{53}\,\mathrm{g\,cm}^2\,\mathrm{s}^{-1}]$','$I\ [10^{57}\,\mathrm{g\,cm}^2]$',\
                    '$\log(\dot{M}\ [M_\odot\,\mathrm{yr}^{-1}])$','$\mathrm{d}M_\mathrm{mech}\ [M_\odot]$',\
                    '$(\log(\dot{M})_\mathrm{mech}\ [M_\odot\,\mathrm{yr}^{-1}])$',\
                    '$\Delta\,\mathscr{L}_\mathrm{rad+aniso+mech}\ [10^{53}\,\mathrm{g\,cm}^2\,\mathrm{s}^{-1}]$',\
                    '$E_\mathrm{rot}\ [E_{51}]$','$E_\mathrm{pot}\ [E_{51}]$','$E_\mathrm{th,gaz}\ [E_{51}]$',\
                    '$E_\mathrm{rad}\ [E_{51}]$','$\mathrm{Period}\,[\mathrm{d}]$','$\mathrm{Separation}\,[R_\odot]$','$M_2/M_1$',\
                    '$R_\mathrm{Roche,1}\,[R_\odot]$','$R_1\,[\mathrm{cm}]$','$R_1(R^2T^4)\,[\mathrm{cm}]$',\
                    '$\dot{M}_\mathrm{bin}\,[M_\odot\,\mathrm{yr}^{-1}]$'],'catList':['model','model','model','surface','surface','surface','surface','centre','centre','centre',
                    'abundances','abundances','abundances','abundances','abundances','abundances','abundances','abundances',\
                    'abundances','abundances','abundances','abundances','abundances','abundances','abundances','abundances',\
                    'abundances','abundances','abundances','abundances','abundances','abundances','abundances','abundances',\
                    'abundances','abundances','rotation','rotation','rotation','rotation','rotation','rotation','rotation',\
                    'rotation','rotation','rotation','rotation','rotation','rotation','rotation','winds','winds','winds','winds',\
                    'energetics','energetics','energetics','energetics','binary','binary','binary','binary','binary','binary','binary'],\
                    'header':0,'column_number':117}
    Evol_formats['preMS'] = {'header':0,'column_number':116}
    Evol_formats['starevol_as'] = {'varList':[['line',0],['Dnu',1],['Dnu_ech',2],['Dnu_error',3],['Ttot',4],['Tbce',5],['THe',6],\
                     ['numax',7],['Dpg',8]],\
                     'unitsList':['model num','$\\Delta\\nu_\\mathrm{asym.}\\ [\\mu\\mathrm{Hz}]$',\
                     '$\\Delta\\nu_\\mathrm{scal.}\\ [\\mu\\mathrm{Hz}]$',\
                     '$\\frac{\\Delta\\nu_\\mathrm{asym.}-\\Delta\\nu_\\mathrm{scal.}}{\\Delta\\nu_\\mathrm{asym.}}$',\
                     'Total accoustic radius [s]','Accoustic radius$_\\mathrm{BCE}$ [s]',\
                     'Accoustic radius$_\\mathrm{He\\ ion}$ [s]','$\\nu_\\mathrm{max}\\ [\\mu\\mathrm{Hz}]$',\
                     '$\\Delta\\Pi_\\mathrm{g\\ modes}\\ [\\mathrm{s}]$'],
                     'catList':['model','astero','astero','astero','astero','astero','astero','astero','astero'],\
                     'header':7,'column_number':9}
    Evol_formats['starevol_hr'] = {'varList':[['line',0],['phaseSE',1],['L',2],['Reff',3],['R',4],['Teff',5],['rhoeff',6],\
                     ['gsurf',7],['Mdot',8],['M',9],['deltat',10],['t',11],['iter',12],['crash',13],['shells',14],\
                     ['cputime',15]],
                     'unitsList':['model num','phase number','$\log(L/L_\odot)$','$R_\\mathrm{eff} \ [R_\odot]$','$R \ [R_\odot]$',\
                     '$\log(T_\mathrm{eff}\ [\mathrm{K}])$',r'$\log(\rho_\mathrm{eff}\ [\mathrm{g\,cm}^{-3}])$',\
                     '$\log(g_\mathrm{surf}\ [\mathrm{cm\,s}^{-2}])$','$\log(\dot{M}\ [M_\odot\,\mathrm{yr}^{-1}])$',\
                     '$M\ [M_\odot]$','$\\Delta t \ [\\mathrm{yr}]$','t [yr]','number of iterations','number of crashes',\
                     'number of shells','t [s]'],\
                     'catList':['model','model','surface','surface','surface','surface','surface','surface','surface',\
                     'surface','model','model','model','model','model','model'],\
                     'header':7,'column_number':16}
    Evol_formats['starevol_c1'] = {'varList':[['line',0],['nc',1],['H1c',2],['H2c',3],['He3c',4],['He4c',5],\
                     ['Li6c',6],['Li7c',7],['Be7c',8],['Be9c',9],['B10c',10],['B11c',11]],\
                     'unitsList':['model num','neutrons [centr. mass frac.]','$^{1}$H [centr. mass frac.]',\
                     '$^{2}$H [centr. mass frac.]','$^{3}$He [centr. mass frac.]','$^{4}$He [centr. mass frac.]',\
                     '$^{6}$Li [centr. mass frac.]','$^{7}$Li [centr. mass frac.]','$^{7}$Be [centr. mass frac.]',\
                     '$^{9}$Be [centr. mass frac.]','$^{10}$B [centr. mass frac.]','$^{11}$B [centr. mass frac.]'],\
                     'catList':['model','abundances','abundances','abundances','abundances','abundances','abundances',\
                     'abundances','abundances','abundances','abundances','abundances'],\
                     'header':7,'column_number':12}
    Evol_formats['starevol_c2'] = {'varList':[['line',0],['C12c',1],['C13c',2],['C14c',3],['N14c',4],['N15c',5],\
                     ['O15c',6],['O16c',7],['O17c',8],['O18c',9],['F19c',10],['Ne20c',11]],\
                     'unitsList':['model num','$^{12}$C [centr. mass frac.]','$^{13}$C [centr. mass frac.]',\
                     '$^{14}$C [centr. mass frac.]','$^{14}$N [centr. mass frac.]','$^{15}$N [centr. mass frac.]',\
                     '$^{15}$O [centr. mass frac.]','$^{16}$O [centr. mass frac.]','$^{17}$O [centr. mass frac.]',\
                     '$^{18}$O [centr. mass frac.]','$^{19}$F [centr. mass frac.]','$^{20}$Ne [centr. mass frac.]'],
                     'catList':['model','abundances','abundances','abundances','abundances','abundances','abundances',\
                     'abundances','abundances','abundances','abundances','abundances'],
                     'header':7,'column_number':12}
    Evol_formats['starevol_c3'] = {'varList':[['line',0],['Ne21c',1],['Ne22c',2],['Na23c',3],['Mg24c',4],['Mg25c',5],\
                     ['Mg26c',6],['Al26c',7],['Al26gc',8],['Al27c',9],['Si28c',10],['Si29c',11]],\
                     'unitsList':['model num','$^{21}$Ne [centr. mass frac.]','$^{22}$Ne [centr. mass frac.]',\
                     '$^{23}$Na [centr. mass frac.]','$^{24}$Mg [centr. mass frac.]','$^{25}$Mg [centr. mass frac.]',\
                     '$^{26}$Mg [centr. mass frac.]','$^{26}$Al [centr. mass frac.]','$^{26}$Al$_\\mathrm{g}$ [centr. mass frac.]',\
                     '$^{27}$Al [centr. mass frac.]','$^{28}$Si [centr. mass frac.]','$^{29}$Si [centr. mass frac.]'],
                     'catList':['model','abundances','abundances','abundances','abundances','abundances','abundances',\
                     'abundances','abundances','abundances','abundances','abundances'],
                     'header':7,'column_number':12}
    Evol_formats['starevol_c4'] = {'varList':[['line',0],['Si30c',1],['P31c',2],['S32c',3],['S33c',4],['S34c',5],\
                     ['S35c',6],['Cl35c',7],['S36c',8],['Cl36c',9],['Cl37c',10],['Heavyc',11]],\
                     'unitsList':['model num','$^{30}$Si [centr. mass frac.]','$^{31}$P [centr. mass frac.]',\
                     '$^{32}$S [centr. mass frac.]','$^{33}$S [centr. mass frac.]','$^{34}$S [centr. mass frac.]',\
                     '$^{35}$S [centr. mass frac.]','$^{35}$Cl [centr. mass frac.]','$^{36}$S [centr. mass frac.]',\
                     '$^{36}$Cl [centr. mass frac.]','$^{37}$Cl [centr. mass frac.]','Heavy el. [centr. mass frac.]'],
                     'catList':['model','abundances','abundances','abundances','abundances','abundances','abundances',\
                     'abundances','abundances','abundances','abundances','abundances'],
                     'header':7,'column_number':12}
    Evol_formats['starevol_s1'] = {'varList':[['line',0],['nc',1],['H1s',2],['H2s',3],['He3s',4],['He4s',5],\
                     ['Li6s',6],['Li7s',7],['Be7s',8],['Be9s',9],['B10s',10],['B11s',11]],\
                     'unitsList':['model num','neutrons [centr. mass frac.]','$^{1}$H [centr. mass frac.]',\
                     '$^{2}$H [surf. mass frac.]','$^{3}$He [surf. mass frac.]','$^{4}$He [surf. mass frac.]',\
                     '$^{6}$Li [surf. mass frac.]','$^{7}$Li [surf. mass frac.]','$^{7}$Be [surf. mass frac.]',\
                     '$^{9}$Be [surf. mass frac.]','$^{10}$B [surf. mass frac.]','$^{11}$B [surf. mass frac.]'],\
                     'catList':['model','abundances','abundances','abundances','abundances','abundances','abundances',\
                     'abundances','abundances','abundances','abundances','abundances'],\
                     'header':7,'column_number':12}
    Evol_formats['starevol_s2'] = {'varList':[['line',0],['C12s',1],['C13s',2],['C14s',3],['N14s',4],['N15s',5],\
                     ['O15s',6],['O16s',7],['O17s',8],['O18s',9],['F19s',10],['Ne20s',11]],\
                     'unitsList':['model num','$^{12}$C [surf. mass frac.]','$^{13}$C [surf. mass frac.]',\
                     '$^{14}$C [surf. mass frac.]','$^{14}$N [surf. mass frac.]','$^{15}$N [surf. mass frac.]',\
                     '$^{15}$O [surf. mass frac.]','$^{16}$O [surf. mass frac.]','$^{17}$O [surf. mass frac.]',\
                     '$^{18}$O [surf. mass frac.]','$^{19}$F [surf. mass frac.]','$^{20}$N2 [surf. mass frac.]'],
                     'catList':['model','abundances','abundances','abundances','abundances','abundances','abundances',\
                     'abundances','abundances','abundances','abundances','abundances'],
                     'header':7,'column_number':12}
    Evol_formats['starevol_s3'] = {'varList':[['line',0],['Ne21s',1],['Ne22s',2],['Na23s',3],['Mg24s',4],['Mg25s',5],\
                     ['Mg26s',6],['Al26s',7],['Al26gs',8],['Al27s',9],['Si28s',10],['Si29s',11]],\
                     'unitsList':['model num','$^{21}$Ne [surf. mass frac.]','$^{22}$Ne [surf. mass frac.]',\
                     '$^{23}$Na [surf. mass frac.]','$^{24}$Mg [surf. mass frac.]','$^{25}$Mg [surf. mass frac.]',\
                     '$^{26}$Mg [surf. mass frac.]','$^{26}$Al [surf. mass frac.]','$^{26}$Al$_\\mathrm{g}$ [surf. mass frac.]',\
                     '$^{27}$Al [surf. mass frac.]','$^{28}$Si [surf. mass frac.]','$^{29}$Si [surf. mass frac.]'],
                     'catList':['model','abundances','abundances','abundances','abundances','abundances','abundances',\
                     'abundances','abundances','abundances','abundances','abundances'],
                     'header':7,'column_number':12}
    Evol_formats['starevol_s4'] = {'varList':[['line',0],['Si30s',1],['P31s',2],['S32s',3],['S33s',4],['S34s',5],\
                     ['S35s',6],['Cl35s',7],['S36s',8],['Cl36s',9],['Cl37s',10],['Heavys',11]],\
                     'unitsList':['model num','$^{30}$Si [surf. mass frac.]','$^{31}$P [surf. mass frac.]',\
                     '$^{32}$S [surf. mass frac.]','$^{33}$S [surf. mass frac.]','$^{34}$S [surf. mass frac.]',\
                     '$^{35}$S [surf. mass frac.]','$^{35}$Cl [surf. mass frac.]','$^{36}$S [surf. mass frac.]',\
                     '$^{36}$Cl [surf. mass frac.]','$^{37}$Cl [surf. mass frac.]','Heavy el. [surf. mass frac.]'],
                     'catList':['model','abundances','abundances','abundances','abundances','abundances','abundances',\
                     'abundances','abundances','abundances','abundances','abundances'],
                     'header':7,'column_number':12}
    Evol_formats['starevol_v1'] = {'varList':[['line',0],['Tc',1],['Tmax',2],['MrTmax',3],['rhoc',4],['rhoTmax',5],\
                     ['Pc',6],['betac',7],['etac',8],['degpec',9],['epsnu',10],['eps_nuc',11],['epsgrav',12]],\
                     'unitsList':['model num','$\log(T_\mathrm{c}\ [K])$','$\log(T_\mathrm{max}\ [K])$',\
                     '$M_r(T_\\mathrm{max})\ [M_\odot]$',r'$\log(\rho_\mathrm{c}\ [\mathrm{g\,cm}^{-3}])$',\
                     r'$\log(\rho(T_\mathrm{max})\ [\mathrm{g\,cm}^{-3}])$',\
                     '$\log(P_\mathrm{c}\ [\mathrm{erg}\,\mathrm{cm}^{-3}])$',\
                     r'$\beta_\mathrm{c}$','$\eta_\mathrm{c}$','central degree of degeneracy',\
                     r'$\epsilon_{\nu,\mathrm{c}}\ [\mathrm{erg\,g}^{-1}\mathrm{s}^{-1}]$', \
                     r'$\epsilon_\mathrm{grav,c}\ [\mathrm{erg\,g}^{-1}\mathrm{s}^{-1}]$', \
                     r'$\epsilon_\mathrm{nucl,c}\ [\mathrm{erg\,g}^{-1}\mathrm{s}^{-1}]$'], \
                     'catList':['model','centre','model','model','centre','model','centre','centre','centre','centre',\
                     'centre','centre','centre'],
                     'header':7,'column_number':13}
    Evol_formats['starevol_v3'] = {'varList':[['line',0],['conv1_Mb',1],['conv1_Rb',2],['conv1_Tb',3],['conv1_rob',4],\
                     ['conv1_Mt',5],['conv1_Rt',6],['conv1_Tt',7],['conv1_rot',8],['env_Mb',9],['env_Rb',10],\
                     ['env_Tb',11],['env_rob',12]],\
                     'unitsList':['model num','$M_\\mathrm{CZ1,bottom}\ [M_\odot]$','$R_\\mathrm{CZ1,bottom}/R_\\star$',\
                     '$\\log(T_\\mathrm{CZ1,bottom}\ [\mathrm{K}]])$',r'$\log(\rho_\mathrm{CZ1,bottom}\ [\mathrm{g\,cm}^{-3}])$',\
                     '$M_\\mathrm{CZ1,top}\ [M_\odot]$','$R_\\mathrm{CZ1,top}/R_\\star$',\
                     '$\\log(T_\\mathrm{CZ1,top}\ [\mathrm{K}]])$',r'$\log(\rho_\mathrm{CZ1,top}\ [\mathrm{g\,cm}^{-3}])$',\
                     '$M_\\mathrm{env,bottom}\ [M_\odot]$','$R_\\mathrm{env,bottom}/R_\\star$',\
                     '$\\log(T_\\mathrm{env,bottom}\ [\mathrm{K}]])$',r'$\log(\rho_\mathrm{env,bottom}\ [\mathrm{g\,cm}^{-3}])$'],\
                     'catList':['model','convection','convection','convection','convection','convection','convection',\
                     'convection','convection','convection','convection','convection','convection'],\
                     'header':7,'column_number':13}
    Evol_formats['starevol_v11'] = {'varList':[['line',0],['mdot_acc',1],['Racc',2],['Macc',3],['Lacc',4],['k2conv',5],\
                     ['k2rad',6],['Rossby',7],['Omega_surf',8],['Vsurf',9],['Ltot',10],['Fenerg',11],['torque',12]],
                     'unitsList':['model num','$\log(\dot{M}_\mathrm{accr.}\ [M_\odot\,\mathrm{yr}^{-1}])$',\
                     '$R_\\mathrm{accr.}/R_\star$','$M_\\mathrm{accr.}/M_\star$','$\log(L_\\mathrm{accr.}\\ [L_\odot])$',\
                     '$k_\\mathrm{2,conv}$','$k_\\mathrm{2,rad}$','Rossby number','$\Omega_\mathrm{surf}\ [\mathrm{s}^{-1}]$',\
                     '$V_\mathrm{surf}\ [\mathrm{km\,s}^{-1}]$',r'$\mathcal{L}_\mathrm{tot}\ [10^{53}\,\mathrm{g\,cm}^2\,\mathrm{s}^{-1}]$',\
                     '$\\mathcal{F}_\\mathrm{E}(\\ell,\\omega)\\ [\\mathrm{erg\\ s}^{-1}]$',\
                     '$\\mathcal{T}_\\mathrm{s}\\ [\\mathrm{g\\ cm}^2\\mathrm{s}^{-1}]$'],
                     'catList':['model','surface','surface','surface','surface','surface','surface','rotation', \
                     'rotation','rotation','rotation','rotation','rotation'],
                     'header':7,'column_number':13}

    Struc_fmt = ['o2013','o2010','full','full_old']
    Struc_formats = {}
    Struc_formats['o2013'] = {'varList':[['shell',0],['Mfrac',1],['Mr',49],['r',4],['rprev',59],['g',56],['P',2],['Hp',55], \
                ['beta',30],['T',3],['Nabad',28],['Nabrad',13],['kappa',29],['dkdP',17],['dkdT',18],['Kther',51],['rho',14], \
                ['drhodP',21],['delta',22],['mu',42],['mue',68],['muprev',91],['mufit',90],['Nabmu',44],['psi',23],['L',5], \
                ['epsH',10],['epsHe',11],['epsC',12],['eps3a',24],['epsCagO',25],['epsOagNe',26],['epsgrav',27],['epsnu',16], \
                ['dEdP',19],['dEdT',20],['H1',6],['He3',31],['He4',7],['C12',8],['C13',32],['C14',75],['N14',33],['N15',34], \
                ['O16',9],['O17',35],['O18',36],['F18',76],['F19',69],['Ne20',37],['Ne21',70],['Ne22',38],['Na23',71],['Mg24',39], \
                ['Mg25',40],['Mg26',41],['Al26',72],['Al27',73],['Si28_alu',74],['Si28',80],['S32',81],['Ar36',82],['Ca40',83], \
                ['Ti44',84],['Cr48',85],['Fe52',86],['Ni56',87],['neutrons',77],['protons',78],['Omega',43],['Omegacons',58], \
                ['Omegaprev',60],['Omfit',89],['dlodlr',50],['Lang',88],['obla',92],['Ur',52],['Vr',53],['Richardson',45], \
                ['Dconv',46],['Dshear',47],['Dh',57],['Deff',48],['Dcirc',54],['DmagO',61],['DmagX',62],['etask',63],['N2mag',64], \
                ['Bphi',65],['alfven',66],['qmin',67]],'unitsList':['shell number','$M_r/M_\mathrm{tot}$','$M_r\ [M_\odot]$','$r\ [R_\odot]$', \
                '$r_\mathr{prev}\ [R_\odot]$','$g_r\ [\mathrm{cm\,s}^{-2}]$','$P\ [\mathrm{g\,cm}^{-1}\,\mathrm{s}^{-2}]$',\
                '$H_P\ [\mathrm{cm}]$','$\beta=P_\mathrm{gas}/P_\mathrm{tot}$','$T\ [K]$',r'$\nabla_\mathrm{ad}$',\
                r'$\nabla_\mathrm{rad}$','$\kappa\ [\mathrm{cm}^2\,\mathrm{g}^{-1}]$','$\mathrm{d}\ln\kappa/\mathrm{d}\ln P$', \
                '$\mathrm{d}\ln\kappa/\mathrm{d}\ln T$','$K_\mathrm{ther}\ [\mathrm{cm}^2\,\mathrm{s}^{-1}]$',r'$\rho\ [\mathrm{g\,cm}^3]$', \
                r'$\mathrm{d}\ln\rho/\mathrm{d}\ln P$',r'$\delta=-\mathrm{d}\ln\rho/\mathrm{d}\ln T$','$\mu$','$\mu_e$',\
                '$\mu_\mathrm{prev}$','$\mu_\mathrm{fit}$',r'$\nabla_\mu$','$\psi$', \
                '$L_r/L_\mathrm{tot}$','$\epsilon_\mathrm{H}\ [\mathrm{erg\,g}^{-1}\mathrm{s}^{-1}]$', \
                '$\epsilon_\mathrm{He}\ [\mathrm{erg\,g}^{-1}\mathrm{s}^{-1}]$', \
                '$\epsilon_\mathrm{C}\ [\mathrm{erg\,g}^{-1}\mathrm{s}^{-1}]$','$\epsilon_{3\alpha}\ [\mathrm{erg\,g}^{-1}\mathrm{s}^{-1}]$', \
                '$\epsilon_{^{12}C(\alpha,\gamma)^{16}O\ [\mathrm{erg\,g}^{-1}\mathrm{s}^{-1}]$', \
                '$\epsilon_{^{16}O(\alpha,\gamma)^{20}Ne\ [\mathrm{erg\,g}^{-1}\mathrm{s}^{-1}]$', \
                '$\epsilon_\mathrm{grav}\ [\mathrm{erg\,g}^{-1}\mathrm{s}^{-1}]$',r'$-\epsilon_\nu\ [\mathrm{erg\,g}^{-1}\mathrm{s}^{-1}]$', \
                '$\mathrm{d}\ln E/\mathrm{d}\ln P$','$\mathrm{d}\ln E/\mathrm{d}\ln T$','$^1$H [mass frac.]','$^3$He [mass frac.]', \
                '$^4$He [mass frac.]','$^{12}$C [mass frac.]','$^{13}$C [mass frac.]','$^{14}$C [mass frac.]','$^{14}$N [mass frac.]', \
                '$^{15}$N [mass frac.]','$^{16}$O [mass frac.]','$^{17}$O [mass frac.]','$^{18}$O [mass frac.]','$^{18}$F [mass frac.]', \
                '$^{19}$F [mass frac.]','$^{20}$Ne [mass frac.]','$^{21}$Ne [mass frac.]','$^{22}$Ne [mass frac.]','$^{23}$Na [mass frac.]', \
                '$^{24}$Mg [mass frac.]','$^{25}$Mg [mass frac.]','$^{26}$Mg [mass frac.]','$^{26}$Al [mass frac.]', \
                '$^{27}$Al [mass frac.]','$^{28}$Si [mass frac.]','$^{28}$Si [mass frac.]','$^{32}$S [mass frac.]','$^{36}$Ar [mass frac.]', \
                '$^{40}$Ca [mass frac.]','$^{44}$Ti [mass frac.]','$^{48}$Cr [mass frac.]','$^{52}$Fe [mass frac.]', \
                '$^{56}$Ni [mass frac.]','neutrons [mass frac.]','protons [mass frac.]','$\Omega\ [\mathrm{s}^{-1}]$', \
                '$\Omega_{\mathscr{L}\mathrm{,cons.}}\ [\mathrm{s}^{-1}]$','$\Omega_\mathrm{prev}\ [\mathrm{s}^{-1}]$', \
                '$\Omega_\mathrm{fit}\ [\mathrm{s}^{-1}]$','$\mathrm{d}\ln\Omega/\mathrm{d}\ln r$', \
                '$\mathscr{L}_r\ [\mathrm{g\,cm}^2\,\mathrm{s}^{-1}]$','$r_\mathrm{pol}/r_\mathrm{eq}$','$U_r\ [\mathrm{cm\,s}^{-1}]$', \
                '$V_r\ [\mathrm{cm\,s}^{-1}]$','$\mathrm{Ri}=N^2/(\mathrm{d}V/\mathrm{d}z)^2$','$D_\mathrm{conv}\ [\mathrm{cm}^2\,\mathrm{s}^{-1}]$', \
                '$D_\mathrm{shear}\ [\mathrm{cm}^2\,\mathrm{s}^{-1}]$','$D_\mathrm{h}\ [\mathrm{cm}^2\,\mathrm{s}^{-1}]$', \
                '$D_\mathrm{eff}\ [\mathrm{cm}^2\,\mathrm{s}^{-1}]$','$D_\mathrm{circ}\ [\mathrm{cm}^2\,\mathrm{s}^{-1}]$', \
                '$D_{\mathrm{mag,}\Omega}\ [\mathrm{cm}^2\,\mathrm{s}^{-1}]$','$D_{\mathrm{mag,}X}\ [\mathrm{cm}^2\,\mathrm{s}^{-1}]$', \
                '$\eta/K$','$N^2_\mathrm{mag}\ [\mathrm{s}^{-1}]$','$B_\phi\ [G]$','$\omega_\mathrm{Alfven}\ [\mathrm{s}^{-1}]$', \
                '$q_\mathrm{min}$'],'catList':['structure','structure','structure','structure','structure','structure','thermo','thermo','thermo', \
                'thermo','thermo','thermo','thermo','thermo','thermo','thermo','EOS','EOS','EOS','EOS','EOS','EOS','EOS','EOS','EOS','energy', \
                'energy','energy','energy','energy','energy','energy','energy','energy','energy','energy','abundances','abundances', \
                'abundances','abundances','abundances','abundances','abundances','abundances','abundances','abundances','abundances', \
                'abundances','abundances','abundances','abundances','abundances','abundances','abundances','abundances','abundances', \
                'abundances','abundances','abundances','abundances','abundances','abundances','abundances','abundances','abundances', \
                'abundances','abundances','abundances','abundances','rotation','rotation','rotation','rotation','rotation','rotation', \
                'rotation','rotation','rotation','rotation','rotation','rotation','rotation','rotation','rotation','magnetism', \
                'magnetism','magnetism','magnetism','magnetism','magnetism','magnetism'],'header':3,'column_number':93}
    Struc_formats['o2010'] = {'varList':[['shell',0],['Mfrac',1],['Mr',49],['r',4],['rprev',59],['g',56],['P',2],['Hp',55], \
                ['beta',30],['T',3],['Nabad',28],['Nabrad',13],['kappa',29],['dkdP',17],['dkdT',18],['Kther',51],['rho',14], \
                ['drhodP',21],['delta',22],['mu',42],['mue',68],['muprev',91],['mufit',90],['Nabmu',44],['psi',23],['L',5], \
                ['epsH',10],['epsHe',11],['epsC',12],['eps3a',24],['epsCagO',25],['epsOagNe',26],['epsgrav',27],['epsnu',16], \
                ['dEdP',19],['dEdT',20],['H1',6],['He3',31],['He4',7],['C12',8],['C13',32],['C14',75],['N14',33],['N15',34], \
                ['O16',9],['O17',35],['O18',36],['F18',76],['F19',69],['Ne20',37],['Ne21',70],['Ne22',38],['Na23',71],['Mg24',39], \
                ['Mg25',40],['Mg26',41],['Al26',72],['Al27',73],['Si28_alu',74],['Si28',80],['S32',81],['Ar36',82],['Ca40',83], \
                ['Ti44',84],['Cr48',85],['Fe52',86],['Ni56',87],['neutrons',77],['protons',78],['Omega',43],['Omegacons',58], \
                ['Omegaprev',60],['Omfit',89],['dlodlr',50],['Lang',88],['Ur',52],['Vr',53],['Richardson',45], \
                ['Dconv',46],['Dshear',47],['Dh',57],['Deff',48],['Dcirc',54],['DmagO',61],['DmagX',62],['etask',63],['N2mag',64], \
                ['Bphi',65],['alfven',66],['qmin',67]],'unitsList':['shell number','$M_r/M_\mathrm{tot}$','$M_r\ [M_\odot]$','$r\ [R_\odot]$', \
                '$r_\mathr{prev}\ [R_\odot]$','$g_r\ [\mathrm{cm\,s}^{-2}]$','$P\ [\mathrm{g\,cm}^{-1}\,\mathrm{s}^{-2}]$',\
                '$H_P\ [\mathrm{cm}]$','$\beta=P_\mathrm{gas}/P_\mathrm{tot}$','$T\ [K]$',r'$\nabla_\mathrm{ad}$',\
                r'$\nabla_\mathrm{rad}$','$\kappa\ [\mathrm{cm}^2\,\mathrm{g}^{-1}]$','$\mathrm{d}\ln\kappa/\mathrm{d}\ln P$', \
                '$\mathrm{d}\ln\kappa/\mathrm{d}\ln T$','$K_\mathrm{ther}\ [\mathrm{cm}^2\,\mathrm{s}^{-1}]$',r'$\rho\ [\mathrm{g\,cm}^3]$', \
                r'$\mathrm{d}\ln\rho/\mathrm{d}\ln P$',r'$\delta=-\mathrm{d}\ln\rho/\mathrm{d}\ln T$','$\mu$','$\mu_e$',\
                '$\mu_\mathrm{prev}$','$\mu_\mathrm{fit}$',r'$\nabla_\mu$','$\psi$', \
                '$L_r/L_\mathrm{tot}$','$\epsilon_\mathrm{H}\ [\mathrm{erg\,g}^{-1}\mathrm{s}^{-1}]$', \
                '$\epsilon_\mathrm{He}\ [\mathrm{erg\,g}^{-1}\mathrm{s}^{-1}]$', \
                '$\epsilon_\mathrm{C}\ [\mathrm{erg\,g}^{-1}\mathrm{s}^{-1}]$','$\epsilon_{3\alpha}\ [\mathrm{erg\,g}^{-1}\mathrm{s}^{-1}]$', \
                '$\epsilon_{^{12}C(\alpha,\gamma)^{16}O\ [\mathrm{erg\,g}^{-1}\mathrm{s}^{-1}]$', \
                '$\epsilon_{^{16}O(\alpha,\gamma)^{20}Ne\ [\mathrm{erg\,g}^{-1}\mathrm{s}^{-1}]$', \
                '$\epsilon_\mathrm{grav}\ [\mathrm{erg\,g}^{-1}\mathrm{s}^{-1}]$',r'$-\epsilon_\nu\ [\mathrm{erg\,g}^{-1}\mathrm{s}^{-1}]$', \
                '$\mathrm{d}\ln E/\mathrm{d}\ln P$','$\mathrm{d}\ln E/\mathrm{d}\ln T$','$^1$H [mass frac.]','$^3$He [mass frac.]', \
                '$^4$He [mass frac.]','$^{12}$C [mass frac.]','$^{13}$C [mass frac.]','$^{14}$C [mass frac.]','$^{14}$N [mass frac.]', \
                '$^{15}$N [mass frac.]','$^{16}$O [mass frac.]','$^{17}$O [mass frac.]','$^{18}$O [mass frac.]','$^{18}$F [mass frac.]', \
                '$^{19}$F [mass frac.]','$^{20}$Ne [mass frac.]','$^{21}$Ne [mass frac.]','$^{22}$Ne [mass frac.]','$^{23}$Na [mass frac.]', \
                '$^{24}$Mg [mass frac.]','$^{25}$Mg [mass frac.]','$^{26}$Mg [mass frac.]','$^{26}$Al [mass frac.]', \
                '$^{27}$Al [mass frac.]','$^{28}$Si [mass frac.]','$^{28}$Si [mass frac.]','$^{32}$S [mass frac.]','$^{36}$Ar [mass frac.]', \
                '$^{40}$Ca [mass frac.]','$^{44}$Ti [mass frac.]','$^{48}$Cr [mass frac.]','$^{52}$Fe [mass frac.]', \
                '$^{56}$Ni [mass frac.]','neutrons [mass frac.]','protons [mass frac.]','$\Omega\ [\mathrm{s}^{-1}]$', \
                '$\Omega_{\mathscr{L}\mathrm{,cons.}}\ [\mathrm{s}^{-1}]$','$\Omega_\mathrm{prev}\ [\mathrm{s}^{-1}]$', \
                '$\Omega_\mathrm{fit}\ [\mathrm{s}^{-1}]$','$\mathrm{d}\ln\Omega/\mathrm{d}\ln r$', \
                '$\mathscr{L}_r\ [\mathrm{g\,cm}^2\,\mathrm{s}^{-1}]$','$U_r\ [\mathrm{cm\,s}^{-1}]$', \
                '$V_r\ [\mathrm{cm\,s}^{-1}]$','$\mathrm{Ri}=N^2/(\mathrm{d}V/\mathrm{d}z)^2$','$D_\mathrm{conv}\ [\mathrm{cm}^2\,\mathrm{s}^{-1}]$', \
                '$D_\mathrm{shear}\ [\mathrm{cm}^2\,\mathrm{s}^{-1}]$','$D_\mathrm{h}\ [\mathrm{cm}^2\,\mathrm{s}^{-1}]$', \
                '$D_\mathrm{eff}\ [\mathrm{cm}^2\,\mathrm{s}^{-1}]$','$D_\mathrm{circ}\ [\mathrm{cm}^2\,\mathrm{s}^{-1}]$', \
                '$D_{\mathrm{mag,}\Omega}\ [\mathrm{cm}^2\,\mathrm{s}^{-1}]$','$D_{\mathrm{mag,}X}\ [\mathrm{cm}^2\,\mathrm{s}^{-1}]$', \
                '$\eta/K$','$N^2_\mathrm{mag}\ [\mathrm{s}^{-1}]$','$B_\phi\ [G]$','$\omega_\mathrm{Alfven}\ [\mathrm{s}^{-1}]$', \
                '$q_\mathrm{min}$'],'catList':['structure','structure','structure','structure','structure','structure','thermo','thermo','thermo', \
                'thermo','thermo','thermo','thermo','thermo','thermo','thermo','EOS','EOS','EOS','EOS','EOS','EOS','EOS','EOS','EOS','energy', \
                'energy','energy','energy','energy','energy','energy','energy','energy','energy','energy','abundances','abundances', \
                'abundances','abundances','abundances','abundances','abundances','abundances','abundances','abundances','abundances', \
                'abundances','abundances','abundances','abundances','abundances','abundances','abundances','abundances','abundances', \
                'abundances','abundances','abundances','abundances','abundances','abundances','abundances','abundances','abundances', \
                'abundances','abundances','abundances','abundances','rotation','rotation','rotation','rotation','rotation','rotation', \
                'rotation','rotation','rotation','rotation','rotation','rotation','rotation','rotation','magnetism', \
                'magnetism','magnetism','magnetism','magnetism','magnetism','magnetism'],'header':3,'column_number':92}
    Struc_formats['full'] = {'varList':[['shell',0],['Mr',2],['r',1],['P',5],['Pturb',24],['T',3],['Nabad',10],['Nabe',9],['kappa',13], \
                ['dkdrho',14],['dkdT',15],['Cv',6],['rho',4],['dPdrho',7],['dPdT',8],['mu',21],['mu0',22],['L',12],['Lrad',11], \
                ['epsilon',16],['dEdrho',17],['dEdT',18],['H1',19],['He4',20],['HII',27],['HeII',28],['HeIII',29],['Omega',23], \
                ['V_MLT',25],['TOtime',26]],\
                'unitsList':['shell number','$M_r\ [M_\odot]$','$r\ [R_\odot]$','$P\ [\mathrm{g\,cm}^{-1}\,\mathrm{s}^{-2}]$', \
                '$P_\mathrm{turb}\ [\mathrm{g\,cm}^{-1}\,\mathrm{s}^{-2}]$','$T\ [K]$',r'$\nabla_\mathrm{ad}$',r'$\nabla_\mathrm{e}$', \
                '$\kappa\ [\mathrm{cm}^2\,\mathrm{g}^{-1}]$',r'$\mathrm{d}\ln\kappa/\mathrm{d}\ln\rho$','$\mathrm{d}\ln\kappa/\mathrm{d}\ln T$', \
                r'$\mathrm{C}_V\ [\mathrm{ergs\,g}^{-1}\,\mathrm{K}^{-1}]$',r'$\rho\ [\mathrm{g\,cm}^3]$',r'$\mathrm{d}\ln P/\mathrm{d}\ln\rho$', \
                r'$\mathrm{d}\ln P/\mathrm{d}\ln T$','$\mu$','$\mu_0$','$\log(L/L_\odot)$','$\log(L_\mathrm{rad}/L_\odot)$', \
                r'$\epsilon_\mathrm{nucl}+\epsilon_\nu\ [\mathrm{erg\,g}^{-1}\mathrm{s}^{-1}]$',r'$\mathrm{d}\ln E/\mathrm{d}\ln\rho$', \
                '$\mathrm{d}\ln E/\mathrm{d}\ln T$','$^1$H [mass frac.]','$^4$He [mass frac.]','HII/H','HeII/He','HeIII/He', \
                '$\Omega\ [\mathrm{s}^{-1}]$','$V_\mathrm{MLT}\ [\mathrm{cm\,s}^{-1}]$','$t_\mathrm{turn\,over}\ [\mathrm{s}]$'],\
                'catList':['structure','structure','structure','thermo','thermo','thermo','thermo','thermo','thermo','thermo','thermo', \
                'thermo','EOS','EOS','EOS','EOS','EOS','energy','energy','energy','energy','energy','abundances','abundances','abundances',\
                'abundances','abundances','rotation','convection','convection'],\
                'header':12,'column_number':30}
    Struc_formats['full_old'] = {'varList':[['shell',0],['Mr',2],['r',1],['P',5],['Pturb',24],['T',3],['Nabad',10],['Nabe',9],['kappa',13], \
                ['dkdrho',14],['dkdT',15],['Cv',6],['rho',4],['dPdrho',7],['dPdT',8],['mu',21],['mu0',22],['L',12],['Lrad',11], \
                ['epsilon',16],['dEdrho',17],['dEdT',18],['H1',19],['He4',20],['Omega',23]],\
                'unitsList':['shell number','$M_r\ [M_\odot]$','$r\ [R_\odot]$','$P\ [\mathrm{g\,cm}^{-1}\,\mathrm{s}^{-2}]$', \
                '$P_\mathrm{turb}\ [\mathrm{g\,cm}^{-1}\,\mathrm{s}^{-2}]$','$T\ [K]$',r'$\nabla_\mathrm{ad}$',r'$\nabla_\mathrm{e}$', \
                '$\kappa\ [\mathrm{cm}^2\,\mathrm{g}^{-1}]$',r'$\mathrm{d}\ln\kappa/\mathrm{d}\ln\rho$','$\mathrm{d}\ln\kappa/\mathrm{d}\ln T$', \
                r'$\mathrm{C}_V\ [\mathrm{ergs\,g}^{-1}\,\mathrm{K}^{-1}]$',r'$\rho\ [\mathrm{g\,cm}^3]$',r'$\mathrm{d}\ln P/\mathrm{d}\ln\rho$', \
                r'$\mathrm{d}\ln P/\mathrm{d}\ln T$','$\mu$','$\mu_0$','$\log(L/L_\odot)$','$\log(L_\mathrm{rad}/L_\odot)$', \
                r'$\epsilon_\mathrm{nucl}+\epsilon_\nu\ [\mathrm{erg\,g}^{-1}\mathrm{s}^{-1}]$',r'$\mathrm{d}\ln E/\mathrm{d}\ln\rho$', \
                '$\mathrm{d}\ln E/\mathrm{d}\ln T$','$^1$H [mass frac.]','$^4$He [mass frac.]','$\Omega\ [\mathrm{s}^{-1}]$'], \
                'catList':['structure','structure','structure','thermo','thermo','thermo','thermo','thermo','thermo','thermo','thermo', \
                'thermo','EOS','EOS','EOS','EOS','EOS','energy','energy','energy','energy','energy','abundances','abundances','rotation'], \
                'header':11,'column_number':25}

    Cluster_fmt = ['cluster','cluster_old','isochr','isochr_old','isochr_veryold']
    Cluster_formats = {}
    Cluster_formats['cluster'] = {'varList':[['Mini',0],['Zini',1],['Oini',2],['Angle',3],['Bin',4],['M1M2',5], \
                ['M',6],['Rpol',26],['gpol',28],['gmean',29],['Teffcorr',8],['Teff',9],['Teff_gd',11],['Teff_lgd',13], \
                ['L',7],['L_gd',10],['L_lgd',12],['Mbol',14],['Gammaedd',37],['Mdot',35],['dMmech',36], \
                ['Omega_surf',30],['OOc',34],['Vsurf',31],['Vcrit1',32],['Vcrit2',33],['oblat',27],['H1s',38], \
                ['He4s',39],['C12s',40],['C13s',41],['N14s',42],['O16s',43],['O17s',44],['O18s',45],['Ne20s',46], \
                ['Ne22s',47],['Al26s',48],['M_V',15],['U-B',16],['B-V',17],['V-R',18],['V-I',19],['J-K',20], \
                ['H-K',21],['V-K',22],['B2_V1',23],['M_V_noise',24],['B-V_noise',25]],'unitsList':['$M_\mathrm{ini}\,[M_\odot]$',\
                '$Z_\mathrm{ini}$','$\Omega/\Omega_\mathrm{crit,ini}$', \
                '$i\ [^\mathrm{o}]$','binary','$M_1/M_2$','$M\,[M_\odot]$','$R_\mathrm{pol}\,[R_\odot]$', \
                '$\log(g_\mathrm{pol}\,[\mathrm{cm\,s}^{-2}])$','$\log(g_\mathrm{mean}\,[\mathrm{cm\,s}^{-2}])$','$\log(T_\mathrm{eff}\,[\mathrm{K}])$', \
                '$\log(T_\mathrm{eff}\,[\mathrm{K}])$','$\log(T_\mathrm{eff}\,[\mathrm{K}])$', \
                '$\log(T_\mathrm{eff}\,[\mathrm{K}])$','$\log(L/L_\odot)$','$\log(L/L_\odot)$','$\log(L/L_\odot)$', \
                '$\mathrm{M}_\mathrm{bol}$','$\Gamma_\mathrm{Edd}$','$\log(\dot{M}\ [M_\odot\,\mathrm{yr}^{-1}])$', \
                '$\mathrm{d}M_\mathrm{mech}\ [M_\odot]$','$\Omega_\mathrm{surf}\ [\mathrm{s}^{-1}]$', \
                '$\Omega/\Omega_\mathrm{crit}$','$V_\mathrm{surf}\ [\mathrm{km\,s}^{-1}]$', \
                '$V_\mathrm{crit,1}\ [\mathrm{km\,s}^{-1}]$','$V_\mathrm{crit,2}\ [\mathrm{km\,s}^{-1}]$', \
                '$R_\mathrm{pol}/R_\mathrm{eq}$','$^1$H [surf. mass frac.]','$^4$He [surf. mass frac.]', \
                '$^{12}$C [surf. mass frac.]','$^{13}$C [surf. mass frac.]','$^{14}$N [surf. mass frac.]', \
                '$^{16}$O [surf. mass frac.]','$^{17}$O [surf. mass frac.]','$^{18}$O [surf. mass frac.]', \
                '$^{20}$Ne [surf. mass frac.]','$^{22}$Ne [surf. mass frac.]','$^{26}$Al [surf. mass frac.]', \
                '$\mathrm{M}_\mathrm{V}$','U-B','B-V','V-R','V-I','J-K','H-K','V-K','$\mathrm{B}_2-\mathrm{V}_1$', \
                '$\mathrm{M}_\mathrm{V}$','B-V'],'catList':['initial conditions','initial conditions','initial conditions', \
                'initial conditions','initial conditions','initial conditions','global properties', \
                'global properties','global properties','global properties','global properties','global properties', \
                'global properties','global properties','global properties','global properties', \
                'global properties','global properties','global properties','global properties', \
                'global properties','rotation','rotation','rotation','rotation','rotation','rotation', \
                'abundances','abundances','abundances','abundances','abundances','abundances', \
                'abundances','abundances','abundances','abundances','abundances','colours','colours', \
                'colours','colours','colours','colours','colours','colours','colours','colours','colours'],\
                'header':3,'column_number':49}
    Cluster_formats['cluster_old'] = {'varList':[['Mini',0],['Zini',1],['Oini',2],['Angle',3],['Bin',4],['M1M2',5], \
                ['M',6],['Rpol',17],['gpol',19],['Teffcorr',8],['Teff',9],['L',7],['Mbol',10], \
                ['Gammaedd',27],['Mdot',25],['dMmech',26],['Omega_surf',20],['OOc',24],['Vsurf',21], \
                ['Vcrit1',22],['Vcrit2',23],['oblat',18],['H1s',28],['He4s',29],['C12s',30], \
                ['C13s',31],['N14s',32],['O16s',33],['O17s',34],['O18s',35],['Ne20s',36],['Ne22s',37], \
                ['Al26s',38],['M_V',11],['U-B',12],['B-V',13],['B2-V1',14],['M_V_noise',15], \
                ['B-V_noise',16]],'unitsList':['$M_\mathrm{ini}\,[M_\odot]$','$Z_\mathrm{ini}$','$\Omega/\Omega_\mathrm{crit,ini}$', \
                '$i\ [^\mathrm{o}]$','binary','$M_1/M_2$','$M\,[M_\odot]$','$R_\mathrm{pol}\,[R_\odot]$', \
                '$\log(g_\mathrm{pol}\,[\mathrm{cm\,s}^{-2}])$','$\log(T_\mathrm{eff}\,[\mathrm{K}])$', \
                '$\log(T_\mathrm{eff}\,[\mathrm{K}])$','$\log(L/L_\odot)$','$\mathrm{M}_\mathrm{bol}$', \
                '$\Gamma_\mathrm{Edd}$','$\log(\dot{M}\ [M_\odot\,\mathrm{yr}^{-1}])$', \
                '$\mathrm{d}M_\mathrm{mech}\ [M_\odot]$','$\Omega_\mathrm{surf}\ [\mathrm{s}^{-1}]$', \
                '$\Omega/\Omega_\mathrm{crit}$','$V_\mathrm{surf}\ [\mathrm{km\,s}^{-1}]$', \
                '$V_\mathrm{crit,1}\ [\mathrm{km\,s}^{-1}]$','$V_\mathrm{crit,2}\ [\mathrm{km\,s}^{-1}]$', \
                '$R_\mathrm{pol}/R_\mathrm{eq}$','$^1$H [surf. mass frac.]','$^4$He [surf. mass frac.]', \
                '$^{12}$C [surf. mass frac.]','$^{13}$C [surf. mass frac.]','$^{14}$N [surf. mass frac.]', \
                '$^{16}$O [surf. mass frac.]','$^{17}$O [surf. mass frac.]','$^{18}$O [surf. mass frac.]', \
                '$^{20}$Ne [surf. mass frac.]','$^{22}$Ne [surf. mass frac.]','$^{26}$Al [surf. mass frac.]', \
                '$\mathrm{M}_\mathrm{V}$','U-B','B-V','$\mathrm{B}_2-\mathrm{V}_1$','$\mathrm{M}_\mathrm{V}$', \
                'B-V'],'catList':['initial conditions','initial conditions','initial conditions', \
                'initial conditions','initial conditions','initial conditions','global properties', \
                'global properties','global properties','global properties','global properties', \
                'global properties','global properties','global properties','global properties', \
                'global properties','rotation','rotation','rotation','rotation','rotation','rotation', \
                'abundances','abundances','abundances','abundances','abundances','abundances', \
                'abundances','abundances','abundances','abundances','abundances','colours','colours', \
                'colours','colours','colours','colours'],'header':3,'column_number':39}

    Cluster_formats['isochr'] = {'varList':[['Mini',0],['Zini',1],['Oini',2],['M',3],['Rpol',17],['gpol',19], \
                ['Teffcorr',5],['Teff',6],['L',4],['Mbol',7],['Gammaedd',27],['Mdot',25], \
                ['dMmech',26],['Omega_surf',20],['OOc',24],['Vsurf',21],['Vcrit1',22],['Vcrit2',23], \
                ['oblat',18],['H1s',28],['He4s',29],['C12s',30],['C13s',31],['N14s',32],['O16s',33], \
                ['O17s',34],['O18s',35],['Ne20s',36],['Ne22s',37],['Al26s',38],['M_V',8],['U-B',9], \
                ['B-V',10],['V-K',11],['V-R',12],['V-I',13],['J-K',14],['H-K',15],['BC',16]],\
                'unitsList':['$M_\mathrm{ini}\,[M_\odot]$','$Z_\mathrm{ini}$','$\Omega/\Omega_\mathrm{crit,ini}$', \
                '$M\,[M_\odot]$','$R_\mathrm{pol}\,[\mathrm{cm}]$','$\log(g_\mathrm{pol}\,[\mathrm{cm\,s}^{-2}])$', \
                '$\log(T_\mathrm{eff}\,[\mathrm{K}])$','$\log(T_\mathrm{eff}\,[\mathrm{K}])$','$\log(L/L_\odot)$', \
                '$\mathrm{M}_\mathrm{bol}$','$\Gamma_\mathrm{Edd}$','$\log(\dot{M}\ [M_\odot\,\mathrm{yr}^{-1}])$', \
                '$\mathrm{d}M_\mathrm{mech}\ [M_\odot]$','$\Omega_\mathrm{surf}\ [\mathrm{s}^{-1}]$', \
                '$\Omega/\Omega_\mathrm{crit}$','$V_\mathrm{surf}\ [\mathrm{km\,s}^{-1}]$', \
                '$V_\mathrm{crit,1}\ [\mathrm{km\,s}^{-1}]$','$V_\mathrm{crit,2}\ [\mathrm{km\,s}^{-1}]$', \
                '$R_\mathrm{pol}/R_\mathrm{eq}$','$^1$H [surf. mass frac.]','$^4$He [surf. mass frac.]', \
                '$^{12}$C [surf. mass frac.]','$^{13}$C [surf. mass frac.]','$^{14}$N [surf. mass frac.]', \
                '$^{16}$O [surf. mass frac.]','$^{17}$O [surf. mass frac.]','$^{18}$O [surf. mass frac.]', \
                '$^{20}$Ne [surf. mass frac.]','$^{22}$Ne [surf. mass frac.]','$^{26}$Al [surf. mass frac.]', \
                '$\mathrm{M}_\mathrm{V}$','U-B','B-V','V-K', \
                'V-R','V-I','J-K','H-K','Bolometric correction'],'catList':['initial conditions',\
                'initial conditions','initial conditions', \
                'global properties','global properties','global properties','global properties', \
                'global properties','global properties','global properties','global properties', \
                'global properties','global properties','rotation','rotation','rotation','rotation', \
                'rotation','rotation','abundances','abundances','abundances','abundances','abundances', \
                'abundances','abundances','abundances','abundances','abundances','abundances', \
                'colours','colours','colours','colours','colours','colours','colours', \
                'colours','colours'],'header':2,'column_number':39}

    Cluster_formats['isochr_old'] = {'varList':[['Mini',0],['Zini',1],['Oini',2],['M',3],['Rpol',18],['gpol',20], \
                ['Teffcorr',5],['Teff',6],['L',4],['Mbol',7],['Gammaedd',28],['Mdot',26], \
                ['dMmech',27],['Omega_surf',21],['OOc',26],['Vsurf',22],['Vcrit1',23],['Vcrit2',24], \
                ['oblat',19],['H1s',29],['He4s',30],['C12s',31],['C13s',32],['N14s',33],['O16s',34], \
                ['O17s',35],['O18s',36],['Ne20s',37],['Ne22s',38],['Al26s',39],['M_V',8],['U-B',9], \
                ['B-V',10],['B2-V1',11],['V-K',12],['V-R',13],['V-I',14],['J-K',15],['H-K',16],['BC',17]],\
                'unitsList':['$M_\mathrm{ini}\,[M_\odot]$','$Z_\mathrm{ini}$','$\Omega/\Omega_\mathrm{crit,ini}$', \
                '$M\,[M_\odot]$','$R_\mathrm{pol}\,[\mathrm{cm}]$','$\log(g_\mathrm{pol}\,[\mathrm{cm\,s}^{-2}])$', \
                '$\log(T_\mathrm{eff}\,[\mathrm{K}])$','$\log(T_\mathrm{eff}\,[\mathrm{K}])$','$\log(L/L_\odot)$', \
                '$\mathrm{M}_\mathrm{bol}$','$\Gamma_\mathrm{Edd}$','$\log(\dot{M}\ [M_\odot\,\mathrm{yr}^{-1}])$', \
                '$\mathrm{d}M_\mathrm{mech}\ [M_\odot]$','$\Omega_\mathrm{surf}\ [\mathrm{s}^{-1}]$', \
                '$\Omega/\Omega_\mathrm{crit}$','$V_\mathrm{surf}\ [\mathrm{km\,s}^{-1}]$', \
                '$V_\mathrm{crit,1}\ [\mathrm{km\,s}^{-1}]$','$V_\mathrm{crit,2}\ [\mathrm{km\,s}^{-1}]$', \
                '$R_\mathrm{pol}/R_\mathrm{eq}$','$^1$H [surf. mass frac.]','$^4$He [surf. mass frac.]', \
                '$^{12}$C [surf. mass frac.]','$^{13}$C [surf. mass frac.]','$^{14}$N [surf. mass frac.]', \
                '$^{16}$O [surf. mass frac.]','$^{17}$O [surf. mass frac.]','$^{18}$O [surf. mass frac.]', \
                '$^{20}$Ne [surf. mass frac.]','$^{22}$Ne [surf. mass frac.]','$^{26}$Al [surf. mass frac.]', \
                '$\mathrm{M}_\mathrm{V}$','U-B','B-V','$\mathrm{B}_2-\mathrm{V}_1$','V-K', \
                'V-R','V-I','J-K','H-K','Bolometric correction'],'catList':['initial conditions',\
                'initial conditions','initial conditions', \
                'global properties','global properties','global properties','global properties', \
                'global properties','global properties','global properties','global properties', \
                'global properties','global properties','rotation','rotation','rotation','rotation', \
                'rotation','rotation','abundances','abundances','abundances','abundances','abundances', \
                'abundances','abundances','abundances','abundances','abundances','abundances', \
                'colours','colours','colours','colours','colours','colours','colours','colours', \
                'colours','colours'],'header':2,'column_number':40}

    Cluster_formats['isochr_veryold'] = {'varList':[['Mini',0],['Zini',1],['Oini',2],['M',3],['Rpol',12],['gpol',14], \
                ['Teffcorr',5],['Teff',6],['L',4],['Mbol',7],['Gammaedd',22],['Mdot',20], \
                ['dMmech',21],['Omega_surf',15],['OOc',19],['Vsurf',16],['Vcrit1',17],['Vcrit2',18], \
                ['oblat',13],['H1s',23],['He4s',24],['C12s',25],['C13s',26],['N14s',27],['O16s',28], \
                ['O17s',29],['O18s',30],['Ne20s',31],['Ne22s',32],['Al26s',33],['M_V',8],['U-B',9], \
                ['B-V',10],['B2-V1',11]],\
                'unitsList':['$M_\mathrm{ini}\,[M_\odot]$','$Z_\mathrm{ini}$','$\Omega/\Omega_\mathrm{crit,ini}$', \
                '$M\,[M_\odot]$','$R_\mathrm{pol}\,[\mathrm{cm}]$','$\log(g_\mathrm{pol}\,[\mathrm{cm\,s}^{-2}])$', \
                '$\log(T_\mathrm{eff}\,[\mathrm{K}])$','$\log(T_\mathrm{eff}\,[\mathrm{K}])$','$\log(L/L_\odot)$', \
                '$\mathrm{M}_\mathrm{bol}$','$\Gamma_\mathrm{Edd}$','$\log(\dot{M}\ [M_\odot\,\mathrm{yr}^{-1}])$', \
                '$\mathrm{d}M_\mathrm{mech}\ [M_\odot]$','$\Omega_\mathrm{surf}\ [\mathrm{s}^{-1}]$', \
                '$\Omega/\Omega_\mathrm{crit}$','$V_\mathrm{surf}\ [\mathrm{km\,s}^{-1}]$', \
                '$V_\mathrm{crit,1}\ [\mathrm{km\,s}^{-1}]$','$V_\mathrm{crit,2}\ [\mathrm{km\,s}^{-1}]$', \
                '$R_\mathrm{pol}/R_\mathrm{eq}$','$^1$H [surf. mass frac.]','$^4$He [surf. mass frac.]', \
                '$^{12}$C [surf. mass frac.]','$^{13}$C [surf. mass frac.]','$^{14}$N [surf. mass frac.]', \
                '$^{16}$O [surf. mass frac.]','$^{17}$O [surf. mass frac.]','$^{18}$O [surf. mass frac.]', \
                '$^{20}$Ne [surf. mass frac.]','$^{22}$Ne [surf. mass frac.]','$^{26}$Al [surf. mass frac.]', \
                '$\mathrm{M}_\mathrm{V}$','U-B','B-V','$\mathrm{B}_2-\mathrm{V}_1$'],'catList':['initial conditions',\
                'initial conditions','initial conditions', \
                'global properties','global properties','global properties','global properties', \
                'global properties','global properties','global properties','global properties', \
                'global properties','global properties','rotation','rotation','rotation','rotation', \
                'rotation','rotation','abundances','abundances','abundances','abundances','abundances', \
                'abundances','abundances','abundances','abundances','abundances','abundances', \
                'colours','colours','colours','colours'],'header':2,'column_number':34}

    Abund = {'AList':[1,3,4,12,13,14,15,16,17,18,20,22,24,25,26,19,21,23,26,27,28,28,32,36,40,44,48,52,56],\
             'ZList':['H','He','He','C','C','N','N','O','O','O','Ne','Ne','Mg','Mg','Mg','F','Ne','Na','Al','Al','Si\_a','Si','S','Ar','Ca','Ti','Cr','Fe','Ni']}

class ShapeInterpolation():
    """Data and methods needed to determine the surface of a rotating star."""
    def __init__(self):
        self.FileName = os.path.join(MyDriver.Config.get('Paths','DataPath'),'Surface_Omega.dat')
        self.Vector_Omega_Omega_crit = []
        self.Vector_Surface = []
        self.interpolation = interpolate.interp1d([0,0],[0,0])

    def Read_Data(self):
        Data_File = open(self.FileName,'r')

        table = [line.strip().split() for line in Data_File.readlines()[3:]]
        self.Vector_Omega_Omega_crit = [[line[0]] for line in table]
        self.Vector_Surface = [[line[1]] for line in table]
        self.Vector_Oblat = [[line[2]] for line in table]

        self.Vector_Omega_Omega_crit = np.array(self.Vector_Omega_Omega_crit,dtype=np.float64).flat
        self.Vector_Surface = np.array(self.Vector_Surface,dtype=np.float64).flat
        self.Vector_Oblat = 1./np.array(self.Vector_Oblat,dtype=np.float64)
        self.Vector_Oblat = self.Vector_Oblat.flat

        return

    def Define_Interp_OOcShape(self):
        self.interpolation = interpolate.interp1d(self.Vector_Omega_Omega_crit,self.Vector_Surface)
        return

    def Define_Interp_OblatOOc(self):
        oblat_reverse = self.Vector_Oblat[::-1]
        ooc_reverse = self.Vector_Omega_Omega_crit[::-1]
        self.interpolation = interpolate.interp1d(oblat_reverse,ooc_reverse)
        return

    def Define_Interp_OOcOblat(self):
        self.interpolation = interpolate.interp1d(self.Vector_Omega_Omega_crit,self.Vector_Oblat)
        return

class ColourInterpolation():
    """Interpolation in colours and bolometric correction from [Fe/H], g, and Teff.
       Values from Worthey & Lee, ApJS 193 1 (2011)"""
    def __init__(self):
        self.FileName = os.path.join(MyDriver.Config.get('Paths','DataPath'),'DataColours.dat')
        self.FeH_ind = 7
        self.g_ind = 13
        self.Teff_ind = 75
        self.Clrs_ind = 7
        self.Vector_FeH = np.array([-2.5,-2.0,-1.5,-1.0,-0.5,0.0,0.5])
        self.Vector_gsurf = np.array([-0.5,0.0,0.5,1.0,1.5,2.0,2.5,3.0,3.5,4.0,4.5,5.0,5.5])
        self.table_Colours = np.zeros((self.FeH_ind,self.g_ind,self.Teff_ind,self.Clrs_ind+2))
        self.Colours = np.zeros(self.Clrs_ind+1)
        self.theta_init = 5040.0
        self.poly_degree = 4

    def Read_Data(self):
        Vector_Teff,Clrs1,Clrs2,Clrs3,Clrs4,Clrs5,Clrs6,Clrs7,Vector_BC = \
                               np.loadtxt(self.FileName, skiprows=3,usecols=(2,4,5,6,7,8,9,10,11),unpack = True)
        clrs_count_line = 0
        for iFeH in range(self.FeH_ind):
            for ig in range(self.g_ind):
                for iTeff in range(self.Teff_ind):
                    self.table_Colours[iFeH,ig,iTeff,:] = \
                        [self.theta_init/Vector_Teff[clrs_count_line],Clrs1[clrs_count_line],Clrs2[clrs_count_line], \
                        Clrs3[clrs_count_line],Clrs4[clrs_count_line],Clrs5[clrs_count_line],Clrs6[clrs_count_line], \
                        Clrs7[clrs_count_line],Vector_BC[clrs_count_line]]
                    clrs_count_line = clrs_count_line + 1
        return

    def Colours_Conversion(self,ZZ,g_surf,Teff):
        table_interp_Clrs = np.zeros((self.Teff_ind,self.Clrs_ind+2))

        [factor_FeH,Position_Z_before] = Localise_and_Factor(ZZ,self.Vector_FeH,'lin')[0:2]
        [factor_g,Position_g_before] = Localise_and_Factor(g_surf,self.Vector_gsurf,'lin')[0:2]
        for iTeff in range(self.Teff_ind):
            for iClrs in range(self.Clrs_ind+2):
                table_interp_Clrs[iTeff,iClrs] = (1.-factor_FeH)*(1.-factor_g)* \
                                        self.table_Colours[Position_Z_before,Position_g_before,iTeff,iClrs] + \
                                        factor_FeH*(1.-factor_g)* \
                                        self.table_Colours[Position_Z_before+1,Position_g_before,iTeff,iClrs] + \
                                        factor_FeH*factor_g* \
                                        self.table_Colours[Position_Z_before+1,Position_g_before+1,iTeff,iClrs] + \
                                        (1.-factor_FeH)*factor_g* \
                                        self.table_Colours[Position_Z_before,Position_g_before+1,iTeff,iClrs]
        theta = self.theta_init/Teff
        [theta_factor,theta_position] = Localise_and_Factor(theta,table_interp_Clrs[:,0],'lin')[0:2]
        if theta>=table_interp_Clrs[0,0] and theta<=table_interp_Clrs[-1,0]:
            if theta_position>(self.Teff_ind-self.poly_degree-1):
                theta_position = self.Teff_ind-self.poly_degree-1
            self.Colours[:] = interpolate.barycentric_interpolate(table_interp_Clrs[theta_position:theta_position+self.poly_degree+1,0],\
                         table_interp_Clrs[theta_position:theta_position+self.poly_degree+1,1:self.Clrs_ind+2], \
                         theta)
        else:
            for ipoly in range(1,self.Clrs_ind+2):
                self.Colours[ipoly-1] = table_interp_Clrs[theta_position,ipoly] + theta_factor* \
                    (table_interp_Clrs[theta_position+1,ipoly]-table_interp_Clrs[theta_position,ipoly])
        return

def Localise_and_Factor(Wanted,array_in,mode):
    """Localise in the table the position surrounding the current value, and return the interpolation factor.
       Two modes are available, linear or logarithmic."""
    a = 0
    b = array_in.size - 1

    if b == 0:
        factor = 1.
        i = 0
        return [factor,i,i,array_in[i],array_in[i]]
    else:
        while b-a-1 != 0:
            i = (a+b)//2
            if (array_in[i]-Wanted)*(array_in[b]-array_in[0]) <= 0:
                a = i
            else:
                b = i

        if mode == "lin":
            factor = (Wanted - array_in[a])/(array_in[a+1]-array_in[a])
        elif mode == 'log':
            factor = (math.log10(Wanted) - math.log10(array_in[a]))/(math.log10(array_in[a+1])- \
                                                                    math.log10(array_in[a]))
        else:
            print 'Unexpected problem'
            return

    return [factor,a,a+1,array_in[a],array_in[a+1]]

class Driver():
    """Contains all the set-up variables for the tools developed here.
       Uses a config file that is created on the fly if absent."""
    def __init__(self):
        self.Config = ConfigParser.ConfigParser()
        self.Config.optionxform = str
        try:
            with open(os.path.expanduser('~/.GENEC_toolBox.ini')):
                pass
        except IOError:
            try:
                with open(os.path.expanduser('~/.Origin_Tools.ini')) as old_config:
                    with open(os.path.expanduser('~/.GENEC_toolBox.ini'),'w') as Conf_File:
                        for line in old_config:
                            Conf_File.write(line)
            except IOError:
                print('Config file not found: creation of ~/.GENEC_toolBox.ini')
                with open(os.path.expanduser('~/.GENEC_toolBox.ini'),'w') as Conf_File:
                    self.Config.add_section('Paths')
                    source_dir = os.path.dirname(os.path.abspath(__file__))
                    self.Config.set('Paths','ProgPath',source_dir+os.path.sep)
                    Data_Path=os.path.expanduser(raw_input('Enter the path to the data directory (for default, leave blank): '))
                    if Data_Path == '':
                        Data_Path = os .path.join(source_dir,'data/')
                        print 'Data_Path:',Data_Path
                    elif not Data_Path.endswith(os.path.sep):
                        Data_Path += os.path.sep
                    self.Config.set('Paths','DataPath',Data_Path)
                    Fig_Path = os.path.expanduser(raw_input('Enter the path where you want the figure to be created (for default, leave blank): '))
                    if Fig_Path == '':
                        Fig_Path = './'
                    elif not Fig_Path.endswith(os.path.sep):
                        Fig_Path += os.path.sep
                    self.Config.set('Paths','FigPath',Fig_Path)
                    self.Config.write(Conf_File)
                    print 'Configuration file created at: ~/.GENEC_toolBox.ini'
                    for (key,opt) in self.Config.items('Paths'):
                        print '   {0}: {1}'.format(key,opt)
        finally:
            self.Config.read(os.path.expanduser('~/.GENEC_toolBox.ini'))
            try:
                program_path=self.Config.get('Paths','ProgPath')
            except ConfigParser.NoOptionError:
                with open(os.path.expanduser('~/.GENEC_toolBox.ini'),'a') as Conf_File:
                    Conf_File.write('ProgPath: '+os.path.dirname(os.path.abspath(__file__))+'/\n')

        self.Model_list = {}
        self.Model_list_evol = {}
        self.Model_list_struc = {}
        self.Model_list_cluster = {}
        self.modeplot = 'evol'
        self.SelectedModels = []
        self.SelectedModels_evol = []
        self.SelectedModels_struc = []
        self.SelectedModels_cluster = []
        self.added_columns = {'varList':[],'unitsList':[],'catList':[]}

        self.fontSize = 24
        self.ticklength = 8
        self.tickwidth = 1
        self.subplotSep = 0.2
        self.logScale = [False,False]
        self.minorLoc = 0

        self.LatexEnabled = False
        self.lineFlag = 'cycle_colour'
        self.lineWidth = 1
        self.colourFlag = 'cycle'
        self.colourSequence = 'contrast'
        self.colourMap = 'gist_rainbow'
        self.iPoints = False
        self.pointSize = 18
        self.pointFlag = 'cycle_colour'
        self.PSmin = 5
        self.PSmax = 200
        self.emptyPoint = False
        self.axisFlag = [False,False,False,False]
        self.axisLimits = [0.,0.,0.,0.]
        self.CBFlag = [False,False]
        self.CBLimits = [0.,0.]
        self.get_CBlimits = [0.,0.]
        self.CBticksN = 11
        self.axisInv = [False,False]
        self.ilog = [False,False,False]
        self.keepplot = False
        self.multiplot = False
        self.Xvar = 't6'
        self.lastXvar = ''
        self.lastYvar = ''
        self.lastX = []
        self.lastY = []
        self.axisLabel = [False,'']
        self.Link_ModelCurve = True
        self.Cursor_Event_ID = 0
        self.cursor_position = []
        self.cursor_points = []
        self.Kipp_tol = 0.005
        self.steps = False
        self.deltat = 1.e6
        self.timestep_marker = 'o'

        self.closeFig = True
        self.plotConfig = [1,1]

    def checknumber(self,number):
        """Checks whether a number is already attributed and prompts for a new one if necessary."""
        for Existing_Indexes in self.Model_list.keys():
            if number == Existing_Indexes:
                print 'This star number is already attributed to model ',self.Model_list[number].Variables['FileName'][0],'.'
                answer = raw_input('Do you want to overwrite it? y/n ')
                if answer == 'n':
                    print 'The attributed star numbers are : ', self.Model_list.keys()
                    answer = raw_input('Would you like to attribute a new number ? y/n ')
                    if answer == 'n':
                        return False, number
                    else:
                        new_num = int(raw_input('Enter new number: '))
                        if new_num in self.Model_list.keys():
                            print 'Again, this number already exists.'
                            return False, number
                        else:
                            return True, new_num
                else :
                    return True, number
        return True, number

    def store_model(self,Model,num_star):
        """Stores the model number in the database"""
        self.Model_list[num_star] = Model
        if MyDriver.modeplot == 'evol':
            self.Model_list_evol[num_star] = Model
        elif MyDriver.modeplot == 'struc':
            self.Model_list_struc[num_star] = Model
        elif MyDriver.modeplot == 'cluster':
            self.Model_list_cluster[num_star] = Model
        elif MyDriver.modeplot == 'popu':
            self.Model_list_popu[num_star] = Model

    def AddFigure(self,size):
        """Defines the current figure"""
        self.current_Fig = plt.figure(num=None, figsize=size, dpi=80, facecolor='w', edgecolor='k', frameon=True)

    def Store_Axes(self,axe):
        """Saves the figure axes"""
        self.Previous_Axe = axe

    def list_keyOK(self,var,star_list):
        """Verifies the existence of a variable for the list of loaded stars.
           If necessary, creates a new list with only stars for which this key exists."""
        if MyDriver.modeplot == 'evol':
            type = 'star'
        elif MyDriver.modeplot == 'struc':
            type = 'structure'
        elif MyDriver.modeplot == 'cluster':
            type = 'cluster'
        else:
            type = 'model'
        newList=[]
        for i in star_list:
            if var not in self.Model_list[i].Variables.keys():
                pass
            else:
                newList.append(i)
        return newList

    def Zero_LengthOK(self,var,star_list):
        """Verifies that the length of an input vector is non zero.
           If necessary, creates a new list with only stars for which this condition is fulfilled."""
        if MyDriver.modeplot == 'evol':
            type = 'star'
        elif MyDriver.modeplot == 'struc':
            type = 'structure'
        elif MyDriver.modeplot == 'cluster':
            type = 'cluster'
        else:
            type = 'model'
        newList=[]
        for i in star_list:
            if len(self.Model_list[i].Variables[var][0]) == 0:
                pass
            else:
                newList.append(i)
        return newList

class Outputs():
    """Contains some plots utilities."""
    def __init__(self):
        pass

    def Plot(self,x,y,myMask,iColour,iStyle,myLegend,timestep,forced_line=False):
        tempX = self.Variables[x][0]
        tempY = self.Variables[y][0]
        if 'cluster' in self.Variables['format'][0] and not MyDriver.iPoints:
            tempX = tempX[self.Variables['sorted'][0]]
            tempY = tempY[self.Variables['sorted'][0]]

        parseX,parseY = self.parseMask(tempX,tempY,myMask,forced_line)
        one_legend = True
        plotSettings={}
        for myX,myY in zip(parseX,parseY):
            if MyDriver.ilog[0] or MyDriver.logScale[0]:
                mask = myX<=0.
                myX[mask] = 1.e-30
                if MyDriver.ilog[0]:
                    myX = np.log10(myX)
            if MyDriver.ilog[1] or MyDriver.logScale[1]:
                mask = myY<=0.
                myY[mask] = 1.e-30
                if MyDriver.ilog[1]:
                    myY = np.log10(myY)
            if not MyDriver.iPoints:
                if len(myX)!=1:
                    if one_legend:
                        plotSettings={'color':iColour,'ls':iStyle,'lw':MyDriver.lineWidth,'label':myLegend}
                        one_legend = False
                    else:
                        plotSettings={'color':iColour,'ls':iStyle,'lw':MyDriver.lineWidth}
                else:
                    plotSettings={'color':iColour,'marker':'.','markeredgewidth':0.,'ls':''}
            else:
                if one_legend:
                    if MyDriver.emptyPoint:
                        plotSettings={'facecolors':'none','edgecolors':iColour,'marker':iStyle,'s':MyDriver.pointSize,'label':myLegend}
                    else:
                        plotSettings={'c':iColour,'marker':iStyle,'s':MyDriver.pointSize,'label':myLegend}
                    one_legend = False
                else:
                    if MyDriver.emptyPoint:
                        plotSettings={'facecolors':'none','edgecolors':iColour,'marker':iStyle,'s':MyDriver.pointSize}
                    else:
                        plotSettings={'c':iColour,'marker':iStyle,'s':MyDriver.pointSize}
                if iStyle not in Rendering.Point_list or MyDriver.emptyPoint:
                    plotSettings['linewidths'] = 2.
                else:
                    plotSettings['linewidths'] = 0.
            if MyDriver.steps:
                if all([v == True for v in myMask]):
                    x_step,y_step,z_step = Build_timestep(myX,myY,timestep)
                    plt.scatter(x_step,y_step,facecolors='none',edgecolors=iColour,marker=MyDriver.timestep_marker,s=MyDriver.pointSize)
                else:
                    print 'The plotting of timesteps values is not (yet?) compatible with plotif'
            if not MyDriver.iPoints:
                plt.plot(myX,myY,**plotSettings)
            else:
                plt.scatter(myX,myY,**plotSettings)
        if len(myX) > 0:
            MyDriver.lastX = myX
        if len(myY) > 0:
            MyDriver.lastY = myY
        if MyDriver.logScale[0] == True:
            plt.xscale('log')
        else:
            plt.xscale('linear')
        if MyDriver.logScale[1] == True:
            plt.yscale('log')
        else:
            plt.yscale('linear')

    def Get_Segments(self,x,y,myMask):
        tempX = self.Variables[x][0][myMask]
        tempY = self.Variables[y][0][myMask]
        if MyDriver.ilog[0]:
            mask = tempX<=0.
            tempX[mask] = 1.e-30
            tempX = np.log10(tempX)
        if MyDriver.ilog[1]:
            mask = tempY<=0.
            tempY[mask] = 1.e-30
            tempY = np.log10(tempY)
        points = np.array([tempX, tempY]).T.reshape(-1, 1, 2)
        segments = np.concatenate([points[:-1], points[1:]], axis=1)
        return segments

    def parseMask(self,x,y,mask,forced_line):
        myX = []
        myY = []
        begin = []
        end = []
        if mask[0] == True:
            begin.append(0)
        for i in range(1,len(mask)):
            if mask[i-1] == False and mask[i] == True:
                begin.append(i)
            if mask[i-1] == True and mask[i] == False:
                end.append(i-1)
        if mask[-1] == True:
            end.append(len(mask)-1)
        for i in range(len(begin)):
            myX.append(x[begin[i]:end[i]+1])
            myY.append(y[begin[i]:end[i]+1])
        if len(begin) != len(end):
            print 'problem in mask lengths'
            return x,y
        if forced_line:
            tempX = np.array(())
            tempY = np.array(())
            for xi in myX:
                tempX = np.hstack((tempX,xi))
            for yi in myY:
                tempY = np.hstack((tempY,yi))
            myX = [tempX]
            myY = [tempY]
        return myX,myY

class Model(Outputs):
    """Contains all the utilities to read and process the evolution files."""
    def __init__(self):
        self.Variables = {}

    def ColoursCalc(self):
        self.Colours = ColourInterpolation()
        self.Colours.Read_Data()
        imax = np.size(self.Variables['line'][0])
        self.Variables['M_U'] = [np.zeros((imax)),'M$_\mathrm{U}$','colours']
        self.Variables['M_B'] = [np.zeros((imax)),'M$_\mathrm{B}$','colours']
        self.Variables['M_V'] = [np.zeros((imax)),'M$_\mathrm{V}$','colours']
        self.Variables['M_R'] = [np.zeros((imax)),'M$_\mathrm{R}$','colours']
        self.Variables['M_I'] = [np.zeros((imax)),'M$_\mathrm{I}$','colours']
        self.Variables['M_H'] = [np.zeros((imax)),'M$_\mathrm{H}$','colours']
        self.Variables['M_J'] = [np.zeros((imax)),'M$_\mathrm{J}$','colours']
        self.Variables['M_K'] = [np.zeros((imax)),'M$_\mathrm{K}$','colours']
        self.Variables['U-B'] = [np.zeros((imax)),'U-B','colours']
        self.Variables['B-V'] = [np.zeros((imax)),'B-V','colours']
        self.Variables['V-R'] = [np.zeros((imax)),'V-R','colours']
        self.Variables['V-I'] = [np.zeros((imax)),'V-I','colours']
        self.Variables['J-K'] = [np.zeros((imax)),'J-K','colours']
        self.Variables['H-K'] = [np.zeros((imax)),'H-K','colours']
        self.Variables['V-K'] = [np.zeros((imax)),'V-K','colours']
        self.Variables['BC'] =  [np.zeros((imax)),'BC','colours']

        for i in range(self.imax):
            self.Colours.Colours_Conversion(self.Variables['FeH'][0][i],self.Variables['gpol'][0][i],10.**self.Variables['Teff'][0][i])
            self.Variables['M_V'][0][i] = self.Variables['Mbol'][0][i] - self.Colours.Colours[7]
            self.Variables['U-B'][0][i] = self.Colours.Colours[0]
            self.Variables['B-V'][0][i] = self.Colours.Colours[1]
            self.Variables['V-R'][0][i] = self.Colours.Colours[2]
            self.Variables['V-I'][0][i] = self.Colours.Colours[3]
            self.Variables['J-K'][0][i] = self.Colours.Colours[4]
            self.Variables['H-K'][0][i] = self.Colours.Colours[5]
            self.Variables['V-K'][0][i] = self.Colours.Colours[6]
            self.Variables['BC'][0][i] = self.Colours.Colours[7]
        self.Variables['M_B'][0] = self.Variables['B-V'][0]+self.Variables['M_V'][0]
        self.Variables['M_U'][0] = self.Variables['U-B'][0]+self.Variables['M_B'][0]
        self.Variables['M_R'][0] = -self.Variables['V-R'][0]+self.Variables['M_V'][0]
        self.Variables['M_I'][0] = -self.Variables['V-I'][0]+self.Variables['M_V'][0]
        self.Variables['M_K'][0] = -self.Variables['V-K'][0]+self.Variables['M_V'][0]
        self.Variables['M_H'][0] = self.Variables['H-K'][0]+self.Variables['M_K'][0]
        self.Variables['M_J'][0] = self.Variables['J-K'][0]+self.Variables['M_K'][0]
        return

    def Spec_var_o2013(self):
        if self.Variables['format'][0][0] != 'o2013':
            return
        line_skip = False
        self.Variables['ageadv'][0][self.Variables['ageadv'][0]<=0.] = self.Variables['t'][0][-1] - self.Variables['t'][0][-2]
        self.Variables['Zsurf'][0] = self.Variables['Zsurf'][0]-self.Variables['He3s'][0]
        self.Variables['Rpol'] = [np.zeros((self.imax)),'$R_\mathrm{pol}\ [R_\odot]$','surface']
        self.Variables['gpol'] = [np.zeros((self.imax)),'$\log(g_\mathrm{pol}\ [\mathrm{cm\,s}^{-2}])$','surface']

        for i in range(self.imax):
            Actual_Surface = 10.**self.Variables['L'][0][i]*Cst.Lsol /(Cst.sigma*10.**(4.*self.Variables['Teff'][0][i]))
            try:
                Norm_Surface = self.Polar_Radius_f.interpolation(self.Variables['OOc'][0][i])
                r_pol = math.sqrt(Actual_Surface/Norm_Surface)
                g_pol = np.log10(Cst.G*Cst.Msol*self.Variables['M'][0][i]/r_pol**2.)
                self.Variables['Rpol'][0][i] = r_pol/Cst.Rsol
                self.Variables['gpol'][0][i] = g_pol
            except ValueError:
                print 'problem at line ',i+1
                line_skip = True
        if line_skip:
            print 'You need to check this file'
            raise IOError(2,'File seems uncomplete, check it',self.Variables['FileName'][0])
            return
        if self.Variables['FileName'][0][-3:] == '.wg':
            self.Variables['Llostwinds'] = [np.add.accumulate(self.Variables['dlelex'][0]),'$\int\ \dot{\mathscr{L}}\,\mathrm{d}t\ [10^{53}\,\mathrm{g\,cm}^2\,\mathrm{s}^{-1}]$','winds']
            self.Variables['Ltotsys'] = [self.Variables['Ltot'][0] + self.Variables['Llostwinds'][0],'$\mathscr{L}_\mathrm{tot}\ [10^{53}\,\mathrm{g\,cm}^2\,\mathrm{s}^{-1}]$','winds']
        return
    def Spec_var_tgrids(self):
        if self.Variables['format'][0][0] != 'tgrids':
            return
        line_skip = False
        self.Variables['ageadv'][0][self.Variables['ageadv'][0]<=0.] = 1.e-2
        self.Variables['Rpol'] = [np.zeros((self.imax)),'$R_\mathrm{pol}\ [R_\odot]$','surface']
        self.Variables['gpol'] = [np.zeros((self.imax)),'$\log(g_\mathrm{pol}\ [\mathrm{cm\,s}^{-2}])$','surface']

        for i in range(self.imax):
            Actual_Surface = 10.**self.Variables['L'][0][i]*Cst.Lsol /(Cst.sigma*10.**(4.*self.Variables['Teff'][0][i]))
            try:
                Norm_Surface = self.Polar_Radius_f.interpolation(self.Variables['OOc'][0][i])
                r_pol = math.sqrt(Actual_Surface/Norm_Surface)
                g_pol = np.log10(Cst.G*Cst.Msol*self.Variables['M'][0][i]/r_pol**2.)
                self.Variables['Rpol'][0][i] = r_pol/Cst.Rsol
                self.Variables['gpol'][0][i] = g_pol
            except ValueError:
                print 'problem at line ',i+1
                line_skip = True
        if line_skip:
            print 'You need to check this file'
            raise IOError(2,'File seems uncomplete, check it',self.Variables['FileName'][0])
            return
        return

    def Spec_var_tools(self):
        if self.Variables['format'][0][0] != 'tools':
            return
        line_skip = False
        self.Variables['ageadv'][0][self.Variables['ageadv'][0]<=0.] = 1.e-2
        return

    def Spec_var_nami(self):
        if self.Variables['format'][0][0] != 'nami':
            return
        line_skip = False
        self.Variables['ageadv'][0][self.Variables['ageadv'][0]<=0.] = 1.e-2
        self.Variables['gpol'] = [self.Variables['gsurf'][0],'$\log(g_\mathrm{pol}\ [\mathrm{cm\,s}^{-2}])$','surface']
        self.Variables['Rpol'] = [self.Variables['R'],'$R_\mathrm{pol}\ [R_\odot]$','surface']
        return

    def Spec_var_bin(self):
        if self.Variables['format'][0][0] != 'bin':
            return
        line_skip = False
        self.Variables['ageadv'][0][self.Variables['ageadv'][0]<=0.] = self.Variables['t'][0][-1] - self.Variables['t'][0][-2]
        self.Variables['Zsurf'][0] = self.Variables['Zsurf'][0]-self.Variables['He3s'][0]
        self.Variables['Rpol'] = [np.zeros((self.imax)),'$R_\mathrm{pol}\ [R_\odot]$','surface']
        self.Variables['gpol'] = [np.zeros((self.imax)),'$\log(g_\mathrm{pol}\ [\mathrm{cm\,s}^{-2}])$','surface']

        for i in range(self.imax):
            Actual_Surface = 10.**self.Variables['L'][0][i]*Cst.Lsol /(Cst.sigma*10.**(4.*self.Variables['Teff'][0][i]))
            try:
                Norm_Surface = self.Polar_Radius_f.interpolation(self.Variables['OOc'][0][i])
                r_pol = math.sqrt(Actual_Surface/Norm_Surface)
                g_pol = np.log10(Cst.G*Cst.Msol*self.Variables['M'][0][i]/r_pol**2.)
                self.Variables['Rpol'][0][i] = r_pol/Cst.Rsol
                self.Variables['gpol'][0][i] = g_pol
            except ValueError:
                print 'problem at line ',i+1
                line_skip = True
        if line_skip:
            print 'You need to check this file'
            raise IOError(2,'File seems uncomplete, check it',self.Variables['FileName'][0])
            return
        if self.Variables['FileName'][0][-3:] == '.wg':
            self.Variables['Llostwinds'] = [np.add.accumulate(self.Variables['dlelex'][0]),'$\int\ \dot{\mathscr{L}}\,\mathrm{d}t\ [10^{53}\,\mathrm{g\,cm}^2\,\mathrm{s}^{-1}]$','winds']
            self.Variables['Ltotsys'] = [self.Variables['Ltot'][0] + self.Variables['Llostwinds'][0],'$\mathscr{L}_\mathrm{tot}\ [10^{53}\,\mathrm{g\,cm}^2\,\mathrm{s}^{-1}]$','winds']
        return

    def Spec_var_preMS(self):
        if self.Variables['format'][0][0] != 'preMS':
            return
        line_skip = False
        self.Variables['ageadv'][0][self.Variables['ageadv'][0]<=0.] = self.Variables['t'][0][-1] - self.Variables['t'][0][-2]
        self.Variables['Zsurf'][0] = self.Variables['Zsurf'][0]-self.Variables['He3s'][0]
        self.Variables['Rpol'] = [np.zeros((self.imax)),'$R_\mathrm{pol}\ [R_\odot]$','surface']
        self.Variables['gpol'] = [np.zeros((self.imax)),'$\log(g_\mathrm{pol}\ [\mathrm{cm\,s}^{-2}])$','surface']

        for i in range(self.imax):
            Actual_Surface = 10.**self.Variables['L'][0][i]*Cst.Lsol /(Cst.sigma*10.**(4.*self.Variables['Teff'][0][i]))
            try:
                Norm_Surface = self.Polar_Radius_f.interpolation(self.Variables['OOc'][0][i])
                r_pol = math.sqrt(Actual_Surface/Norm_Surface)
                g_pol = np.log10(Cst.G*Cst.Msol*self.Variables['M'][0][i]/r_pol**2.)
                self.Variables['Rpol'][0][i] = r_pol/Cst.Rsol
                self.Variables['gpol'][0][i] = g_pol
            except ValueError:
                print 'problem at line ',i+1
                line_skip = True
        if line_skip:
            print 'You need to check this file'
            raise IOError(2,'File seems uncomplete, check it',self.Variables['FileName'][0])
            return
        if self.Variables['FileName'][0][-3:] == '.wg':
            self.Variables['Llostwinds'] = [np.add.accumulate(self.Variables['dlelex'][0]),'$\int\ \dot{\mathscr{L}}\,\mathrm{d}t\ [10^{53}\,\mathrm{g\,cm}^2\,\mathrm{s}^{-1}]$','winds']
            self.Variables['Ltotsys'] = [self.Variables['Ltot'][0] + self.Variables['Llostwinds'][0],'$\mathscr{L}_\mathrm{tot}\ [10^{53}\,\mathrm{g\,cm}^2\,\mathrm{s}^{-1}]$','winds']
        return

    def Spec_var_starevol(self):
        if self.Variables['format'][0][0] != 'starevol':
            return

        Actual_Surface = self.Variables['L'][0]*Cst.Lsol /(Cst.sigma*self.Variables['Teff'][0]**4.)
        Critical_polar_radius = np.sqrt(Actual_Surface/self.Polar_Radius_f.Vector_Surface[-1])
        O_crit = np.sqrt(8.*Cst.G*Cst.Msol*self.Variables['M'][0]/(27.*Critical_polar_radius**3.))
        OOc = self.Variables['Omega_surf'][0]/O_crit
        OOc[np.where(OOc>1.)] = 1.
        self.Variables['Mcc'] = [np.zeros((len(self.Variables['line'][0]))),'$M_\mathrm{cc}\ [M_\odot]$','centre']
        index = np.where(np.logical_or(self.Variables['phaseSE'][0] == 2,np.logical_or(self.Variables['phaseSE'][0] == 4,self.Variables['phaseSE'][0] > 5)))
        self.Variables['Mcc'][0][index] = self.Variables['conv1_Mt'][0][index]
        self.Variables['Mccrel'] = [np.array(()),'$M_\mathrm{cc}/M_\mathrm{tot}$','centre']
        self.Variables['Mccrel'][0] = self.Variables['Mcc'][0]*self.Variables['M'][0]
        self.Variables['OOc'] = [OOc,'$\Omega/min(\Omega_\mathrm{crit,1},\Omega_\mathrm{crit,2})$','rotation']

        # Convert stuff to log
        self.Variables['L'][0] = np.log10(self.Variables['L'][0])
        self.Variables['Teff'][0] = np.log10(self.Variables['Teff'][0])
        self.Variables['Teffcorr'] = [self.Variables['Teff'][0],self.Variables['Teff'][1],self.Variables['Teff'][2]]

        Norm_Surface = self.Polar_Radius_f.interpolation(self.Variables['OOc'][0])
        r_pol = np.sqrt(Actual_Surface/Norm_Surface)
        g_pol = np.log10(Cst.G*Cst.Msol*self.Variables['M'][0]/r_pol**2.)

        self.Polar_Radius_f.Define_Interp_OOcOblat()
        oblat = self.Polar_Radius_f.interpolation(OOc)
        self.Variables['oblat'] = [oblat,'$R_\mathrm{pol}/R_\mathrm{eq}$','surface']
        Vsurf = self.Variables['Omega_surf'][0]*r_pol/oblat/1.e5
        self.Variables['Vsurf'] = [Vsurf,'$V_\mathrm{surf}\ [\mathrm{km\,s}^{-1}]$','rotation']
        Vcrit1 = 3.*Critical_polar_radius*OOc/2.e5
        self.Variables['Vcrit1'] = [Vcrit1,'$V_\mathrm{crit,1}\ [\mathrm{km\,s}^{-1}]$','rotation']
        # No ways of computing Vcrit2 with starevol formats.
        self.Variables['Vcrit2'] = [Vcrit1,'$V_\mathrm{crit,1}\ [\mathrm{km\,s}^{-1}]$','rotation']


        # This is to come back with the normal interpolation
        self.Polar_Radius_f.Define_Interp_OOcShape()

        self.Variables['Rpol'] = [r_pol/Cst.Rsol,'$R_\mathrm{pol}\ [R_\odot]$','surface']
        self.Variables['gpol'] = [g_pol,'$\log(g_\mathrm{pol}\ [\mathrm{cm\,s}^{-2}])$','surface']
        mask = self.Variables['Mdot'][0]<=0.
        self.Variables['Mdot'][0][mask] = 0.
        self.Variables['Mdot'][0][np.logical_not(mask)] = np.log10(self.Variables['Mdot'][0][np.logical_not(mask)])
        self.Variables['Mdot_mech'] = [np.zeros(np.size(self.Variables['Mdot'][0])),'$\log(\dot{M}\ [M_\odot\,\mathrm{yr}^{-1}])$','surface']
        mask = self.Variables['mdot_acc'][0]<=0.
        self.Variables['mdot_acc'][0][mask] = 0.
        self.Variables['mdot_acc'][0][np.logical_not(mask)] = np.log10(self.Variables['mdot_acc'][0][np.logical_not(mask)])
        mask = self.Variables['Lacc'][0]<=0.
        self.Variables['Lacc'][0][mask] = 0.
        self.Variables['Lacc'][0][np.logical_not(mask)] = np.log10(self.Variables['Lacc'][0][np.logical_not(mask)])

        self.Variables['Tc'][0] = np.log10(self.Variables['Tc'][0])
        self.Variables['Tmax'][0] = np.log10(self.Variables['Tmax'][0])
        self.Variables['rhoc'][0] = np.log10(self.Variables['rhoc'][0])
        self.Variables['rhoTmax'][0] = np.log10(self.Variables['rhoTmax'][0])
        self.Variables['Pc'][0] = np.log10(self.Variables['Pc'][0])

        self.Variables['GammaEdd'] = [np.zeros(np.size(self.Variables['Mdot'][0])),'$\Gamma_\mathrm{Edd}$','surface']
        # no centre angular velocity in starevol, set to 0.
        self.Variables['Omega_cen'] = [np.zeros(np.size(self.Variables['Mdot'][0])),'$V_\mathrm{crit,1}\ [\mathrm{km\,s}^{-1}]$','rotation']
        # no mass-loss correction for rotation in starevol, set to 1.
        self.Variables['rot_corr'] = [np.zeros(np.size(self.Variables['Mdot'][0]))+1.,'$F_\Omega$','rotation']
        self.Variables['Ltot'][0] = self.Variables['Ltot'][0]/1.e53

        return

    def SpecificVariables(self,fmt):
        self.Polar_Radius_f = ShapeInterpolation()
        self.Polar_Radius_f.Read_Data()
        self.Polar_Radius_f.Define_Interp_OOcShape()

        switcher = {
            'o2013': self.Spec_var_o2013(),
            'tgrids': self.Spec_var_tgrids(),
            'tools': self.Spec_var_tools(),
            'nami': self.Spec_var_nami(),
            'bin': self.Spec_var_bin(),
            'preMS': self.Spec_var_preMS(),
            'starevol': self.Spec_var_starevol(),
        }

        return switcher.get(fmt,'Unknown format')

    def read(self,FileName,num_deb,num_fin,format,colour,wa,quiet):
        if ".wg" not in FileName and ".grids" not in FileName and ".dat" not in FileName:
            format = "starevol"
            file_cols = 0

        if format != "starevol":
            if not os.path.isfile(FileName):
                raise IOError(1,'File does not exist, check name and path',FileName)
                return
            lastline = os.popen('tail -1 '+FileName).readline().replace('\n','')
            file_cols = len(lastline.split())
        if format == '':
            for fmt in readList.Evol_fmt:
                if file_cols == readList.Evol_formats[fmt]['column_number'] + len(MyDriver.added_columns['varList']):
                    format = fmt
                    break
            if format == '':
                raise FormatError(1,'column number ='+str(file_cols)+' does not match any known format',FileName)
                return
        if format == 'tgrids':
            if 'Extraction' in os.popen('head -1 '+FileName).readline():
                num_deb=num_deb+15
            colour = True
        if not quiet:
            if format != "starevol":
                print 'Number of columns: '+str(file_cols)+' --> format identified= '+format
                print 'Loading file ',FileName,'...'
            else:
                print 'No extension detected, trying with starevol format.'

        if format == "starevol":
            extensions_list = [".as",".hr",".c1",".c2",".c3",".c4",".s1",".s2",".s3",".s4",".v1",".v3",".v11"]
            FilesToRead = [FileName + ext for ext in extensions_list]
        else:
            FilesToRead = [FileName]

        for Current_FileName in FilesToRead:
            header = self.ReadBlock(format,Current_FileName,file_cols,num_deb,num_fin,quiet)

        StarName = os.path.splitext(FileName)[0][FileName.rfind('/')+1:]
        self.Variables['FileName'] = [FileName,StarName,'model']
        self.Variables['format'] = [[format,header],'format and header lines','reading']
        self.Variables['line_num'] = [[num_deb,num_fin],'boundary lines','reading']
        self.Variables['options'] = [[colour,wa],'options colour and wa','reading']
        self.Variables['line'][0] = self.Variables['line'][0].astype(int)
        massini = self.Variables['M'][0][0]
        self.Variables['Mini'] = [massini,'$M_\mathrm{ini}\ [M_\odot]$','model']
        self.imax = np.size(self.Variables['line'][0])
        if not quiet:
            print 'File read, '+str(self.imax)+' lines.'

        if wa:
            WAfile = FileName.replace('.wg','.wa')
            if WAfile != FileName:
                self.read_wa(WAfile,num_deb-header,num_fin)
            else:
                print 'The wa option is valid only when charging a complete wg file.'

        ind_begH,ind_endH,ind_begHe,ind_endHe,ind_begC,ind_endC,ind_begNe,ind_endNe,ind_begO,ind_endO,ind_begSi,ind_endSi = 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1
        self.Variables['phase'] = [np.array(['' for x in range(self.imax)],dtype=object),'combustion phase','energetics']
        if self.Variables['H1c'][0][0] == self.Variables['H1s'][0][0]:
            ind_begH = np.where(self.Variables['H1c'][0]<np.max(self.Variables['H1c'][0])-3.e-3)[0][0]
        try:
            ind_endH = np.where(self.Variables['H1c'][0]<1.e-5)[0][0]
            ind_begHe = ind_endH + np.where(self.Variables['He4c'][0][ind_endH:]<np.max(self.Variables['He4c'][0])-3.e-3)[0][0]
            ind_endHe = np.where(self.Variables['He4c'][0]<1.e-5)[0][0]
            if ind_endHe != -1:
                ind_begC = ind_endHe + np.where(self.Variables['C12c'][0][ind_endHe:]<self.Variables['C12c'][0][ind_endHe]-3.e-3)[0][0]
                if ind_begC != -1:
                    ind_endC = ind_begC + np.where(self.Variables['C12c'][0][ind_begC:]<1.e-4)[0][0]
            if ind_endC != -1:
                ind_begNe = ind_endC + np.where(self.Variables['Ne20c'][0][ind_endC:]<np.max(self.Variables['Ne20c'][0])-3.e-3)[0][0]
                if ind_begNe != -1:
                    ind_endNe = ind_begNe + np.where(self.Variables['Ne20c'][0][ind_begNe:]<1.e-3)[0][0]
            if ind_endNe != -1:
                ind_begO = ind_endNe + np.where(self.Variables['O16c'][0][ind_endNe:]<np.max(self.Variables['O16c'][0])-3.e-3)[0][0]
                if ind_begO != -1:
                    ind_endO = ind_begO + np.where(self.Variables['O16c'][0][ind_begO:]<1.e-3)[0][0]
            if ind_endO != -1:
                ind_begSi = ind_endO + np.where(self.Variables['Si28c'][0][ind_endO:]<np.max(self.Variables['Si28c'][0])-3.e-3)[0][0]
                if ind_begSi != -1:
                    ind_endSi = ind_begSi + np.where(self.Variables['Si28c'][0][ind_begSi:]<1.e-3)[0][0]
        except:
            pass
        self.Variables['ind_burning_phases'] = [[ind_begH,ind_endH,ind_begHe,ind_endHe,ind_begC,ind_endC,ind_begNe,ind_endNe,ind_begO, \
                                                ind_endO,ind_begSi,ind_endSi],'phases limits','reading']
        if not quiet:
            print 'limits of burning phases:',self.Variables['ind_burning_phases']
        if ind_begH != 0:
            self.Variables['phase'][0][:ind_begH] = 'preH'
        self.Variables['phase'][0][ind_begH:ind_endH] = 'H'
        if ind_endH != -1:
            self.Variables['phase'][0][ind_endH:ind_begHe] = 'HHe'
        if ind_begHe != -1:
            self.Variables['phase'][0][ind_begHe:ind_endHe] = 'He'
        if ind_endHe != -1:
            self.Variables['phase'][0][ind_endHe:ind_begC] = 'HeC'
        if ind_begC != -1:
            self.Variables['phase'][0][ind_begC:ind_endC] = 'C'
        if ind_endC != -1:
            self.Variables['phase'][0][ind_endC:ind_begNe] = 'CNe'
        if ind_begNe != -1:
            self.Variables['phase'][0][ind_begNe:ind_endNe] = 'Ne'
        if ind_endNe != -1:
            self.Variables['phase'][0][ind_endNe:ind_begO] = 'NeO'
        if ind_begO != -1:
            self.Variables['phase'][0][ind_begO:ind_endO] = 'O'
        if ind_endO != -1:
            self.Variables['phase'][0][ind_endO:ind_begSi] = 'OSi'
        if ind_begSi != -1:
            self.Variables['phase'][0][ind_begSi:ind_endSi] = 'Si'
        if ind_endSi != -1:
            self.Variables['phase'][0][ind_endSi:-1] = 'collapse'
        self.Variables['t6'] = [self.Variables['t'][0]/1.e6,'t [Myr]','model']
        self.Variables['t9'] = [self.Variables['t'][0]/1.e9,'t [Gyr]','model']
        self.Variables['ageadv'] = [self.Variables['t'][0][-1] - self.Variables['t'][0],'log(time before collapse [yr])','model']
        if format != 'starevol':
            self.Variables['Mcc'] = [self.Variables['M'][0]*self.Variables['Mccrel'][0],'$M_\mathrm{cc}\ [M_\odot]$','centre']
        if format not in ['tgrids','tools','nami','starevol']:
            self.Variables['ZCext'] = [np.zeros((self.imax)),'$M_\mathrm{ZC,ext}$','surface']
            for i in range(self.imax):
                if self.CZ_array[1,-1,i] != 1.:
                    self.Variables['ZCext'][0][i] = self.Variables['ZCext'][0][i-1]
                else:
                    for j in range(21):
                        if self.CZ_array[1,j,i] == 1.:
                            self.Variables['ZCext'][0][i] = self.CZ_array[0,j,i]
                            break
        if format in ['nami']:
            self.Variables['Teffcorr'] = self.Variables['Teff']
            self.Variables['rhom'][0] = 10.**self.Variables['rhom'][0]
            self.Variables['OOc'] = [np.zeros((len(self.Variables['line'])))]
        if format != 'starevol':
            self.Variables['Mbol'] = [-2.5*self.Variables['L'][0]+4.7554,'$\mathrm{M}_\mathrm{bol}$','surface']
        else:
            self.Variables['Mbol'] = [-2.5*np.log10(self.Variables['L'][0])+4.7554,'$\mathrm{M}_\mathrm{bol}$','surface']
        if format != 'nami':
            if format != 'starevol':
                self.Variables['R'] = [np.sqrt(10.**self.Variables['L'][0]*Cst.Lsol/(4.*math.pi*Cst.sigma))/(10.**(2.*self.Variables['Teff'][0])*Cst.Rsol),'$R\ [R_\odot]$','surface']
            else:
                self.Variables['R'] = [np.sqrt(self.Variables['L'][0]*Cst.Lsol/(4.*math.pi*Cst.sigma))/(self.Variables['Teff'][0]**2.*Cst.Rsol),'$R\ [R_\odot]$','surface']
            self.Variables['rhom'] = [3.*self.Variables['M'][0]*Cst.Msol/(4.*math.pi*(self.Variables['R'][0]*Cst.Rsol)**3.),r'$\rho_\mathrm{m}\ [\mathrm{g\,cm}^3]$','model']
        self.Variables['gsurf'] = [np.log10(Cst.G*self.Variables['M'][0]*Cst.Msol/(self.Variables['R'][0]*Cst.Rsol)**2.),'$\log(g_\mathrm{surf}\ [\mathrm{cm\,s}^{-2}])$','surface']
        self.Variables['fwg'] = [self.Variables['gsurf'][0]-self.Variables['Teff'][0]*4.+16.,"$\log(g/(T_\mathrm{eff}/10'000\,\mathrm{K})^4)$",'surface']
        self.Variables['sL'] = [4.*self.Variables['Teff'][0]-self.Variables['gsurf'][0]-(np.log10(5778.**4.*Cst.Rsol**2./(Cst.G*Cst.Msol))),'$\mathscr{L}/\mathscr{L}_\odot$','surface']
        if format not in ['nami','starevol']:
            if not all(v==0. for v in self.Variables['Vsurf'][0]):
                Vcrit = [min(vcrit1,vcrit2) if vcrit2 > 0. else vcrit1 for [vcrit1,vcrit2] in zip(self.Variables['Vcrit1'][0],self.Variables['Vcrit2'][0])]
                self.Variables['VVc'] = [np.array([veq/vc if vc>0. else 0. for [veq,vc] in zip(self.Variables['Vsurf'][0],Vcrit)]),'$V/V_\mathrm{crit}$','rotation']
                self.Variables['period'] = [2.*math.pi/(self.Variables['Omega_surf'][0]*3600.*24.),'$\mathrm{P\,[d]}$','rotation']
            self.Variables['Vesc'] = [np.sqrt(2.*self.Variables['R'][0]*Cst.Rsol*10.**self.Variables['gsurf'][0])/1.e5,'$V_\mathrm{esc}\ [\mathrm{km\,s}^{-1}]$','winds']
            CTeff = np.zeros((self.imax))
            CTeff[self.Variables['Teff'][0]>=np.log10(21000.)] = 2.65
            CTeff[(self.Variables['Teff'][0] < np.log10(21000.)) & (self.Variables['Teff'][0] > 4.0)] = 1.40
            CTeff[self.Variables['Teff'][0] <= 4.0] = 1.
            self.Variables['Vinf'] = [CTeff*self.Variables['Vesc'][0],'$V_\infty\ [\mathrm{km\,s}^{-1}]$','winds']
            self.Variables['Mdot'][0][self.Variables['Mdot'][0] == 0.] = -30.
            self.Variables['Pwinds'] = [0.5*(10.**self.Variables['Mdot'][0]*Cst.Msol/Cst.year)*(self.Variables['Vinf'][0]*1.e5)**2.,'$P_\mathrm{winds}\ [\mathrm{erg\,s}^{-1}]$','winds']
            self.Variables['Bmin'] = [np.sqrt((10.**self.Variables['Mdot'][0]*Cst.Msol/Cst.year)*self.Variables['Vinf'][0]*1.e5/(self.Variables['R'][0]*Cst.Rsol)),'$B_\mathrm{min}\ [\mathrm{G}]$','winds']
            self.Variables['Zsurf'] = [1.-self.Variables['H1s'][0]-self.Variables['He4s'][0],'$Z_\mathrm{surf}$ [mass frac.]','abundances']
        if format in "starevol":
            self.Variables['Zsurf'] = [1.-self.Variables['H1s'][0]-self.Variables['H2s'][0]-self.Variables['He4s'][0]-self.Variables['He3s'][0],'$Z_\mathrm{surf}$ [mass frac.]','abundances']

        if format != "starevol":
            self.Variables['FeH'] = [np.log10(self.Variables['Zsurf'][0]/Cst.Zsol)-np.log10(self.Variables['H1s'][0]/Cst.Hsol),'Fe/H','abundances']
        else:
            self.Variables['FeH'] = [self.Variables['Zsurf'][0]*0.-0.3,'Fe/H','abundances']
        self.Variables['tauKH'] = [3.*Cst.G*(self.Variables['M'][0]*Cst.Msol)**2./(4.*self.Variables['R'][0]*Cst.Rsol*10.**self.Variables['L'][0]*Cst.Lsol*Cst.year),r'$\tau_{KH}$ [yr]','model']
        self.Variables['NH'] = [np.zeros((self.imax)),'log(N/H [numb.]+12)','abundances']
        mask = self.Variables['H1s'][0]<=0.
        self.Variables['NH'][0][mask] = np.log10(self.Variables['N14s'][0][mask]/14.)+42.
        self.Variables['NH'][0][np.logical_not(mask)] = np.log10(self.Variables['N14s'][0][np.logical_not(mask)]/14.)-np.log10(self.Variables['H1s'][0][np.logical_not(mask)])+12.
        self.Variables['NHrel'] = [self.Variables['NH'][0]-self.Variables['NH'][0][0],'log(N/H)-log(N/H)$_\mathrm{ini}$','abundances']
        self.Variables['NC'] = [np.zeros((self.imax)),'log(N/C [numb.])','abundances']
        mask = self.Variables['C12s'][0]<=0.
        self.Variables['NC'][0][mask] = np.log10(self.Variables['N14s'][0][mask]/14.)-30.
        self.Variables['NC'][0][np.logical_not(mask)] = np.log10(self.Variables['N14s'][0][np.logical_not(mask)]/14.)-np.log10(self.Variables['C12s'][0][np.logical_not(mask)]/12.)
        self.Variables['NCrel'] = [self.Variables['NC'][0]-self.Variables['NC'][0][0],'log(N/C)-log(N/C)$_\mathrm{ini}$','abundances']
        self.Variables['NO'] = [np.zeros((self.imax)),'log(N/O [numb.])','abundances']
        mask = self.Variables['O16s'][0]<=0.
        self.Variables['NO'][0][mask] = np.log10(self.Variables['N14s'][0][mask]/14.)-30.
        self.Variables['NO'][0][np.logical_not(mask)] = np.log10(self.Variables['N14s'][0][np.logical_not(mask)]/14.)-np.log10(self.Variables['O16s'][0][np.logical_not(mask)]/16.)
        self.Variables['NOrel'] = [self.Variables['NO'][0]-self.Variables['NO'][0][0],'log(N/O)-log(N/O)$_\mathrm{ini}$','abundances']
        self.Variables['C12C13'] = [np.zeros((self.imax)),'log($^{12}$C/$^{13}$C [numb.])','abundances']
        mask = self.Variables['C13s'][0]<=0.
        self.Variables['C12C13'][0][mask] = np.log10(self.Variables['C12s'][0][mask]/12.)-30.
        self.Variables['C12C13'][0][np.logical_not(mask)] = np.log10(self.Variables['C12s'][0][np.logical_not(mask)]/12.)-np.log10(self.Variables['C13s'][0][np.logical_not(mask)]/13.)
        self.Variables['C12C13rel'] = [self.Variables['C12C13'][0]-self.Variables['C12C13'][0][0],'log($^{12}$C/$^{13}$C)-log($^{12}$C/$^{13}$C)$_\mathrm{ini}$','abundances']

        self.SpecificVariables(format)
        if colour:
            self.ColoursCalc()
        self.Variables['ageadv'][0] = np.log10(self.Variables['ageadv'][0])

        current_time = self.Variables['t'][0][0]
        self.timestep = []
        self.deltat = MyDriver.deltat
        i=0
        while current_time <= self.Variables['t'][0][-1]:
            if self.Variables['t'][0][i] > current_time:
                current_index = i-1
                current_factor = (current_time-self.Variables['t'][0][current_index])/(self.Variables['t'][0][i]-self.Variables['t'][0][current_index])
                self.timestep.append([current_index,current_factor])
                current_time = current_time+MyDriver.deltat
            if current_time >= self.Variables['t'][0][i]:
                i+=1

        if not quiet:
            print 'File successfully loaded.'
        return

    def TestFloat(self,DataIn):
        """Transform a non-conventional float (ex: 1.00-109) to 0."""
        try:
            float(DataIn)
            return DataIn
        except ValueError:
            return '0.0'

    def read_wa(self,FileName,num_deb,num_fin):
        """Reads the wa file. Called by the option wa=True in loadE()"""
        try:
            wafile = open(FileName,'r')
            print '.wa file found: ',FileName
            wafile.close()
        except IOError as err:
            print('File error:' + str(err))
            wafile2 = raw_input('File '+FileName+' not found. Enter a valid path+name:')
            try:
                with open(wafile2,'r'):
                    print '.wa file found: ',FileName
                    wafile = wafile2
                    wafile2.close()
            except IOError as err2:
                print('File problem: ' + str(err2))
                return

        wafile = open(FileName,'r')
        BigArray = np.genfromtxt(wafile,skip_header=num_deb,comments=None)
        el_num = (BigArray.shape[1]-3)/2
        print el_num,' isotopes read in .wa file'
        for i,A,el in zip(range(el_num),readList.Abund['AList'],readList.Abund['ZList']):
            self.Variables[str(el)+str(A)+'s'] = [BigArray[:num_fin,i+3],'$^{'+str(A)+'}$'+str(el)+' [surf. mass frac.]','abundances']
            self.Variables[str(el)+str(A)+'c'] = [BigArray[:num_fin,el_num+i+3],'$^{'+str(A)+'}$'+str(el)+' [centr. mass frac.]','abundances']

    def read_BurnFile(self,MyBurnFile):
        """Reads the .burn file associated to an evolution file.
           The .burn file must have been generated from the .v files with the program strucData (option 3).
           By default, it is seeked in the same path as the evolution file."""
        try:
            BurnFile = open(MyBurnFile,'r')
            print '.burn file found: ',MyBurnFile
            BurnFile.close()
        except IOError as err:
            print('File error:' + str(err))
            MyBurnFile2 = raw_input('File '+MyBurnFile+' not found. Enter a valid path+name:')
            try:
                MyBurnFile = open(MyBurnFile2,'r')
                print '.burn file found: ',MyBurnFile2
                MyBurnFile.close()
            except IOError as err2:
                print('File problem: ' + str(err2))
                lineB = 0.
                ageB = 0.
                massB = 0.
                epsH = 0.
                epsHe = 0.
                epsC = 0.
                epsNe = 0.
                epsO = 0.
                epsSi = 0.
                return lineB,ageB,massB,epsH,epsHe,epsC,epsNe,epsO,epsSi

        BurnFile = open(MyBurnFile,'r')
        lastline = os.popen('tail -1 '+MyBurnFile).readline().replace('\n','')
        adv_burn = len(lastline.split()) > 12
        BigArray = np.genfromtxt(MyBurnFile,comments=None)
        lineB = BigArray[:,0]
        ageB = BigArray[:,1]
        massB = BigArray[:,2]
        epsH = np.array((BigArray[:,4],BigArray[:,3],BigArray[:,5]))
        epsHe = np.array((BigArray[:,7],BigArray[:,6],BigArray[:,8]))
        epsC = np.array((BigArray[:,10],BigArray[:,9],BigArray[:,11]))
        if adv_burn:
            epsNe = np.array((BigArray[:,13],BigArray[:,12],BigArray[:,14]))
            epsO = np.array((BigArray[:,16],BigArray[:,15],BigArray[:,17]))
            epsSi = np.array((BigArray[:,19],BigArray[:,18],BigArray[:,20]))
        else:
            epsNe = np.zeros((3,len(lineB)))
            epsO = np.zeros((3,len(lineB)))
            epsSi = np.zeros((3,len(lineB)))
        return lineB,ageB,massB,epsH,epsHe,epsC,epsNe,epsO,epsSi

    def ReadBlock(self,format,FileName,file_cols,num_deb,num_fin,quiet):
        if format == 'preMS':
            add_column(['H2c',110],'$^2$H [centr. mass frac.]','abundances',False)
            add_column(['Li6c',111],'$^6$Li [centr. mass frac.]','abundances',False)
            add_column(['Li7c',112],'$^7$Li [centr. mass frac.]','abundances',False)
            add_column(['H2s',113],'$^2$H [surf. mass frac.]','abundances',False)
            add_column(['Li6s',114],'$^6$Li [surf. mass frac.]','abundances',False)
            add_column(['Li7s',115],'$^7$Li [surf. mass frac.]','abundances',False)
            Evol_varList = readList.Evol_formats['o2013']['varList'] + MyDriver.added_columns['varList']
            Evol_unitsList = readList.Evol_formats['o2013']['unitsList'] + MyDriver.added_columns['unitsList']
            Evol_catList = readList.Evol_formats['o2013']['catList'] + MyDriver.added_columns['catList']
            col_num = readList.Evol_formats[format]['column_number']
        else:
            if format == "starevol":
                current_ext = FileName[FileName.rfind(".")+1:]
                format_ext = format+"_"+current_ext
                if not os.path.isfile(FileName):
                    FileName_old = FileName
                    FileName = FileName + ".gz"
                    if not os.path.isfile(FileName):
                        print "No such fileS " + FileName_old + " or " + FileName + "."
                        raise
                        return
            else:
                format_ext = format
            Evol_varList = readList.Evol_formats[format_ext]['varList'] + MyDriver.added_columns['varList']
            Evol_unitsList = readList.Evol_formats[format_ext]['unitsList'] + MyDriver.added_columns['unitsList']
            Evol_catList = readList.Evol_formats[format_ext]['catList'] + MyDriver.added_columns['catList']
            col_num = readList.Evol_formats[format_ext]['column_number'] + len(MyDriver.added_columns['varList'])
            if format == "starevol":
                file_cols = col_num
        header = readList.Evol_formats[format_ext]['header']
        num_deb = num_deb + header

        for MyVar,colNum,MyUnit,MyType in zip([varList[0] for varList in Evol_varList],[varList[1] for varList in Evol_varList],Evol_unitsList,Evol_catList):
            self.Variables[MyVar] = [np.array(()),MyUnit,MyType]

        converters = {}
        for i in range(file_cols):
            converters[i] = lambda s: self.TestFloat(s)

        try:
            toZip = False
            if format == "starevol" and os.path.splitext(FileName)[1] == '.gz':
                toZip = True
                rootName = os.path.splitext(FileName)[0]
                if not quiet:
                    print('unzipped file: '+rootName)
                CommandUnzip = 'gunzip '+FileName
                CommandZip = 'gzip '+rootName
                os.system(CommandUnzip)
                MyFile = rootName
            else:
                MyFile = FileName
            BigArray = np.loadtxt(MyFile,skiprows=num_deb,converters=converters,usecols=range(file_cols))
            if toZip:
                os.system(CommandZip)
        except ValueError:
            os.system(CommandZip)
            print "converters couldn't help, probable format error"
            raise ValueError
            return

        if BigArray.shape[1] != col_num:
            raise FormatError(1,'column number does not match, make sure you entered the correct format for file',FileName)
            return
        if num_fin == -1:
            num_fin = BigArray.shape[0]

        for i,myVar in zip([varList[1] for varList in Evol_varList],[varList[0] for varList in Evol_varList]):
            self.Variables[myVar][0] = BigArray[:num_fin,i]
        if format not in ['tgrids','tools','nami','starevol']:
            j = sorted([varList[1] for varList in Evol_varList])[-(2+len(MyDriver.added_columns['varList']))]+1
            self.CZ_array = np.array([[BigArray[:num_fin,j],BigArray[:num_fin,j+2],BigArray[:num_fin,j+4],BigArray[:num_fin,j+6],BigArray[:num_fin,j+8],BigArray[:num_fin,j+10], \
                                BigArray[:num_fin,j+12],BigArray[:num_fin,j+14],BigArray[:num_fin,j+16],BigArray[:num_fin,j+18],BigArray[:num_fin,j+20],BigArray[:num_fin,j+22], \
                                BigArray[:num_fin,j+24],BigArray[:num_fin,j+26],BigArray[:num_fin,j+28],BigArray[:num_fin,j+30],BigArray[:num_fin,j+32],BigArray[:num_fin,j+34], \
                                BigArray[:num_fin,j+36],BigArray[:num_fin,j+38]],[BigArray[:num_fin,j+1],BigArray[:num_fin,j+3],BigArray[:num_fin,j+5],BigArray[:num_fin,j+7], \
                                BigArray[:num_fin,j+9],BigArray[:num_fin,j+11],BigArray[:num_fin,j+13],BigArray[:num_fin,j+15],BigArray[:num_fin,j+17],BigArray[:num_fin,j+19], \
                                BigArray[:num_fin,j+21],BigArray[:num_fin,j+23],BigArray[:num_fin,j+25],BigArray[:num_fin,j+27],BigArray[:num_fin,j+29],BigArray[:num_fin,j+31], \
                                BigArray[:num_fin,j+33],BigArray[:num_fin,j+35],BigArray[:num_fin,j+37],BigArray[:num_fin,j+39]]])
            standard_columns()

        return header

class Struc(Outputs):
    """Contains all the utilities to read and process the structure files.
       Note that it is not necessary to unzip the .v file before reading."""
    def __init__(self):
        self.Variables = {}

    def make_content_list(self,FileName,format=''):
        MyFile = open(FileName)
        if format in ['o2013','o2010']:
            Struc_begin = "# modnb"
            Test_Length = 7
        elif format in ['full','full_old']:
            Struc_begin = "Model num"
            Test_Length = 9

        Time_Step_Dic = {}
        Next_Line = False
        i = 1
        for MyLine in MyFile:
            if Next_Line and (format in ['o2013','o2010']):
                Next_Line = False
                Current_Model = int(MyLine.split()[0])
                Time_Step_Dic[Current_Model] = [i-1,i-1]
            if MyLine[0:Test_Length] == Struc_begin:
                if format in ['full','full_old']:
                    if i != 1:
                        End_Line = i-1
                        Time_Step_Dic[Current_Model][1] = End_Line
                    Current_Model = int(MyLine.split()[-1])
                    Time_Step_Dic[Current_Model] = [i,i]
                elif format in ['o2013','o2010']:
                    if i != 1:
                        End_Line = i-1
                        Time_Step_Dic[Current_Model][1] = End_Line
                    Next_Line = True
            i += 1
        End_Line = i-1
        Time_Step_Dic[Current_Model][1] = End_Line

        return Time_Step_Dic

    def Spec_var_o2013(self):
        if self.Variables['format'][0] != 'o2013':
            return
        self.Variables['timestep'] = [self.time_step,'$\delta\,t$ [s]','model']
        self.Variables['nshell'] = [self.n_shell,'Total shells','model']
        self.Variables['rprev'][0] = 10.**self.Variables['rprev'][0]/Cst.Rsol
        self.Variables['cs'] = [np.sqrt(self.Variables['P'][0]/(self.Variables['rho'][0]*self.Variables['drhodP'][0])),'$c_\mathrm{sound}\ [\mathrm{cm\,s}^{-1}]$','EOS']
        if all(g==0. for g in self.Variables['g'][0]):
            self.Variables['g'][0] = Cst.G*self.Variables['Mr'][0]*Cst.Msol/self.Variables['r_cm'][0]**2.
        g_r = self.Variables['g'][0]
        if g_r[0] == 0.:
            g_r[0] = g_r[1]
        if g_r[-1] == 0.:
            g_r[-1] = g_r[-2]
        if all(hp==0 for hp in self.Variables['Hp'][0]):
            self.Variables['Hp'][0] = self.Variables['P'][0] / (self.Variables['rho'][0]*self.Variables['g'][0])
        H_P = self.Variables['Hp'][0]
        if H_P[0] == 0.:
            H_P[0] = H_P[1]
        if H_P[-1] == 0.:
            H_P[-1] = H_P[-2]
        self.Variables['N2'] = [g_r*self.Variables['delta'][0]/H_P*(self.Variables['Nabad'][0] \
                            -self.Variables['Nabrad'][0]+self.Variables['Nabmu'][0]/self.Variables['delta'][0]), \
                            '$N^2\ [\mathrm{s}^{-1}]$','structure']
        self.Variables['NT2'] = [g_r*self.Variables['delta'][0]/H_P*(self.Variables['Nabad'][0]-self.Variables['Nabrad'][0]),'$N_T^2\ [\mathrm{s}^{-1}]$','structure']
        self.Variables['Nmu2'] = [g_r/H_P*self.Variables['Nabmu'][0],'$N_\mu^2\ [\mathrm{s}^{-1}]$','structure']
        self.Variables['Cp'] = [self.Variables['P'][0]*self.Variables['delta'][0]/(self.Variables['Nabad'][0]*self.Variables['rho'][0] \
                                *self.Variables['T'][0]),r'$\mathrm{C}_P\ [\mathrm{ergs\,g}^{-1}\,\mathrm{K}^{-1}]$','thermo']

    #U =cst_a*cst_c*T_red**4.*NablaAd_red/(rho_red*kappa_red*MixLength_red**2.*P_red*delta_red)*np.sqrt(8.*Hp_red/(g_red*delta_red))
        U = 3.*Cst.a*Cst.c*self.Variables['T'][0]**3./(self.Variables['rho'][0]**2. \
            *self.Variables['Cp'][0]*self.Variables['kappa'][0]*(1.6*self.Variables['Hp'][0])**2.) \
            *np.sqrt(8.*self.Variables['Hp'][0]/(g_r*self.Variables['delta'][0]))
        U[np.logical_not(self.Convection)] = 0.
        A = 2.*((4.*(self.Variables['Nabrad'][0]-self.Variables['Nabad'][0])/9. + ((19./27.)**3.-1./9.)*U**2.))*U
        A[A<0.] = 0.
        E = 3.*368./729. * U**2.
        D = (A/2.)**2. + (E/3.)**3.
        W = (1./2.*A + np.sqrt(D))**(1./3.)
        x1 = np.zeros(len(U))

        for i in range(len(U)):
            po = np.array([1., -19./9.*U[i], 3.*U[i]**2., -(17./9.*U[i]**3.  \
                    + 8./9.*U[i]*(self.Variables['Nabrad'][0][i]-self.Variables['Nabad'][0][i]))])
            if self.Convection[i]:
                sol = np.roots(po)
                for j in range(3):
                    if np.imag(sol[j]) == 0.:
                        x1[i] = np.real(sol[j])
            else:
                x1[i] = 0.

        self.Variables['Nabla'] = [self.Variables['Nabad'][0] + x1**2. - U**2.,r'$\nabla$','thermo']
        self.Variables['Nabla_int'] = [np.zeros(len(self.Variables['Nabla'][0])),r'$\nabla_\mathrm{int}$','thermo']
        for i in range(len(self.Variables['Nabla_int'][0])):
            if self.Variables['Nabla'][0][i]-self.Variables['Nabad'][0][i]+U[i]**2. >= 0.:
                self.Variables['Nabla_int'][0][i] = self.Variables['Nabad'][0][i] - 2.*U[i]**2. \
                        + 2.*U[i]*np.sqrt(self.Variables['Nabla'][0][i]-self.Variables['Nabad'][0][i]+U[i]**2.)
            else:
                self.Variables['Nabla_int'][0][i] = self.Variables['Nabad'][0][i] - 2.*U[i]**2.
        self.Variables['V_MLT'] = [np.sqrt(g_r*self.Variables['delta'][0]*(self.Variables['Nabla'][0] \
                    -self.Variables['Nabla_int'][0])*(1.6*self.Variables['Hp'][0])**2./(8.*self.Variables['Hp'][0])), \
                    '$V_\mathrm{MLT}\ [\mathrm{cm\,s}^{-1}]$','thermo']

        self.Variables['epsnu'][0] = -self.Variables['epsnu'][0]
        self.Variables['eps_reac'] = [self.Variables['epsH'][0]+self.Variables['epsHe'][0]+self.Variables['epsC'][0]+self.Variables['epsnu'][0],r'$\epsilon_\mathrm{nucl}+\epsilon_\nu\ [\mathrm{erg\,g}^{-1}\mathrm{s}^{-1}]$','energy']
        self.Variables['Veq'] = [self.Variables['Omega'][0]*self.Variables['r_cm'][0]/1.e5,'$V_\mathrm{eq}\ [\mathrm{km\,s}^{-1}]$','rotation']
        if not (self.Variables['Omega'][0]==0.).all():
            self.Variables['OOc'] = [self.Omega_crit_f.interpolation(self.Variables['obla'][0]),'$\Omega_r/\Omega_\mathrm{crit}$','rotation']
        self.Variables['jr'] = [(2./3.)*self.Variables['Omega'][0]*self.Variables['r_cm'][0]**2.,'$\mathscr{j}_{r}\ [\mathrm{cm}^2 \mathrm{s}^{-1}]$','rotation']
        self.Variables['jK'] = [2.*Cst.G*self.Variables['Mr'][0]*Cst.Msol/(Cst.c*math.sqrt(3.)),'$\mathscr{j}_\mathrm{Kerr}\ [\mathrm{cm}^2 \mathrm{s}^{-1}]$','rotation']
        self.Variables['jS'] = [np.sqrt(12.)*Cst.G*self.Variables['Mr'][0]*Cst.Msol/Cst.c,'$\mathscr{j}_\mathrm{Schwarzschild}\ [\mathrm{cm}^2 \mathrm{s}^{-1}]$','rotation']
        Lin = np.cumsum(self.Variables['Lang'][0])
        Mr = self.Variables['Mr'][0]
        Mr[Mr == 0.] = 1.e-10
# a/M with a from Shapiro & Teukolsky, eq. 12.7.2
        a_om = Lin*Cst.c/(Cst.G*(Mr*Cst.Msol)**2.)
        a_om = np.minimum(a_om,1.)
# Shapiro & Teukolsky, eq. 12.7.24
        z1 = 1.+(1.-a_om**2.)**(1./3.)*((1.+a_om)**(1./3.)+(1.-a_om)**(1./3.))
        z2 = np.sqrt(3.*a_om**2.+z1**2.)
        r_msco = 3.+z2-np.sqrt((3.-z1)*(3.+z1+2.*z2))
        self.Variables['jKmax'] = [self.Variables['jK'][0],\
                       '$\mathscr{j}_\mathrm{Kerr}^\mathrm{max}\ [\mathrm{cm}^2 \mathrm{s}^{-1}]$','rotation']
        Numerical_Factor = np.zeros((len(self.Variables['jKmax'][0]))) + 2./math.sqrt(3)
# Shapiro & Teukolsky, eq. 12.7.18
        Numerical_Factor[np.where(a_om < 1.)] = (a_om[np.where(a_om < 1.)]**2. - 2.*a_om[np.where(a_om < 1.)]*np.sqrt(r_msco[np.where(a_om < 1.)])+ \
                                                 r_msco[np.where(a_om < 1.)]**2.)/np.sqrt(r_msco[np.where(a_om < 1.)]**2.*(r_msco[np.where(a_om < 1.)]-3.)+ \
                                                 2*a_om[np.where(a_om < 1.)]*np.sqrt(r_msco[np.where(a_om < 1.)]**3.))
        self.Variables['jKmax'][0] = Numerical_Factor*Cst.G*Mr*Cst.Msol/Cst.c
        self.Variables['Br'] = [np.zeros((self.n_shell)),'$B_r\ [G]$','magnetism']
        ntmask = self.Variables['NT2'][0]!=0.
        self.Variables['Br'][0][ntmask] = self.Variables['Bphi'][0][ntmask]*(2.*self.Variables['Omega'][0][ntmask]*self.Variables['Kther'][0][ntmask] \
                        /(self.Variables['NT2'][0][ntmask]*self.Variables['r'][0][ntmask])**2.)**(1./4.)

        return

    def Spec_var_o2010(self):
        if self.Variables['format'][0] != 'o2010':
            return
        self.Variables['timestep'] = [self.time_step,'$\delta\,t$ [s]','model']
        self.Variables['nshell'] = [self.n_shell,'Total shells','model']
        self.Variables['rprev'][0] = 10.**self.Variables['rprev'][0]/Cst.Rsol
        self.Variables['cs'] = [np.sqrt(self.Variables['P'][0]/(self.Variables['rho'][0]*self.Variables['drhodP'][0])),'$c_\mathrm{sound}\ [\mathrm{cm\,s}^{-1}]$','EOS']
        H_P = self.Variables['Hp'][0]
        if H_P[0] == 0.:
            H_P[0] = H_P[1]
        if H_P[-1] == 0.:
            H_P[-1] = H_P[-2]
        g_r = self.Variables['g'][0]
        if g_r[0] == 0.:
            g_r[0] = g_r[1]
        if g_r[-1] == 0.:
            g_r[-1] = g_r[-2]
        self.Variables['N2'] = [g_r*self.Variables['delta'][0]/H_P*(self.Variables['Nabad'][0] \
                            -self.Variables['Nabrad'][0]+self.Variables['Nabmu'][0]/self.Variables['delta'][0]), \
                            '$N^2\ [\mathrm{s}^{-1}]$','structure']
        self.Variables['NT2'] = [g_r*self.Variables['delta'][0]/H_P*(self.Variables['Nabad'][0]-self.Variables['Nabrad'][0]),'$N_T^2\ [\mathrm{s}^{-1}]$','structure']
        self.Variables['Nmu2'] = [g_r/H_P*self.Variables['Nabmu'][0],'$N_\mu^2\ [\mathrm{s}^{-1}]$','structure']
        self.Variables['Cp'] = [self.Variables['P'][0]*self.Variables['delta'][0]/(self.Variables['Nabad'][0]*self.Variables['rho'][0] \
                                *self.Variables['T'][0]),r'$\mathrm{C}_P\ [\mathrm{ergs\,g}^{-1}\,\mathrm{K}^{-1}]$','thermo']

    #U =cst_a*cst_c*T_red**4.*NablaAd_red/(rho_red*kappa_red*MixLength_red**2.*P_red*delta_red)*np.sqrt(8.*Hp_red/(g_red*delta_red))
        U = 3.*Cst.a*Cst.c*self.Variables['T'][0]**3./(self.Variables['rho'][0]**2. \
            *self.Variables['Cp'][0]*self.Variables['kappa'][0]*(1.6*self.Variables['Hp'][0])**2.) \
            *np.sqrt(8.*self.Variables['Hp'][0]/(g_r*self.Variables['delta'][0]))
        U[np.logical_not(self.Convection)] = 0.
        A = 2.*((4.*(self.Variables['Nabrad'][0]-self.Variables['Nabad'][0])/9. + ((19./27.)**3.-1./9.)*U**2.))*U
        A[A<0.] = 0.
        E = 3.*368./729. * U**2.
        D = (A/2.)**2. + (E/3.)**3.
        W = (1./2.*A + np.sqrt(D))**(1./3.)
        x1 = np.zeros(len(U))

        for i in range(len(U)):
            po = np.array([1., -19./9.*U[i], 3.*U[i]**2., -(17./9.*U[i]**3.  \
                    + 8./9.*U[i]*(self.Variables['Nabrad'][0][i]-self.Variables['Nabad'][0][i]))])
            if self.Convection[i]:
                sol = np.roots(po)
                for j in range(3):
                    if np.imag(sol[j]) == 0.:
                        x1[i] = np.real(sol[j])
            else:
                x1[i] = 0.

        self.Variables['Nabla'] = [self.Variables['Nabad'][0] + x1**2. - U**2.,r'$\nabla$','thermo']
        self.Variables['Nabla_int'] = [np.zeros(len(self.Variables['Nabla'][0])),r'$\nabla_\mathrm{int}$','thermo']
        for i in range(len(self.Variables['Nabla_int'][0])):
            if self.Variables['Nabla'][0][i]-self.Variables['Nabad'][0][i]+U[i]**2. >= 0.:
                self.Variables['Nabla_int'][0][i] = self.Variables['Nabad'][0][i] - 2.*U[i]**2. \
                        + 2.*U[i]*np.sqrt(self.Variables['Nabla'][0][i]-self.Variables['Nabad'][0][i]+U[i]**2.)
            else:
                self.Variables['Nabla_int'][0][i] = self.Variables['Nabad'][0][i] - 2.*U[i]**2.
        self.Variables['V_MLT'] = [np.sqrt(g_r*self.Variables['delta'][0]*(self.Variables['Nabla'][0] \
                    -self.Variables['Nabla_int'][0])*(1.6*self.Variables['Hp'][0])**2./(8.*self.Variables['Hp'][0])), \
                    '$V_\mathrm{MLT}\ [\mathrm{cm\,s}^{-1}]$','thermo']

        self.Variables['epsnu'][0] = -self.Variables['epsnu'][0]
        self.Variables['eps_reac'] = [self.Variables['epsH'][0]+self.Variables['epsHe'][0]+self.Variables['epsC'][0]+self.Variables['epsnu'][0],r'$\epsilon_\mathrm{nucl}+\epsilon_\nu\ [\mathrm{erg\,g}^{-1}\mathrm{s}^{-1}]$','energy']
        self.Variables['Veq'] = [self.Variables['Omega'][0]*self.Variables['r_cm'][0]/1.e5,'$V_\mathrm{eq}\ [\mathrm{km\,s}^{-1}]$','rotation']
        self.Variables['jr'] = [(2./3.)*self.Variables['Omega'][0]*self.Variables['r_cm'][0]**2.,'$\mathscr{j}_{r}\ [\mathrm{cm}^2 \mathrm{s}^{-1}]$','rotation']
        self.Variables['jK'] = [2.*Cst.G*self.Variables['Mr'][0]*Cst.Msol/(Cst.c*math.sqrt(3.)),'$\mathscr{j}_\mathrm{Kerr}\ [\mathrm{cm}^2 \mathrm{s}^{-1}]$','rotation']
        self.Variables['jS'] = [np.sqrt(12.)*Cst.G*self.Variables['Mr'][0]*Cst.Msol/Cst.c,'$\mathscr{j}_\mathrm{Schwarzschild}\ [\mathrm{cm}^2 \mathrm{s}^{-1}]$','rotation']
        Lin = np.cumsum(self.Variables['Lang'][0])
        Mr = self.Variables['Mr'][0]
        Mr[Mr == 0.] = 1.e-10
# a/M with a from Shapiro & Teukolsky, eq. 12.7.2
        a_om = Lin*Cst.c/(Cst.G*(Mr*Cst.Msol)**2.)
        a_om = np.minimum(a_om,1.)
# Shapiro & Teukolsky, eq. 12.7.24
        z1 = 1.+(1.-a_om**2.)**(1./3.)*((1.+a_om)**(1./3.)+(1.-a_om)**(1./3.))
        z2 = np.sqrt(3.*a_om**2.+z1**2.)
        r_msco = 3.+z2-np.sqrt((3.-z1)*(3.+z1+2.*z2))
        self.Variables['jKmax'] = [self.Variables['jK'][0],\
                       '$\mathscr{j}_\mathrm{Kerr}^\mathrm{max}\ [\mathrm{cm}^2 \mathrm{s}^{-1}]$','rotation']
        Numerical_Factor = np.zeros((len(self.Variables['jKmax'][0]))) + 2./math.sqrt(3)
# Shapiro & Teukolsky, eq. 12.7.18
        Numerical_Factor[np.where(a_om < 1.)] = (a_om[np.where(a_om < 1.)]**2. - 2.*a_om[np.where(a_om < 1.)]*np.sqrt(r_msco[np.where(a_om < 1.)])+ \
                                                 r_msco[np.where(a_om < 1.)]**2.)/np.sqrt(r_msco[np.where(a_om < 1.)]**2.*(r_msco[np.where(a_om < 1.)]-3.)+ \
                                                 2*a_om[np.where(a_om < 1.)]*np.sqrt(r_msco[np.where(a_om < 1.)]**3.))
        self.Variables['jKmax'][0] = Numerical_Factor*Cst.G*Mr*Cst.Msol/Cst.c
        self.Variables['Br'] = [np.zeros((self.n_shell)),'$B_r\ [G]$','magnetism']
        ntmask = self.Variables['NT2'][0]!=0.
        self.Variables['Br'][0][ntmask] = self.Variables['Bphi'][0][ntmask]*(2.*self.Variables['Omega'][0][ntmask]*self.Variables['Kther'][0][ntmask] \
                        /(self.Variables['NT2'][0][ntmask]*self.Variables['r'][0][ntmask])**2.)**(1./4.)

        return

    def Spec_var_full(self):
        if self.Variables['format'][0] != 'full':
            return
        self.Variables['Mr'][0] = self.Variables['Mr'][0]/Cst.Msol
        self.Variables['Mfrac'] = [self.Variables['Mr'][0]/self.Variables['M_tot'][0],'$M_r/M_\mathrm{tot}$','structure']
        self.Variables['L'][0][self.Variables['L'][0]>0.] = np.log10(self.Variables['L'][0][self.Variables['L'][0]>0.]/Cst.Lsol)
        self.Variables['L'][0][self.Variables['L'][0]<=0.] = -5.
        self.Variables['Lrad'][0][self.Variables['Lrad'][0]>0.] = np.log10(self.Variables['Lrad'][0][self.Variables['Lrad'][0]>0.]/Cst.Lsol)
        self.Variables['Lrad'][0][self.Variables['Lrad'][0]<=0.] = -5.
        return

    def Spec_var_fullold(self):
        if self.Variables['format'][0] != 'full_old':
            return
        self.Variables['Mr'][0] = self.Variables['Mr'][0]/Cst.Msol
        self.Variables['Mfrac'] = [self.Variables['Mr'][0]/self.Variables['M_tot'][0],'$M_r/M_\mathrm{tot}$','structure']
        self.Variables['L'][0][self.Variables['L'][0]>0.] = np.log10(self.Variables['L'][0][self.Variables['L'][0]>0.]/Cst.Lsol)
        self.Variables['L'][0][self.Variables['L'][0]<=0.] = -5.
        self.Variables['Lrad'][0][self.Variables['Lrad'][0]>0.] = np.log10(self.Variables['Lrad'][0][self.Variables['Lrad'][0]>0.]/Cst.Lsol)
        self.Variables['Lrad'][0][self.Variables['Lrad'][0]<=0.] = -5.
        return

    def SpecificVariables(self,fmt):
        self.Omega_crit_f = ShapeInterpolation()
        self.Omega_crit_f.Read_Data()
        self.Omega_crit_f.Define_Interp_OblatOOc()

        switcher = {
            'o2013': self.Spec_var_o2013(),
            'o2010': self.Spec_var_o2010(),
            'full': self.Spec_var_full(),
            'full_old': self.Spec_var_fullold(),
        }

        return switcher.get(fmt,'Unknown format')

    def read(self,FileName,num_deb,line_to_read,format,quiet):
        print 'In read: num_deb,line_to_read:',num_deb,line_to_read
        if format == '':
            raise FormatError(2,'column number does not match any known format',FileName)
            return
        if not quiet:
            print 'Loading file ',FileName,'...'
        i_ext = FileName.rfind('.')
        fileLength = file_len(FileName)
        if not quiet:
            print 'total length of file:',fileLength

        Struc_varList = readList.Struc_formats[format]['varList'] + MyDriver.added_columns['varList']
        Struc_unitsList = readList.Struc_formats[format]['unitsList'] + MyDriver.added_columns['unitsList']
        Struc_catList = readList.Struc_formats[format]['catList'] + MyDriver.added_columns['catList']
        header = readList.Struc_formats[format]['header']

        for MyVar,MyUnit,MyType in zip([varList[0] for varList in Struc_varList],Struc_unitsList,Struc_catList):
           self.Variables[MyVar] = [np.array(()),MyUnit,MyType]

        MyFile = open(FileName,'r')

        if format == "full" or format == 'full_old':
            Empty_Lines = 0
            for i in range((num_deb)):
                MyFile.readline()
            for MyLine in MyFile:
                if MyLine == "\n":
                    Empty_Lines += 1

        MyFile.seek(0)

        for i in range((num_deb)):
            MyFile.readline()

        if format in ['o2013','o2010']:
            MyFile.readline()
            self.num_model,self.age,self.mass,self.n_shell,self.time_step=MyFile.readline().split()
            self.num_model = int(self.num_model)
            print 'Reading model',self.num_model
            self.age = float(self.age)
            self.mass = float(self.mass)
            self.n_shell = int(self.n_shell)
            self.time_step = float(self.time_step)
            #nfoot = fileLength-self.n_shell-num_deb-header
            line_to_read = line_to_read - header
        elif format in ['full','full_old']:
            self.num_model=MyFile.readline().split()[3]
            self.age=MyFile.readline().split()[3]
            self.mass=MyFile.readline().split()[3]
            self.radius=MyFile.readline().split()[3]
            self.Ltot=MyFile.readline().split()[2]
            self.Teff=MyFile.readline().split()[2]
            if not quiet:
                print 'Model number: ',self.num_model
                print 'Time: ',self.age
                print 'Mass: ',self.mass
                print 'R: ',self.radius
                print 'L: ',self.Ltot
                print 'Teff: ',self.Teff
            #nfoot = fileLength-num_deb-line_to_read-Empty_Lines+2
            line_to_read = line_to_read - header

        MyFile.seek(0)

        BigArray = np.genfromtxt(FileName,skip_header=num_deb+header,max_rows=line_to_read,comments=None)

        for i,myVar in zip([varList[1] for varList in Struc_varList],[varList[0] for varList in Struc_varList]):
            self.Variables[myVar][0] = BigArray[:,i]

        if format in ['o2013','o2010']:
            self.Convection = BigArray[:,15]
            self.Convection = self.Convection >= 0.
        elif format in ['full','full_old']:
            self.Convection = BigArray[:,9]-BigArray[:,10]
            self.Convection = self.Convection == 0.
        self.ConvectiveZones = []
        zone = 0
        if self.Convection[0]:
            self.ConvectiveZones.append([0])
            zone += 1
        for i in range(1,len(self.Convection)):
            if not self.Convection[i] and self.Convection[i-1]:
                self.ConvectiveZones[zone-1].append(i-1)
            if self.Convection[i] and not self.Convection[i-1]:
                self.ConvectiveZones.append([i])
                zone += 1
        if self.Convection[-1]:
            self.ConvectiveZones[zone-1].append(len(self.Convection)-1)

        StarName = os.path.splitext(FileName)[0][FileName.rfind('/')+1:]
        if format in ['full','full_old']:
            StarName = StarName[:StarName.find('_')]
        self.Variables['FileName'] = [FileName,StarName,'model']
        self.Variables['format'] = [format,format,'model']
        self.Variables['Model'] = [int(self.num_model),'model number','model']
        self.Variables['M_tot'] = [float(self.mass),'$M_\mathrm{tot}\ [M_\odot]$','model']
        self.Variables['age'] = [float(self.age),'age [yr]','model']

        self.Variables['r_cm'] = [10.**self.Variables['r'][0],'$r$ [cm]','structure']
        self.Variables['r'][0] = 10.**self.Variables['r'][0]/Cst.Rsol
        self.Variables['P'][0] = 10.**self.Variables['P'][0]
        self.Variables['T'][0] = 10.**self.Variables['T'][0]
        self.Variables['kappa'][0] = 10.**self.Variables['kappa'][0]
        self.Variables['rho'][0] = 10.**self.Variables['rho'][0]

        self.SpecificVariables(format)

        if not quiet:
            print 'File ',FileName, 'successfully loaded.'
        return True

class Cluster(Outputs):
    """Contains all the utilities to read and process the cluster/isochrone files generated by GePSy."""
    def __init__(self):
        self.Variables = {}

    def ColoursCalc(self):
        self.Variables['M_B'] = [self.Variables['B-V'][0]+self.Variables['M_V'][0],'M$_\mathrm{B}$','colours']
        self.Variables['M_U'] = [self.Variables['U-B'][0]+self.Variables['M_B'][0],'M$_\mathrm{U}$','colours']
        if self.Variables['format'][0][0] != 'isochr_veryold':
            self.Variables['M_R'] = [-self.Variables['V-R'][0]+self.Variables['M_V'][0],'M$_\mathrm{R}$','colours']
            self.Variables['M_I'] = [-self.Variables['V-I'][0]+self.Variables['M_V'][0],'M$_\mathrm{I}$','colours']
            self.Variables['M_K'] = [-self.Variables['V-K'][0]+self.Variables['M_V'][0],'M$_\mathrm{K}$','colours']
            self.Variables['M_H'] = [self.Variables['H-K'][0]+self.Variables['M_K'][0],'M$_\mathrm{H}$','colours']
            self.Variables['M_J'] = [self.Variables['J-K'][0]+self.Variables['M_K'][0],'M$_\mathrm{J}$','colours']
        return

    def Spec_var_cluster(self):
        if self.Variables['format'][0][0] != 'cluster':
            return
        self.Variables['Vsini'] = [self.Variables['Vsurf'][0]*np.sin(np.radians(self.Variables['Angle'][0])),'$V\,\sin\,i\ [\mathrm{km\,s}^{-1}]$','rotation']
        self.Variables['R'] = [np.sqrt(10.**self.Variables['L_lgd'][0]*Cst.Lsol/(4.*math.pi*Cst.sigma))/(10.**(2.*self.Variables['Teff_lgd'][0])*Cst.Rsol),'$R\ [R_\odot]$','global properties']
        self.Variables['rhom'] = [3.*self.Variables['M'][0]*Cst.Msol/(4.*math.pi*(self.Variables['R'][0]*Cst.Rsol)**3.),r'$\rho_\mathrm{m}\ [\mathrm{g\,cm}^3]$','global properties']
        self.Variables['gsurf'] = [np.log10(Cst.G*self.Variables['M'][0]*Cst.Msol/(self.Variables['R'][0]*Cst.Rsol)**2.),'$\log(g_\mathrm{surf}\ [\mathrm{cm\,s}^{-2}])$','global properties']
        self.Variables['sL'] = [4.*self.Variables['Teff_lgd'][0]-self.Variables['gsurf'][0]-(np.log10(5778.**4.*Cst.Rsol**2./(Cst.G*Cst.Msol))),'$\log(\mathscr{L}/\mathscr{L}_\odot)$','global properties']
        self.Variables['sLmean'] = [4.*self.Variables['Teff_lgd'][0]-self.Variables['gmean'][0]-(np.log10(Cst.Teffsol**4.*Cst.Rsol**2./(Cst.G*Cst.Msol))),'$\log(\mathscr{L}/\mathscr{L}_\odot)$','global properties']
        self.Variables['fwg'] = [self.Variables['gmean'][0]-self.Variables['Teff_lgd'][0]*4.+16.,"$\log(g/(T_\mathrm{eff}/10'000\,\mathrm{K})^4)$",'global properties']
        self.Variables['period'] = [np.ma.array(2.*math.pi/(self.Variables['Omega_surf'][0]*3600.*24.),mask=self.Variables['Omega_surf'][0]==0.),'$\mathrm{P\,[d]}$','rotation']
        return

    def Spec_var_clusterold(self):
        if self.Variables['format'][0][0] != 'cluster_old':
            return
        self.Variables['Vsini'] = [self.Variables['Vsurf'][0]*np.sin(np.radians(self.Variables['Angle'][0])),'$V\,\sin\,i\ [\mathrm{km\,s}^{-1}]$','rotation']
        self.Variables['R'] = [np.sqrt(10.**self.Variables['L_lgd'][0]*Cst.Lsol/(4.*math.pi*Cst.sigma))/(10.**(2.*self.Variables['Teff_lgd'][0])*Cst.Rsol),'$R\ [R_\odot]$','global properties']
        self.Variables['rhom'] = [3.*self.Variables['M'][0]*Cst.Msol/(4.*math.pi*(self.Variables['R'][0]*Cst.Rsol)**3.),r'$\rho_\mathrm{m}\ [\mathrm{g\,cm}^3]$','global properties']
        self.Variables['gsurf'] = [np.log10(Cst.G*self.Variables['M'][0]*Cst.Msol/(self.Variables['R'][0]*Cst.Rsol)**2.),'$\log(g_\mathrm{surf}\ [\mathrm{cm\,s}^{-2}])$','global properties']
        self.Variables['sL'] = [4.*self.Variables['Teff_lgd'][0]-self.Variables['gsurf'][0]-(np.log10(5778.**4.*Cst.Rsol**2./(Cst.G*Cst.Msol))),'$\log(\mathscr{L}/\mathscr{L}_\odot)$','global properties']
        self.Variables['sLmean'] = [4.*self.Variables['Teff_lgd'][0]-self.Variables['gmean'][0]-(np.log10(Cst.Teffsol**4.*Cst.Rsol**2./(Cst.G*Cst.Msol))),'$\log(\mathscr{L}/\mathscr{L}_\odot)$','global properties']
        self.Variables['fwg'] = [self.Variables['gmean'][0]-self.Variables['Teff_lgd'][0]*4.+16.,"$\log(g/(T_\mathrm{eff}/10'000\,\mathrm{K})^4)$",'global properties']
        self.Variables['period'] = [np.ma.array(2.*math.pi/(self.Variables['Omega_surf'][0]*3600.*24.),mask=self.Variables['Omega_surf'][0]==0.),'$\mathrm{P\,[d]}$','rotation']
        return

    def Spec_var_isochr(self):
        if self.Variables['format'][0][0] != 'isochr':
            return
        self.Variables['fwg'] = [self.Variables['gpol'][0]-self.Variables['Teff'][0]*4.+16.,"$\log(g/(T_\mathrm{eff}/10'000\,\mathrm{K})^4)$",'global properties']
        self.Variables['period'] = [np.ma.array(2.*math.pi/(self.Variables['Omega_surf'][0]*3600.*24.),mask=self.Variables['Omega_surf'][0]==0.),'$\mathrm{P\,[d]}$','rotation']
        return

    def Spec_var_isochrold(self):
        if self.Variables['format'][0][0] != 'isochr_old':
            return
        self.Variables['fwg'] = [self.Variables['gpol'][0]-self.Variables['Teff'][0]*4.+16.,"$\log(g/(T_\mathrm{eff}/10'000\,\mathrm{K})^4)$",'global properties']
        self.Variables['period'] = [np.ma.array(2.*math.pi/(self.Variables['Omega_surf'][0]*3600.*24.),mask=self.Variables['Omega_surf'][0]==0.),'$\mathrm{P\,[d]}$','rotation']
        return

    def Spec_var_isochrveryold(self):
        if self.Variables['format'][0][0] != 'isochr_old':
            return
        self.Variables['period'] = [np.ma.array(2.*math.pi/(self.Variables['Omega_surf'][0]*3600.*24.),mask=self.Variables['Omega_surf'][0]==0.),'$\mathrm{P\,[d]}$','rotation']
        return

    def SpecificVariables(self,fmt):

        switcher = {
            'cluster': self.Spec_var_cluster(),
            'cluster_old': self.Spec_var_clusterold(),
            'isochr': self.Spec_var_isochr(),
            'isochr_old': self.Spec_var_isochrold(),
            'isochr_veryold': self.Spec_var_isochrveryold(),
        }

        return switcher.get(fmt,'Unknown format')

    def read(self,FileName,num_deb,num_fin,format,quiet,random):
        if not os.path.isfile(FileName):
            raise IOError(1,'File does not exist, check name and path',FileName)
            return
        if not quiet:
            print 'Loading file ',FileName,'...'
        lastline = os.popen('tail -1 '+FileName).readline().replace('\n','')
        fileLength = file_len(FileName)+1
        file_cols = len(lastline.split())
        if not quiet:
            print 'number of columns:',file_cols
        if format == '':
            if 'WARNING' in os.popen('head -1 '+FileName).readline():
                for fmt in readList.Cluster_fmt[0:2]:
                    if file_cols == readList.Cluster_formats[fmt]['column_number'] + len(MyDriver.added_columns['varList']):
                        format = fmt
                        break
            else:
                for fmt in readList.Cluster_fmt[2:5]:
                    if file_cols == readList.Cluster_formats[fmt]['column_number'] + len(MyDriver.added_columns['varList']):
                        format = fmt
                        break
        if not quiet:
            print 'format identified=',format
        if num_fin == -1:
            num_fin = fileLength

        Cluster_varList = readList.Cluster_formats[format]['varList'] + MyDriver.added_columns['varList']
        Cluster_unitsList = readList.Cluster_formats[format]['unitsList'] + MyDriver.added_columns['unitsList']
        Cluster_catList = readList.Cluster_formats[format]['catList'] + MyDriver.added_columns['catList']
        header = readList.Cluster_formats[format]['header']
        num_deb = num_deb + header

        for MyVar,MyUnit,MyType in zip([varList[0] for varList in Cluster_varList],Cluster_unitsList,Cluster_catList):
           self.Variables[MyVar] = [np.array(()),MyUnit,MyType]

        BigArray = np.genfromtxt(FileName,skip_header=num_deb,max_rows=num_fin-num_deb-1)

        if random != 0:
            ind = np.random.randint(0,BigArray.shape[0]-1,random)
            BigArray = BigArray[ind,:]

        for i,myVar in zip([varList[1] for varList in Cluster_varList],[varList[0] for varList in Cluster_varList]):
            self.Variables[myVar][0] = BigArray[:,i]

        ModelName = FileName[FileName.rfind('/')+1:]
        self.Variables['FileName'] = [FileName,ModelName,'model']
        self.Variables['format'] = [[format,header],'format and header lines','reading']
        self.Variables['line_num'] = [num_deb,'starting line','reading']
        self.Variables['Mdot'][0][self.Variables['Mdot'][0]==0.] = -30.
        imax = np.size(self.Variables['Mini'][0])
        if 'cluster' in format:
            self.Variables['sorted'] = [np.argsort(self.Variables['Mini'][0]),'Mini-sorted index','reading']
        if not quiet:
            print str(imax)+' lines read.'

        self.Variables['NH'] = [np.zeros((imax)),'log(N/H [numb.]+12)','abundances']
        mask = self.Variables['H1s'][0]<=0.
        self.Variables['NH'][0][mask] = np.log10(self.Variables['N14s'][0][mask]/14.)+42.
        self.Variables['NH'][0][np.logical_not(mask)] = np.log10(self.Variables['N14s'][0][np.logical_not(mask)]/14.)-np.log10(self.Variables['H1s'][0][np.logical_not(mask)])+12.
        self.Variables['NC'] = [np.zeros((imax)),'log(N/C [numb.])','abundances']
        mask = self.Variables['C12s'][0]<=0.
        self.Variables['NC'][0][mask] = np.log10(self.Variables['N14s'][0][mask]/14.)-30.
        self.Variables['NC'][0][np.logical_not(mask)] = np.log10(self.Variables['N14s'][0][np.logical_not(mask)]/14.)-np.log10(self.Variables['C12s'][0][np.logical_not(mask)]/12.)
        self.Variables['NCrel'] = [self.Variables['NC'][0]-np.log10(12.*Cst.Nsol/(14.*Cst.C12sol)),'log(N/C)-log(N/C)$_\mathrm{ini}$','abundances']
        self.Variables['NO'] = [np.zeros((imax)),'log(N/O [numb.])','abundances']
        mask = self.Variables['O16s'][0]<=0.
        self.Variables['NO'][0][mask] = np.log10(self.Variables['N14s'][0][mask]/14.)-30.
        self.Variables['NO'][0][np.logical_not(mask)] = np.log10(self.Variables['N14s'][0][np.logical_not(mask)]/14.)-np.log10(self.Variables['O16s'][0][np.logical_not(mask)]/16.)
        self.Variables['NOrel'] = [self.Variables['NO'][0]-np.log10(16.*Cst.Nsol/(14.*Cst.Osol)),'log(N/O)-log(N/O)$_\mathrm{ini}$','abundances']
        self.Variables['C12C13'] = [np.zeros((imax)),'log($^{12}$C/$^{13}$C [numb.])','abundances']
        mask = self.Variables['C13s'][0]<=0.
        self.Variables['C12C13'][0][mask] = np.log10(self.Variables['C12s'][0][mask]/12.)-30.
        self.Variables['C12C13'][0][np.logical_not(mask)] = np.log10(self.Variables['C12s'][0][np.logical_not(mask)]/12.)-np.log10(self.Variables['C13s'][0][np.logical_not(mask)]/13.)
        self.Variables['C12C13rel'] = [self.Variables['C12C13'][0]-np.log10(13.*Cst.C12sol/(12.*Cst.C13sol)),'log($^{12}$C/$^{13}$C)-log($^{12}$C/$^{13}$C)$_\mathrm{ini}$','abundances']

        self.SpecificVariables(format)
        self.ColoursCalc()

        if not quiet:
            print 'File ',ModelName, 'successfully loaded.'
        return

    def Colour_correction(self,excess,dist_mod):
        """Correction of the M_V and B-V for a distance modulus and a colour excess, with
           the average interstellar extinction curve R_V = A_V/E(B-V) = 3.1.
           Called by the direct command colour_corr(excess,dist_mod,num_star)."""
        self.Variables['M_V_corr']=[self.Variables['M_V'][0]+dist_mod+3.1*excess,'$\mathrm{m}_\mathrm{V}$','colours']
        self.Variables['B-V_corr'] = [self.Variables['B-V'][0]+excess,'$\mathrm{B-V}$','colours']

class Analysis():
    """In construction. Will provide several tools to analyse the evolution or structure files."""
    def __init__(self):
        self.Data = {}
        self.MassList = [0.8,0.9,1.,1.1,1.25,1.35,1.5,1.7,2.,2.5,3.,4.,5.,7.,9.,12.,15.,20.,25.,32.,40.,60.,85.,120.]
        self.OmGridsList = [0.,0.568]
        self.OmBeList = [0.,0.1,0.2,0.3,0.4,0.5,0.568,0.6,0.7,0.8,0.9,0.95]
        self.ZList = [0.,1.e-8,1.e-5,4.e-4,2.e-3,6.e-3,1.4e-2,2.e-2,4.e-2]
        self.AuthorisedModes = [['list','free'],['grids','Be','free']]
        self.beg_burn = 3.e-3
        self.end_burn = 1.e-5

    def setEntry(self,Star,mode):
        if not mode[0] in self.AuthorisedModes[0] or not mode[1] in self.AuthorisedModes[1]:
            print 'This instance should be initialised with one of the following modes: ',self.AuthorisedModes
            print 'Set to ["list","grids"] by default.'
            mode = ['list','grids']
        else:
            self.mode = mode
        Mini = Star.Variables['M'][0][0]
        Oini = Star.Variables['OOc'][0][0]
        Zini = 1.-Star.Variables['H1s'][0][0]-Star.Variables['He4s'][0][0]
        dist_min = 1.e9
        if mode[0] != 'free':
            for zz in self.ZList:
                if abs(Zini-zz) < dist_min:
                    dist_min = abs(Zini-zz)
                    Zini_rounded = zz
        else:
            Zini_rounded = Zini
        if mode[0] == 'list':
            dist_min = 1.e9
            for mass in self.MassList:
                if abs(Mini-mass) < dist_min:
                    dist_min = abs(Mini-mass)
                    Mini_rounded = mass
        else:
            Mini_rounded = round(Mini,2)
        if mode[1] != 'free':
            if mode[1] == 'grids':
                OmegaList = self.OmGridsList
            elif self.mode[1] == 'Be':
                OmegaList = self.OmBeList
            dist_min = 1.e9
            for omega in OmegaList:
                if abs(Oini-omega) < dist_min:
                    dist_min = abs(Oini-omega)
                    Oini_rounded = omega
        else:
            Oini_rounded = round(Oini,2)
        return Mini_rounded,Oini_rounded,Zini_rounded

    def lifetime(self,num,mode=['list','grids'],quiet=False):
        """Computes the lifetime in the different burning phases."""
        MyStar = MyDriver.Model_list[num]
        Mini,Oini,Zini = self.setEntry(MyStar,mode)
        if not [Mini,Oini,Zini] in self.Data.keys() and not quiet:
            print 'Entry for M=',Mini,' with OOc=',Oini,' at Z=',Zini,' added.'
        H_ini = MyStar.Variables['H1s'][0][0]
        He_ini = 1.-Zini
        phase = 0
        time = np.zeros((6,2))
        for i in range(len(MyStar.Variables['line'][0])):
            if phase == 0 and MyStar.Variables['H1c'][0][i] < H_ini-self.beg_burn:
                if i != 0:
                    time[0,0] = MyStar.Variables['t'][0][i-1]
                else:
                    time[0,0] = MyStar.Variables['t'][0][i]
                phase = 1
            if phase == 1 and MyStar.Variables['H1c'][0][i] < self.end_burn:
                time[0,1] = MyStar.Variables['t'][0][i-1]
                phase = 2
            if phase == 2 and MyStar.Variables['He4c'][0][i] < He_ini-self.beg_burn:
                time[1,0] = MyStar.Variables['t'][0][i-1]
                phase = 3
            if phase == 3 and MyStar.Variables['He4c'][0][i] < self.end_burn:
                time[1,1] = MyStar.Variables['t'][0][i-1]
                phase = 4
                C_ini = MyStar.Variables['C12c'][0][i-1]
            if phase == 4 and MyStar.Variables['C12c'][0][i] < C_ini-self.beg_burn:
                time[2,0] = MyStar.Variables['t'][0][i-1]
                phase = 5
            if phase == 5 and MyStar.Variables['C12c'][0][i] < self.end_burn:
                time[2,1] = MyStar.Variables['t'][0][i-1]
                phase = 6
                Ne_ini = MyStar.Variables['Ne20c'][0][i-1]
            if phase == 6 and MyStar.Variables['Ne20c'][0][i] < Ne_ini-self.beg_burn:
                time[3,0] = MyStar.Variables['t'][0][i-1]
                phase = 7
            if phase == 7 and MyStar.Variables['Ne20c'][0][i] < self.end_burn:
                time[3,1] = MyStar.Variables['t'][0][i-1]
                phase = 8
                O_ini = MyStar.Variables['O16c'][0][i-1]
            if phase == 8 and MyStar.Variables['O16c'][0][i] < O_ini-self.beg_burn:
                time[4,0] = MyStar.Variables['t'][0][i-1]
                phase = 9
            if phase == 9 and MyStar.Variables['O16c'][0][i] < self.end_burn:
                time[4,1] = MyStar.Variables['t'][0][i-1]
                phase = 10

        Temp_Dic = {}
        if time[0,1] != 0.:
            Temp_Dic['tauMS'] = time[0,1]-time[0,0]
        else:
            Temp_Dic['tauMS'] = 0.
        if time[1,1] != 0.:
            Temp_Dic['tauHeb'] = time[1,1]-time[1,0]
        else:
            Temp_Dic['tauHeb'] = 0.
        if time[2,1] != 0.:
            Temp_Dic['tauCb'] = time[2,1]-time[2,0]
        else:
            Temp_Dic['tauCb'] = 0.
        if time[3,1] != 0.:
            Temp_Dic['tauNeb'] = time[3,1]-time[3,0]
        else:
            Temp_Dic['tauNeb'] = 0.
        if time[4,1] != 0.:
            Temp_Dic['tauOb'] = time[4,1]-time[4,0]
        else:
            Temp_Dic['tauOb'] = 0.
        try:
            self.Data[Mini,Oini,Zini].update(Temp_Dic)
        except:
            self.Data[Mini,Oini,Zini] = {}
            self.Data[Mini,Oini,Zini].update(Temp_Dic)
        if not quiet:
            print '----------------------------------------------------------------'
            print 'LIFETIMES:\tM= ',Mini,' with OOc= ',Oini,' at Z= ',Zini
            print ''
            print 'MS lifetime:   ',self.Data[Mini,Oini,Zini]['tauMS']
            print 'He-b lifetime: ',self.Data[Mini,Oini,Zini]['tauHeb']
            print 'C-b lifetime:  ',self.Data[Mini,Oini,Zini]['tauCb']
            print 'Ne-b lifetime: ',self.Data[Mini,Oini,Zini]['tauNeb']
            print 'O-b lifetime:  ',self.Data[Mini,Oini,Zini]['tauOb']
            print '----------------------------------------------------------------'

class Kippenhahn():
    """Construction of the Kippenhahn diagram.
       The mass is divided in 500 mass steps for which the convective or radiative status is determined. """
    mass_step = 500

    def init_Kipp(self,Mini):
        self.resolution = Mini/self.mass_step
        self.centered_mass = np.linspace(self.resolution/2.,Mini-self.resolution/2.,self.mass_step)

    def findCZ(self,Model,time_array,time_jump):
        #maximal dimensions for the matrix
        self.CZ_matrix = np.zeros((np.size(Model.CZ_array[0,0,:]),self.mass_step))
        self.mass_array = Model.Variables['M'][0]
        reference_vector = np.zeros((self.mass_step)) + 2.
        self.time_mask = []
        for time in range(np.size(Model.CZ_array[0,0,:])):
            if time%time_jump != 0 and time != np.size(Model.CZ_array[0,0,:])-1:
                self.time_mask.append(False)
                continue
            if MyDriver.axisLimits[3] != 0. and (time_array[time] < MyDriver.axisLimits[0] or time_array[time] > MyDriver.axisLimits[1]):
                self.time_mask.append(False)
                continue
            if time%5000 == 0:
                print 'Computing time step no: ',time
            current_vector = np.zeros((self.mass_step))
            ZC_list=[]
            for i in range(np.size(Model.CZ_array[0,:,0])):
                if (Model.CZ_array[1,i,time]-Model.CZ_array[0,i,time])*self.mass_array[time] >= self.resolution/2.:
                    ZC_list.append([Model.CZ_array[0,i,time]*self.mass_array[time],Model.CZ_array[1,i,time]*self.mass_array[time]])
            for i in range(self.mass_step):
                for j in range(len(ZC_list)):
                    if self.centered_mass[i] >= ZC_list[j][0] and self.centered_mass[i] <= ZC_list[j][1]:
                        current_vector[i] = 1.
                        break
            # The difference is computed only up to the value of the current mass.
            diff = self.ComputeDiff(current_vector, reference_vector, self.mass_array[time])
            if diff >= MyDriver.Kipp_tol or time == np.size(Model.CZ_array[0,0,:])-1:
                self.time_mask.append(True)
                current_size = np.sum(self.time_mask)-1
                self.CZ_matrix[current_size,:] = current_vector
                reference_vector = current_vector
            else:
                self.time_mask.append(False)
        self.CZ_matrix = self.CZ_matrix.transpose()
        self.time_mask = np.array(self.time_mask,dtype=bool)

    def plot_Kippen(self,SubFig,time_array,hatch,noshade):
        """Used by Kippen()"""
        colour_sequence = np.linspace(0.1,3.,2,endpoint=True)
        time_array = time_array[self.time_mask]
        matrix_size = len(time_array)
        if noshade:
            SubFig.contourf(time_array,self.centered_mass,self.CZ_matrix[:,0:matrix_size],colour_sequence,vmin=0.,vmax=3.,colors='none',hatches=[hatch,None])
        else:
            SubFig.contourf(time_array,self.centered_mass,self.CZ_matrix[:,0:matrix_size],colour_sequence,vmin=0.,vmax=3.,cmap=cm.binary,hatches=[hatch,None])

    def ComputeDiff(self,Vector_in,Vector_ref,current_mass):
        Cell_Number = 0
        Diff_Number = 0
        for i in range(np.size(Vector_in)):
            if self.centered_mass[i] <= current_mass:
                Cell_Number = Cell_Number+1
                if Vector_in[i] != Vector_ref[i]:
                    Diff_Number = Diff_Number+1
            else:
                break
        return float(Diff_Number)/float(Cell_Number)

def Analyse(model_list,mode=['list','grids']):
    """Launches the computation of the lifetimes."""
    if isinstance(model_list,int):
        MyData.lifetime(model_list,mode)
    elif isinstance(model_list,list):
        for model in model_list:
            MyData.lifetime(model,mode)

def add_column(var,unit='',cat='',verbose=True):
    """Allows to add a column description to the standard one before reading a file.
          Usage: add_column(['varName',col_num],'label','category').
       'label' and 'category' are optional. If absent, 'label' will be varName and 'category' will be empty."""
    if verbose:
        print 'The column has to be added at the end of the file.'
        print 'Its number must at least be the following (according to mode and format):'
        print '\t Evol mode'
        print '\t\t o2013: 110\n\t\t tgrids: 43\n\t\t tools: 55\n\t\t bin: 117'
        print '\t Struc mode'
        print '\t\t o2013-o2010: 92\n\t\t full: 24'
        print '\t Cluster mode'
        print '\t\t cluster: 49\n\t\t cluster_old: 39\n\t\t isochr: 39\n\t\t isochr_old: 40\n'
    if unit == '':
        unit = var[0]+' [cgs]'
    MyDriver.added_columns['varList'] = MyDriver.added_columns['varList'] + [var]
    MyDriver.added_columns['unitsList'] = MyDriver.added_columns['unitsList'] + [unit]
    MyDriver.added_columns['catList'] = MyDriver.added_columns['catList'] + [cat]

def standard_columns():
    """Removes the columns added by add_column()."""
    MyDriver.added_columns = {'varList':[],'unitsList':[],'catList':[]}

def loadE(FileName,num_star=1,num_deb=0,num_fin=-1,format='',colour=False,forced=False,wa=False,quiet=False):
    """Loads a new evolution file in the database.
       Usage: loadE(FileName,num_star[,num_deb,num_fin,format=tgrids])
       Optional arguments are:
          num_deb (first line by default)
          num_fin (last line by default)
          format (o2013, tgrids, tools, bin, preMS,starevol). if empty: auto-detection
          colour (False by default, colours computation if True)
          forced (False by default, True to avoid the checking of the star number)
          wa (False by default, True to read the abundances in the wa file)
          quiet (False by default, True to avoid all the babbling)."""
    MyModel = Model()
    if ".wg" not in FileName and ".grids" not in FileName and ".dat" not in FileName:
        format = "starevol"

    if format != "starevol":
        if not os.path.isfile(FileName):
            print('File '+FileName+' does not exist, check name and path.')
            return
    toZip = False
    if os.path.splitext(FileName)[1] == '.gz':
        toZip = True
        rootName = os.path.splitext(FileName)[0]
        if not quiet:
            print('unzipped file: '+rootName)
        CommandUnzip = 'gunzip '+FileName
        CommandZip = 'gzip '+rootName
        os.system(CommandUnzip)
        MyEFile = rootName
    else:
        MyEFile = FileName

    Checked = False
    if MyDriver.modeplot != 'evol':
        if not quiet:
            print 'Switch to evol mode.'
        switch('evol')
    if not forced:
        Checked, num_star = Driver.checknumber(MyDriver,num_star)
    if Checked or forced:
        try:
            MyModel.read(MyEFile,num_deb,num_fin,format,colour,wa,quiet)
            MyDriver.store_model(MyModel,num_star)
            if not num_star in MyDriver.SelectedModels:
                MyDriver.SelectedModels.append(num_star)
            if not num_star in MyDriver.SelectedModels_evol:
                MyDriver.SelectedModels_evol.append(num_star)
            MyData.lifetime(num_star,mode=['free','free'],quiet=True)
            Mini = round(MyDriver.Model_list[num_star].Variables['M'][0][0],2)
            Oini = round(MyDriver.Model_list[num_star].Variables['OOc'][0][0],2)
            Zini = 1.-MyDriver.Model_list[num_star].Variables['H1s'][0][0]-MyDriver.Model_list[num_star].Variables['He4s'][0][0]
            tauH = MyData.Data[(Mini,Oini,Zini)]['tauMS']
            tauHe = MyData.Data[(Mini,Oini,Zini)]['tauHeb']
            tauC = MyData.Data[(Mini,Oini,Zini)]['tauCb']
            tauNe = MyData.Data[(Mini,Oini,Zini)]['tauNeb']
            tauO = MyData.Data[(Mini,Oini,Zini)]['tauOb']
            Set_Var([tauH,tauHe,tauC,tauNe,tauO],'tau',num_star,label='lifetimes [yr]',category='model')
            if tauH !=0.:
                Set_Var(Get_Var('t',num_star)/tauH,'t_tauH',num_star,label=r'$t/\tau_\mathrm{H}$',category='model')
            else:
                print 'MS not finished, the variable t_tauH will not be available'
        except IOError as IOerr:
            print '[Error',str(IOerr.errno)+']',IOerr.strerror,': ',IOerr.filename
    if toZip:
        os.system(CommandZip)

def loadS(FileName,num_star=1,toread=[],format='',forced=False,quiet=False):
    """Loads a new structure file in the database.
       Usage: loadS(Filename,num_star[,toread=[struc_num],forced=True])
       Optional argument are:
          toread=[struc_list], structure number that has to be loaded (all by default)
            if several structures are loaded, they will be numbered sequentially beginning from num_star.
          format ('o2013', 'o2010', 'full', or 'full_old'. By default, auto-detection)
          forced (False by default, True to avoid the checking of the star number)
          quiet (False by default, True to avoid all the babbling)."""
    MyModel = Struc()
    if not os.path.isfile(FileName):
        print('File '+FileName+' does not exist, check name and path.')
        return
    toZip = False
    if os.path.splitext(FileName)[1] == '.gz':
        toZip = True
        rootName = os.path.splitext(FileName)[0]
        if not quiet:
            print('unzipped file: '+rootName)
        CommandUnzip = 'gunzip '+FileName
        CommandZip = 'gzip '+rootName
        os.system(CommandUnzip)
        MyVFile = rootName
    else:
        MyVFile = FileName

    lastline = os.popen('tail -3 '+MyVFile+' | head -1').readline().replace('\n','')
    file_cols = len(lastline.split())

    if format == '':
        if 'StrucData' in MyVFile:
            for fmt in readList.Struc_fmt[2:4]:
                if file_cols == readList.Struc_formats[fmt]['column_number'] + len(MyDriver.added_columns['varList']):
                    format = fmt
                    break
        else:
            for fmt in readList.Struc_fmt[0:2]:
                if file_cols == readList.Struc_formats[fmt]['column_number'] + len(MyDriver.added_columns['varList']):
                    format = fmt
                    break
        if format == '':
            raise FormatError(1,'column number= '+str(file_cols)+' does not match any known format',FileName)
            return
        if not quiet:
            print 'format identified=',format

    Time_Step_Dic = MyModel.make_content_list(MyVFile,format)
    print sorted(Time_Step_Dic.items(), key=lambda x: x[0])

    if toread == []:
        toread = Time_Step_Dic.keys()

    ToReadModels = []
    [ToReadModels.append(i) for i in flatten([toread]) if i in Time_Step_Dic.keys()]
    if len([i for i in flatten([toread]) if i not in Time_Step_Dic.keys()]) !=0:
        print 'Model(s) ',[i for i in flatten([toread]) if i not in Time_Step_Dic.keys()],' is (are) not loaded.'

    for Current_Model in sorted(ToReadModels):
        MyModel = Struc()
        print Current_Model
        Checked = False
        if MyDriver.modeplot != 'struc':
            if not quiet:
                print 'Switch to struc mode.'
            switch('struc')
        if not forced:
            Checked, num_star = Driver.checknumber(MyDriver,num_star)
        if Checked or forced:
            num_deb = Time_Step_Dic[Current_Model][0]
            line_to_read = Time_Step_Dic[Current_Model][1]-num_deb+1
            try:
                MyModel.read(MyVFile,num_deb-1,line_to_read,format=format,quiet=quiet)
                MyDriver.store_model(MyModel,num_star)
                if not num_star in MyDriver.SelectedModels:
                    MyDriver.SelectedModels.append(num_star)
                if not num_star in MyDriver.SelectedModels_struc:
                    MyDriver.SelectedModels_struc.append(num_star)
                num_star += 1
            except IOError as IOerr:
                print '[Error',str(IOerr.errno)+']',IOerr.strerror,': ',IOerr.filename
            except np.linalg.LinAlgError:
                print 'problem computing MLT, aborting.'
                os.system(CommandZip)
                raise
            except FormatError:
                raise FormatError(1,'column number= '+str(file_cols)+' does not match any known format',FileName)

    if toZip:
        os.system(CommandZip)
    return len(ToReadModels)

def loadC(FileName,num_star=1,num_deb=0,num_fin=-1,format='',forced=False,quiet=False,random=0):
    """Loads a new cluster/isochrone file in the database.
       Usage: loadC(Filename,num_star[,num_deb,format='fmt',forced=True])
       Optional argument is:
          num_deb (first line by default)
          format ('cluster', 'cluster_old', 'isochr', 'isochr_old'. By default: auto-detection)
          forced (False by default, True to avoid the checking of the star number)
          quiet (False by default, True to avoid all the babbling)."""
    Checked = False
    multi_iso = False
    if MyDriver.modeplot != 'cluster':
        if not quiet:
            print 'Switch to cluster mode.'
        switch('cluster')
    if num_fin == -1:
        MyFile = open(FileName)
        search_line = 'Isochrone for log(time) = '
        iso_time_dic = {}
        i=0
        for i,MyLine in enumerate(MyFile):
            if MyLine[0:len(search_line)] == search_line:
                iso_time_dic[float(MyLine.split('=')[1])] = i-1
        if iso_time_dic:
            multi_iso = True
        iso_times = sorted(iso_time_dic.keys())
        if not quiet:
            print 'isochrone file with ages:',iso_times
        iso_beg = [iso_time_dic[t] for t in sorted(iso_time_dic.keys())]
        iso_end = [iso_beg[i]+1 for i in range(1,len(iso_beg))]
        iso_end.append(-1)
    if not multi_iso:
        MyModel = Cluster()
        if not forced:
            Checked, num_star = Driver.checknumber(MyDriver,num_star)
            if Checked or forced:
                try:
                    MyModel.read(FileName,num_deb,num_fin,format=format,quiet=quiet, random=random)
                    MyDriver.store_model(MyModel,num_star)
                    if not num_star in MyDriver.SelectedModels:
                        MyDriver.SelectedModels.append(num_star)
                        if not num_star in MyDriver.SelectedModels_cluster:
                            MyDriver.SelectedModels_cluster.append(num_star)
                except IOError as IOerr:
                    print '[Error',str(IOerr.errno)+']',IOerr.strerror,': ',IOerr.filename
    else:
        for (i,beg),end,time in zip(enumerate(iso_beg),iso_end,iso_times):
            MyModel = Cluster()
            if not forced:
                Checked, mynum_star = Driver.checknumber(MyDriver,num_star+i)
            else:
                mynum_star = num_star+i
            if Checked or forced:
                try:
                    if not quiet:
                        print '***** loading isochrone at age ',time,' *****'
                    MyModel.read(FileName,beg,end,format=format,quiet=quiet, random=random)
                    MyDriver.store_model(MyModel,mynum_star)
                    if not mynum_star in MyDriver.SelectedModels:
                        MyDriver.SelectedModels.append(mynum_star)
                        if not mynum_star in MyDriver.SelectedModels_cluster:
                            MyDriver.SelectedModels_cluster.append(mynum_star)
                except IOError as IOerr:
                    print '[Error',str(IOerr.errno)+']',IOerr.strerror,': ',IOerr.filename

def loadEFromList(FileName,ini_index=1,num_deb=0,format='',forced=False,quiet=False,colour=False):
    """ Loads a list of models from a file.
        The file shall contain on each line the path to the wanted model.
        By default, the models are loaded with index 1 for the first one up to n,
           but setting 'ini_index=i' modifies the numbering from i to i+n.
        The format is an optional argument, auto-detection if omitted.
        The forced=True option avoids the questions linked to a number already attributed.
        Usage : LoadEFromList(Fichier_Liste[,ini_index=...,format ="tgrids",forced=True])."""
    ListFile = open(FileName,'r')
    index = ini_index
    for Path in ListFile:
        MyPath = str(Path.split()[0])
        try:
            loadE(MyPath,index,num_deb,format=format,forced=forced,quiet=quiet,colour=colour)
            index += 1
        except FormatError as WF:
            print '[Error',str(WF.errno)+']',WF.strerror,': ',WF.filename
            pass
        except IndexError:
            print 'column problem in file '+MyPath
            pass
        except ValueError:
            print 'value problem in file '+MyPath
            pass
    if not quiet:
        print ''
        Loaded('evol')

def loadSFromList(FileName,ini_index=1,format='',forced=False,quiet=False):
    """ Loads a list of structures from a file.
        The file shall contain on each line the path to the wanted structures.
        By default, the structures are loaded with index 1 for the first one up to n,
           but setting 'ini_index=i' modifies the numbering from i to i+n.
        The format is an optional argument, auto-detection if omitted.
        The forced=True option avoids the questions linked to a number already attributed.
        Usage : LoadSFromList(Fichier_Liste[,ini_index=i,forced=True])."""
    ListFile = open(FileName,'r')
    index = ini_index
    for Path in ListFile:
        MyPath = str(Path.split()[0])
        increment = loadS(MyPath,index,[],format,forced,quiet)
        index = index + increment
    if not quiet:
        print ''
        Loaded('struc')

def loadCFromList(FileName,ini_index=1,num_deb=0,format='',forced=False,quiet=False):
    """ Loads a list of clusters/isochrones from a file.
        The file shall contain on each line the path to the wanted cluster/isochrone.
        By default, the files are loaded with index 1 for the first one up to n,
           but setting 'ini_index=i' modifies the numbering from i to i+n.
        The format is an optional argument, auto-detection if omitted.
        The forced=True option avoids the questions linked to a number already attributed.
        Usage : LoadCFromList(Fichier_Liste[,ini_index=...,format ="isochr",forced=True])."""
    ListFile = open(FileName,'r')
    index = ini_index
    for Path in ListFile:
        MyPath = str(Path.split()[0])
        try:
            loadC(MyPath,index,num_deb,format=format,forced=forced,quiet=quiet)
            index += 1
        except FormatError as WF:
            print '[Error',str(WF.errno)+']',WF.strerror,': ',WF.filename
            pass
        except IndexError:
            print 'column problem in file '+file
            pass
        except ValueError:
            print 'value problem in file '+file
            pass
    if not quiet:
        print ''
        Loaded('cluster')

def loadEFromDir(DirName,select='*',ini_index=1,num_deb=0,format='',forced=False,quiet=True,colour=False):
    """Loads all models (.wg, .dat, or .wg.grids) in the directory given in argument.
        By default, the models are loaded with index 1 for the first one up to n,
            but setting 'ini_index=i' modifies the numbering from i to i+n.
        The optional argument select='string' restricts the loading only to files that have 'string'
            in their name.
        The forced=True option avoids the questions linked to a number already attributed.
        Usage : LoadEFromDir(DirName[,ini_index=...,select ="...",forced=True,quiet=True])."""
    index = ini_index
    num_files = 0
    if DirName[-1] != '/':
        DirName = DirName+'/'
    print 'loading files from directory '+DirName+':'
    Selected_files = sorted(glob.glob(DirName+'*'+select+'*'))
    if len(Selected_files) == 0.:
        print 'No files matching your request.'
        return
    for file in [i for i in Selected_files if os.path.splitext(i)[1] in ['.wg','.dat','.grids']]:
        file_short = file[file.rfind('/')+1:]
        print 'file '+file_short
        try:
            loadE(file,index,num_deb,format=format,forced=forced,quiet=quiet,colour=colour)
            if not quiet:
                print 'File '+file_short+' successfully loaded.'
            index += 1
            num_files += 1
        except FormatError as WF:
            print '[Error',str(WF.errno)+']',file_short+': '+WF.strerror
            pass
        except IndexError:
            print 'column problem in file '+file_short
            pass
        except ValueError:
            print 'value problem in file '+file_short
            pass
        except:
            print 'file '+file_short+' does not seem to be a valid file, skipped.'
            pass
    if not quiet:
        print ''
        Loaded('evol')
    else:
        print str(num_files)+' files loaded. Details can be displayed with Loaded().'

def loadSFromDir(DirName,select='*',ini_index=1,toread=[],format='',forced=False,quiet=False):
    """Loads all structures (.v or StrucData) in the directory given in argument.
        By default, the models are loaded with index 1 for the first one up to n,
            but setting 'ini_index=i' modifies the numbering from i to i+n.
        The optional argument select='string' restricts the loading only to files that have 'string'
            in their name.
        The forced=True option avoids the questions linked to a number already attributed.
        Usage : LoadSFromDir(DirName[,ini_index=...,select ="S0",forced=True,quiet=True])."""
    index = ini_index
    print 'loading files from directory '+DirName+':'
    Selected_files = sorted(glob.glob(DirName+'*'+select+'*'))
    if len(Selected_files) == 0.:
        print 'No files matching your request.'
        return
    for file in [i for i in Selected_files if ((os.path.splitext(i)[1] == '.dat' and 'StrucData' in os.path.splitext(i)[0]) or '.v' in i)]:
        print 'loading',file
        try:
            increment = loadS(file,index,[],format,forced,quiet)
            if not quiet:
                print 'File '+file+' successfully loaded.'
            index = index + increment
        except FormatError as WF:
            print '[Error',str(WF.errno)+']',WF.strerror,': ',WF.filename
            pass
        except IndexError:
            print 'column problem in file '+file
            pass
        except ValueError:
            print 'value problem in file '+file
            pass
    if not quiet:
        print ''
        Loaded('struc')

def loadCFromDir(DirName,select='*',ini_index=1,num_deb=0,format='',forced=False,quiet=False):
    """Loads all clusters/isochrones (Clu*.dat, or Iso*.dat) in the directory given in argument.
        By default, the files are loaded with index 1 for the first one up to n,
            but setting 'ini_index=i' modifies the numbering from i to i+n.
        The optional argument select='string' restricts the loading only to files that have 'string'
            in their name.
        The forced=True option avoids the questions linked to a number already attributed.
        Usage : LoadCFromDir(DirName[,ini_index=...,select ="006",forced=True,quiet=True])."""
    index = ini_index
    print 'loading files from directory '+DirName+':'
    Selected_files = sorted(glob.glob(DirName+'*'+select+'*'))
    if len(Selected_files) == 0.:
        print 'No files matching your request.'
        return
    for file in [i for i in Selected_files if (os.path.splitext(i)[1] == '.dat' and os.path.splitext(i)[0][i.rfind('/')+1:i.rfind('/')+4] in ['Clu','Iso'])]:
        if not quiet:
            print 'loading',file
        try:
            loadC(file,index,num_deb,format=format,forced=forced,quiet=quiet)
            if not quiet:
                print 'File '+file+' successfully loaded.'
            index += 1
        except FormatError as WF:
            print '[Error',str(WF.errno)+']',WF.strerror,': ',WF.filename
            pass
        except IndexError:
            print 'column problem in file '+file
            pass
        except ValueError:
            print 'value problem in file '+file
            pass
    if not quiet:
        print ''
        Loaded('cluster')

def LoadedEvol():
    """Prints the models loaded in the database as well as those selected for plots """
    print "Models loaded in database:"
    for i in MyDriver.Model_list_evol.keys():
        print i,':\t',MyDriver.Model_list_evol[i].Variables['FileName'][0]

    print '\nModels currently selected for plotting:'
    print MyDriver.SelectedModels_evol

def LoadedStruc():
    """Prints the structure loaded in the database as well as those selected for plots """
    print 'Structures loaded in database:'
    for i in MyDriver.Model_list_struc.keys():
        print i,':\t',MyDriver.Model_list_struc[i].Variables['FileName'][0],'\t',MyDriver.Model_list_struc[i].Variables['Model'][0]

    print '\nStructures currently selected for plotting:'
    print MyDriver.SelectedModels_struc

def LoadedCluster():
    """Prints the clusters/isochrones loaded in the database as well as those selected for plots """
    print 'Clusters/isochrones loaded in database:'
    for i in MyDriver.Model_list_cluster.keys():
        print i,':\t',MyDriver.Model_list_cluster[i].Variables['FileName'][0]

    print '\nClusters/isochrones currently selected for plotting:'
    print MyDriver.SelectedModels_cluster

def Loaded(mode=''):
    """Prints the files loaded in the database as well as those selected for plots.
       Usage: Loaded(mode)
              with mode being either none for the current one or 'evol', 'struc', or 'cluster'."""
    if mode == '':
        mode = MyDriver.modeplot
    if mode == 'evol':
        LoadedEvol()
    elif mode == 'struc':
        LoadedStruc()
    elif mode== 'cluster':
        LoadedCluster()
    else:
        print 'wrong mode selected'

def flatten(x):
    """Allows to treat equally a list and a number when selecting models.
       Used by add_model(), del_model(), and select_model()."""
    result = []
    for el in x:
        if hasattr(el, "__iter__") and not isinstance(el, basestring):
            result.extend(flatten(el))
        else:
            result.append(el)
    return result

def reloadE(model_list):
    """Reloads the selected models."""
    try:
        for i in flatten([model_list]):
            loadE(MyDriver.Model_list_evol[i].Variables['FileName'][0],i,num_deb=MyDriver.Model_list_evol[i].Variables['line_num'][0][0]-MyDriver.Model_list_evol[i].Variables['format'][0][1],\
                num_fin=MyDriver.Model_list_evol[i].Variables['line_num'][0][1],format=MyDriver.Model_list_evol[i].Variables['format'][0][0],colour=MyDriver.Model_list_evol[i].Variables['options'][0][0],\
                wa=MyDriver.Model_list_evol[i].Variables['options'][0][1],forced=True,quiet=True)
            print 'Model ',i,'reloaded'
    except KeyError:
        print 'Number(s) ',[i for i in flatten([model_list]) if i not in MyDriver.Model_list_evol.keys()],' not attributed to any model'

def reloadS(model_list):
    """Reloads the selected structures."""
    try:
        for i in flatten([model_list]):
            loadS(MyDriver.Model_list_struc[i].Variables['FileName'][0],i,MyDriver.Model_list_struc[i].Variables['Model'][0],format=MyDriver.Model_list_struc[i].Variables['format'][0],forced=True,quiet=True)
            print 'Structure ',i,'reloaded'
    except KeyError:
        print 'Number(s) ',[i for i in flatten([model_list]) if i not in MyDriver.Model_list_struc.keys()],' not attributed to any structure'

def reloadC(model_list):
    """Reloads the selected clusters/isochrones."""
    try:
        for i in flatten([model_list]):
            loadC(MyDriver.Model_list_cluster[i].Variables['FileName'][0],i,num_deb=MyDriver.Model_list_cluster[i].Variables['line_num'][0]-MyDriver.Model_list_cluster[i].Variables['format'][0][1],\
                format=MyDriver.Model_list_cluster[i].Variables['format'][0][0],forced=True,quiet=True)
            if MyDriver.Model_list_cluster[i].Variables['format'][0][0] == 'cluster':
                print 'Cluster ',i,'reloaded'
            elif MyDriver.Model_list_cluster[i].Variables['format'][0][0] == 'isochr':
                print 'Isochrone ',i,'reloaded'
    except KeyError:
        print 'Number(s)',[i for i in flatten([model_list]) if i not in MyDriver.Model_list_cluster.keys()],' not attributed to any cluster/isochrone '

def del_model(num_list):
    """Removes the model numbers given in argument from the list of selected models for plotting."""
    if len([i for i in flatten([num_list]) if i not in MyDriver.SelectedModels]) !=0:
        print 'Model(s) ',[i for i in flatten([num_list]) if i not in MyDriver.SelectedModels],' is (are) not among the selected models.'
    [MyDriver.SelectedModels.remove(i) for i in flatten([num_list]) if i in MyDriver.SelectedModels]

def add_model(num_list):
    """Adds the model numbers given in argument to the list of selected models for plotting """
    [MyDriver.SelectedModels.append(i) for i in flatten([num_list]) if i in MyDriver.Model_list.keys()]
    if len([i for i in flatten([num_list]) if i not in MyDriver.Model_list.keys()]) !=0:
        print 'Model(s) ',[i for i in flatten([num_list]) if i not in MyDriver.Model_list.keys()],' is (are) not loaded.'

def select_model(model_list):
    """Defines the list of selected models for plotting """
    MyDriver.SelectedModels = []
    [MyDriver.SelectedModels.append(i) for i in flatten([model_list]) if i in MyDriver.Model_list.keys()]
    if MyDriver.modeplot == 'evol':
        MyDriver.SelectedModels_evol = MyDriver.SelectedModels
    if MyDriver.modeplot == 'struc':
        MyDriver.SelectedModels_struc = MyDriver.SelectedModels
    if MyDriver.modeplot == 'cluster':
        MyDriver.SelectedModels_cluster = MyDriver.SelectedModels
    if len([i for i in flatten([model_list]) if i not in MyDriver.Model_list.keys()]) !=0:
        print 'Model(s) ',[i for i in flatten([model_list]) if i not in MyDriver.Model_list.keys()],' is (are) not loaded.'

def select_all():
    """Selects all available models in the current mode """
    select_model(eval('MyDriver.Model_list_'+MyDriver.modeplot+'.keys()'))

def switch(mode='evol'):
    """Switches from the different modes: evolution, structure, or cluster.
       Usage: switch('struc')"""
    Allowed_modes = ['evol','struc','cluster']
    if not mode in Allowed_modes:
        print 'The input argument should be "evol", "struc", or "cluster".'
        return
    if mode == 'evol' and MyDriver.modeplot != 'evol':
        MyDriver.SelectedModels = MyDriver.SelectedModels_evol
        MyDriver.Model_list = MyDriver.Model_list_evol
        MyDriver.modeplot = 'evol'
        MyDriver.Xvar = 't6'
        MyDriver.iPoints = False
    if mode == 'struc' and MyDriver.modeplot != 'struc':
        MyDriver.SelectedModels = MyDriver.SelectedModels_struc
        MyDriver.Model_list = MyDriver.Model_list_struc
        MyDriver.modeplot = 'struc'
        MyDriver.Xvar = 'Mfrac'
        MyDriver.iPoints = False
        MyDriver.steps = False
    if mode == 'cluster' and MyDriver.modeplot != 'cluster':
        MyDriver.SelectedModels = MyDriver.SelectedModels_cluster
        MyDriver.Model_list = MyDriver.Model_list_cluster
        MyDriver.modeplot = 'cluster'
        MyDriver.Xvar = 'Teff'
        MyDriver.iPoints = True
        MyDriver.steps = False

def VarEvol(num=''):
    """Prints the available variables for plotting in evolution mode.
       Needs at least one loaded model."""
    if num == '':
        num = MyDriver.Model_list_evol.keys()[0]
    Category_list = []
    for i in range(len(MyDriver.Model_list_evol[num].Variables.keys())):
        if not MyDriver.Model_list_evol[num].Variables.values()[i][2] in Category_list:
            Category_list.append(MyDriver.Model_list_evol[num].Variables.values()[i][2])
    Category_list.remove('reading')
    for Category in sorted(Category_list):
        print '\n'+Category.upper()+':'
        for key in sorted(MyDriver.Model_list_evol[num].Variables.keys(), key=lambda s: s.lower()):
            if MyDriver.Model_list_evol[num].Variables[key][2] == Category:
                if len(key) > 6:
                    print '\t'+key+':\t'+MyDriver.Model_list_evol[num].Variables[key][1]
                else:
                    print '\t'+key+':\t\t'+MyDriver.Model_list_evol[num].Variables[key][1]

def VarStruc(num=''):
    """Prints the available variables for plotting in structure mode.
       Needs at least one loaded structure."""
    if num == '':
        num = MyDriver.Model_list_struc.keys()[0]
    Category_list = []
    for i in range(len(MyDriver.Model_list_struc[num].Variables.keys())):
        if not MyDriver.Model_list_struc[num].Variables.values()[i][2] in Category_list:
            Category_list.append(MyDriver.Model_list_struc[num].Variables.values()[i][2])
    for Category in sorted(Category_list):
        print '\n'+Category.upper()+':'
        for key in sorted(MyDriver.Model_list_struc[num].Variables.keys(), key=lambda s: s.lower()):
            if MyDriver.Model_list_struc[num].Variables[key][2] == Category:
                if len(key) > 6:
                    print '\t'+key+':\t'+MyDriver.Model_list_struc[num].Variables[key][1]
                else:
                    print '\t'+key+':\t\t'+MyDriver.Model_list_struc[num].Variables[key][1]

def VarCluster(num=''):
    """Prints the available variables for plotting in cluster mode.
       Needs at least one loaded cluster."""
    if num == '':
        num = MyDriver.Model_list_cluster.keys()[0]
    Category_list = []
    for i in range(len(MyDriver.Model_list_cluster[num].Variables.keys())):
        if not MyDriver.Model_list_cluster[num].Variables.values()[i][2] in Category_list:
            Category_list.append(MyDriver.Model_list_cluster[num].Variables.values()[i][2])
    Category_list.remove('reading')
    for Category in sorted(Category_list):
        print '\n'+Category.upper()+':'
        for key in sorted(MyDriver.Model_list_cluster[num].Variables.keys(), key=lambda s: s.lower()):
            if MyDriver.Model_list_cluster[num].Variables[key][2] == Category:
                if len(key) > 6:
                    print '\t'+key+':\t'+MyDriver.Model_list_cluster[num].Variables[key][1]
                else:
                    print '\t'+key+':\t\t'+MyDriver.Model_list_cluster[num].Variables[key][1]

def Get_Var(var,num_star):
    """Retrieves the variable entered in input to allow personalised manipulation of the variable.
       Usage: toto = Get_Var('Var_Name',num_star)"""
    return MyDriver.Model_list[num_star].Variables[var][0]

def Set_Var(var,var_name,num_star,**args):
    """Passes a newly defined variable into the available variables dictionary.
       Typically used after Get_Var() and operations on the retrieved variable.
       To generalise this to all the selected models (or structures), write a loop:
           for i in MyDriver.SelectedModels:
               New_Var = a function involving Get_Var('wanted_var',i)
               Set_Var(New_Var,"New_Var_name",i[,label="Corresponding label",category="The wanted category"])
        Example: for i in MyDriver.SelectedModels:
                     New_Var = Get_Var('R',i)**2.
                     Set_Var(New_Var,"R2",i,label='$R^2$',category='model')
        The label and category parameters are optional."""
    MyLabel = ''
    MyCat = ''
    for arg in args.keys():
        if arg == 'label':
            MyLabel = args[arg]
        elif arg == 'category':
            MyCat = args[arg]
        else:
            print('Bad argument for function Set_Var. Should be label="..." and category="..." .')

    if not MyDriver.Model_list[num_star].Variables.has_key(var_name):
        MyDriver.Model_list[num_star].Variables[var_name] = [var,MyLabel,MyCat]
    else:
        print 'The key ',var_name,' already exists in this dictionary.'

def Del_Var(varName,num_star=0,quiet=False):
    """Deletes an entry of the Variables dictionary.
       Usage: Del_Var(varName,num_star)"""
    if num_star == 0:
        num_star = MyDriver.Model_list.keys()
    for i in flatten([num_star]):
        try:
            del MyDriver.Model_list[i].Variables[varName]
            if not quiet:
                print 'The variable '+varName+' has been successfully deleted in model '+str(i)+'.'
        except KeyError:
            if not quiet:
                print 'The variable you tried to delete does not exist in model '+str(i)+'.'

def Deriv(Var1,Var2,num_star=[]):
    """Takes the derivative of variable 1 over variable 2.
       Entering a number or a list of numbers applies it to one, several or all the stars loaded."""
    selectedModels=[]
    if num_star==[]:
        selectedModels = MyDriver.Model_list.keys()
    else:
        [selectedModels.append(i) for i in flatten([num_star]) if i in MyDriver.Model_list.keys()]
        if len([i for i in flatten([selectedModels]) if i not in MyDriver.Model_list.keys()]) !=0:
            print 'Model(s) ',[i for i in flatten([selectedModels]) if i not in MyDriver.Model_list.keys()],' is (are) not loaded.'
            return
    for i in selectedModels:
        x=Get_Var(Var1,i)
        y=Get_Var(Var2,i)
        dx=np.gradient(x)
        dy=np.gradient(y)
        dx_min=min(dx)
        dy=[val if val != 0. else dx_min/1.e30 for val in dy]
        Set_Var(dx/dy,'d'+Var1+'_d'+Var2,i,label='$\mathrm{d '+Var1+'}/\mathrm{d '+Var2+'}$')
    print 'The derivative can be plotted under the name d'+Var1+'_d'+Var2

def Vector_split(varName,num_star,quiet=False):
    """Splits a vector into its positive and negative components and adds both in the Variables dictionary.
       Usage: Vector_split(varName,num_star)."""
    myVector = Get_Var(varName,num_star)
    myLab = MyDriver.Model_list[num_star].Variables[varName][1]
    myCat = MyDriver.Model_list[num_star].Variables[varName][2]
    myVector_pos = np.maximum(myVector,1.e-30)
    myVector_neg = np.absolute(np.minimum(myVector,-1.e-30))
    Set_Var(myVector_pos,varName+'_pos',num_star,label=myLab,category=myCat)
    Set_Var(myVector_neg,varName+'_neg',num_star,label='$-$'+myLab,category=myCat)
    if not quiet:
        print 'The positive and negative values can be plotted under the name '+varName+'_pos and '+varName+'_neg respectively'

def Plot(y,plotif=['',''],cshift=0,forced_line=False):
    """Plots the input variable y as a function of the x variable entered with defX(Variable_name).
       Usage:Plot('VarName')
       Possibility to restrict the data plotted to a condition on a variable:
          Example: Plot('He4s',plotif=['H1c','>0.'])
       In case you want to force coneection of all line segments (with plotif), use forced_line = True"""
    rc('text', usetex=MyDriver.LatexEnabled)

    if plotif == ['','']:
        masked = False
    else:
        masked = True

    NewFig,mySubplot = configPlot()
    if not MyDriver.keepplot:
        if NewFig:
            if MyDriver.closeFig:
                plt.close()
            MyDriver.AddFigure((8,8))
        MyDriver.current_Fig.subplots_adjust(wspace=MyDriver.subplotSep)
        New_Axes = MyDriver.current_Fig.add_subplot(mySubplot)
    else:
        if MyDriver.multiplot:
            New_Axes = MyDriver.Previous_Axe.twinx()
        else:
            New_Axes = MyDriver.Previous_Axe

    bad_y = False
    Star_list=MyDriver.list_keyOK(y,MyDriver.SelectedModels)
    Star_list=MyDriver.Zero_LengthOK(y,Star_list)
    if len(Star_list) != len(MyDriver.SelectedModels):
        bad_var = y
        bad_y = True

    Star_list=MyDriver.list_keyOK(MyDriver.Xvar,Star_list)
    Star_list=MyDriver.Zero_LengthOK(MyDriver.Xvar,Star_list)
    if len(Star_list) != len(MyDriver.SelectedModels) and not bad_y:
        bad_var = MyDriver.Xvar

    if len(Star_list) == 0:
        print 'No star knows variable',bad_var
        print 'Available variables are:'
        print sorted(MyDriver.Model_list[MyDriver.SelectedModels[0]].Variables.keys(), key=lambda s: s.lower())
        return
    else:
        if len(Star_list) != len(MyDriver.SelectedModels):
            print 'The variable',bad_var,'does not exist for model(s)',[x for x in MyDriver.SelectedModels if x not in Star_list],'. They will not appear on the plot.'

    MyDriver.lastXvar = MyDriver.Xvar
    MyDriver.lastYvar = y

    try:
        myLegend = MyDriver.Model_list[Star_list[0]].Variables[y][1]
        if MyDriver.ilog[1]:
            myLegend = 'log('+myLegend+')'
    except:
        myLegend = ''

    j = 0
    for i in Star_list:
        if MyDriver.colourFlag == 'cycle':
            iColour = Rendering.Colours_list[MyDriver.colourSequence][0][(j+cshift) % len(Rendering.Colours_list[MyDriver.colourSequence][0])]
            ColourName = Rendering.Colours_list[MyDriver.colourSequence][1][(j+cshift) % len(Rendering.Colours_list[MyDriver.colourSequence][1])]
            MyDriver.Link_ModelCurve = True
        else:
            iColour = MyDriver.colourFlag
            ColourName = MyDriver.colourFlag
            MyDriver.Link_ModelCurve = False
        if not MyDriver.iPoints:
            if MyDriver.lineFlag == 'cycle_all':
                iStyle = Rendering.Line_list[j % len(Rendering.Line_list)]
            elif MyDriver.lineFlag == 'cycle_colour':
                iStyle = Rendering.Line_list[(j/len(Rendering.Colours_list[MyDriver.colourSequence][0])) % len(Rendering.Line_list)]
            else:
                iStyle = MyDriver.lineFlag
        else:
            if MyDriver.pointFlag == 'cycle_all':
                iStyle = Rendering.Point_list[j % len(Rendering.Point_list)]
            elif MyDriver.pointFlag == 'cycle_colour':
                iStyle = Rendering.Point_list[(j/len(Rendering.Colours_list[MyDriver.colourSequence][0])) % len(Rendering.Point_list)]
            else:
                iStyle = MyDriver.pointFlag

        if not masked:
            myMask = (np.zeros(len(MyDriver.Model_list[i].Variables[y][0])) == 0.)
        else:
            myMask = BuildMask(plotif[0],plotif[1],i)
            if all([v == False for v in myMask]):
                print 'Plotif: no points met the condition',plotif[0],plotif[1],' for star ',i
                if len(Star_list) == 1:
                    print 'Aborting...'
                    return
                else:
                    continue

        if not MyDriver.axisFlag[0]:
            if j==0 and (not MyDriver.keepplot or MyDriver.multiplot):
                MyDriver.axisLimits[0] = np.nanmin(MyDriver.Model_list[i].Variables[MyDriver.Xvar][0][myMask])
                if MyDriver.ilog[0]:
                    if MyDriver.axisLimits[0] > 0.:
                        MyDriver.axisLimits[0] = np.log10(MyDriver.axisLimits[0])
                    else:
                        MyDriver.axisLimits[0] = -30.
            else:
                if MyDriver.ilog[0]:
                    if np.log10(np.nanmin(MyDriver.Model_list[i].Variables[MyDriver.Xvar][0][myMask])) < MyDriver.axisLimits[0]:
                        if np.isinf(np.log10(np.nanmin(MyDriver.Model_list[i].Variables[MyDriver.Xvar][0][myMask]))):
                            MyDriver.axisLimits[0] = -30.
                        else:
                            MyDriver.axisLimits[0] = np.log10(np.nanmin(MyDriver.Model_list[i].Variables[MyDriver.Xvar][0][myMask]))
                else:
                    if np.nanmin(MyDriver.Model_list[i].Variables[MyDriver.Xvar][0][myMask]) < MyDriver.axisLimits[0]:
                        MyDriver.axisLimits[0] = np.nanmin(MyDriver.Model_list[i].Variables[MyDriver.Xvar][0][myMask])
        if not MyDriver.axisFlag[1]:
            if j==0 and (not MyDriver.keepplot or MyDriver.multiplot):
                MyDriver.axisLimits[1] = np.nanmax(MyDriver.Model_list[i].Variables[MyDriver.Xvar][0][myMask])
                if MyDriver.ilog[0]:
                    if MyDriver.axisLimits[1] > 0.:
                        MyDriver.axisLimits[1] = np.log10(MyDriver.axisLimits[1])
                    else:
                        MyDriver.axisLimits[1] = -30.
            else:
                if MyDriver.ilog[0]:
                    if np.log10(np.nanmax(MyDriver.Model_list[i].Variables[MyDriver.Xvar][0][myMask])) > MyDriver.axisLimits[1]:
                        if np.isinf(np.log10(np.nanmax(MyDriver.Model_list[i].Variables[MyDriver.Xvar][0][myMask]))):
                            MyDriver.axisLimits[1] = -30.
                        else:
                            MyDriver.axisLimits[1] = np.log10(np.nanmax(MyDriver.Model_list[i].Variables[MyDriver.Xvar][0][myMask]))
                else:
                    if np.nanmax(MyDriver.Model_list[i].Variables[MyDriver.Xvar][0][myMask]) > MyDriver.axisLimits[1]:
                        MyDriver.axisLimits[1] = np.nanmax(MyDriver.Model_list[i].Variables[MyDriver.Xvar][0][myMask])
        if not MyDriver.axisFlag[2]:
            if j==0 and (not MyDriver.keepplot or MyDriver.multiplot):
                MyDriver.axisLimits[2] = np.nanmin(MyDriver.Model_list[i].Variables[y][0][myMask])
                if MyDriver.ilog[1]:
                    if MyDriver.axisLimits[2] > 0.:
                        MyDriver.axisLimits[2] = np.log10(MyDriver.axisLimits[2])
                    else:
                        MyDriver.axisLimits[2] = -30.
            else:
                if MyDriver.ilog[1]:
                    if np.nanmin(MyDriver.Model_list[i].Variables[y][0][myMask]) > 0.:
                        if np.log10(np.nanmin(MyDriver.Model_list[i].Variables[y][0][myMask])) < MyDriver.axisLimits[2]:
                            MyDriver.axisLimits[2] = np.log10(np.nanmin(MyDriver.Model_list[i].Variables[y][0][myMask]))
                    else:
                        if MyDriver.axisLimits[2] > -30.:
                            MyDriver.axisLimits[2] = -30.
                else:
                    if np.nanmin(MyDriver.Model_list[i].Variables[y][0][myMask]) < MyDriver.axisLimits[2]:
                        MyDriver.axisLimits[2] = np.nanmin(MyDriver.Model_list[i].Variables[y][0][myMask])
        if MyDriver.axisFlag[3] == False:
            if j==0 and (not MyDriver.keepplot or MyDriver.multiplot):
                MyDriver.axisLimits[3] = np.nanmax(MyDriver.Model_list[i].Variables[y][0][myMask])
                if MyDriver.ilog[1]:
                    if MyDriver.axisLimits[3] > 0.:
                        MyDriver.axisLimits[3] = np.log10(MyDriver.axisLimits[3])
                    else:
                        MyDriver.axisLimits[3] = -30.
            else:
                if MyDriver.ilog[1]:
                    if np.nanmax(MyDriver.Model_list[i].Variables[y][0][myMask]) > 0.:
                        if np.log10(np.nanmax(MyDriver.Model_list[i].Variables[y][0][myMask])) > MyDriver.axisLimits[3]:
                            MyDriver.axisLimits[3] = np.log10(np.nanmax(MyDriver.Model_list[i].Variables[y][0][myMask]))
                    else:
                        if MyDriver.axisLimits[3] < -30.:
                            MyDriver.axisLimits[3] = -30.
                else:
                    if np.nanmax(MyDriver.Model_list[i].Variables[y][0][myMask]) > MyDriver.axisLimits[3]:
                        MyDriver.axisLimits[3] = np.nanmax(MyDriver.Model_list[i].Variables[y][0][myMask])
        if MyDriver.modeplot != 'evol':
            MyDriver.Model_list[i].Plot(MyDriver.Xvar,y,myMask,iColour,iStyle,myLegend,[],forced_line=forced_line)
        else:
            MyDriver.Model_list[i].Plot(MyDriver.Xvar,y,myMask,iColour,iStyle,myLegend,MyDriver.Model_list[i].timestep,forced_line=forced_line)
        if MyDriver.Link_ModelCurve:
            if MyDriver.modeplot != 'struc':
                print '{0: <7s}: {1: 4d} - {2}'.format(ColourName,i,MyDriver.Model_list[i].Variables['FileName'][0])
            else:
                print '{0: <7s}: {1: 4d} - {2} ({3})'.format(ColourName,i,MyDriver.Model_list[i].Variables['FileName'][0],MyDriver.Model_list[i].Variables['Model'][0])
        j += 1

    axisInv_save = list(MyDriver.axisInv)
    if MyDriver.Xvar in Rendering.Inversed_by_default:
        MyDriver.axisInv[0] = True

    Xmin,Xmax,Ymin,Ymax,MyDriver.axisLimits[0],MyDriver.axisLimits[1],MyDriver.axisLimits[2],MyDriver.axisLimits[3] = DefNewLimits(MyDriver.axisLimits)

    New_Axes.axis((Xmin,Xmax,Ymin,Ymax))
    Xlabel = MyDriver.Model_list[Star_list[0]].Variables[MyDriver.Xvar][1]
    if not MyDriver.axisLabel[0]:
        Ylabel = MyDriver.Model_list[Star_list[0]].Variables[y][1]
    else:
        Ylabel = MyDriver.axisLabel[1]
    if MyDriver.ilog[0]:
        Xlabel = 'log('+Xlabel+')'
    elif MyDriver.ilog[1]:
        Ylabel = 'log('+Ylabel+')'
    New_Axes.set_xlabel(Xlabel,fontsize = MyDriver.fontSize+4,labelpad=20)
    New_Axes.set_ylabel(Ylabel,fontsize = MyDriver.fontSize+4)
    New_Axes.tick_params(axis='x', labelsize = MyDriver.fontSize)
    New_Axes.tick_params(axis='y', labelsize = MyDriver.fontSize)
    if MyDriver.minorLoc != 0:
        if MyDriver.logScale[0] == False:
            New_Axes.xaxis.set_minor_locator(mptick.AutoMinorLocator(MyDriver.minorLoc))
        if MyDriver.logScale[1] == False:
            New_Axes.yaxis.set_minor_locator(mptick.AutoMinorLocator(MyDriver.minorLoc))
    else:
        if MyDriver.logScale[0] == False:
            New_Axes.xaxis.set_minor_locator(mptick.AutoMinorLocator())
        if MyDriver.logScale[1] == False:
            New_Axes.yaxis.set_minor_locator(mptick.AutoMinorLocator())

    New_Axes.axes.xaxis.set_tick_params(which='major',length=MyDriver.ticklength,width=MyDriver.tickwidth)
    New_Axes.axes.xaxis.set_tick_params(which='minor',length=MyDriver.ticklength/2,width=MyDriver.tickwidth)
    New_Axes.axes.yaxis.set_tick_params(which='major',length=MyDriver.ticklength,width=MyDriver.tickwidth)
    New_Axes.axes.yaxis.set_tick_params(which='minor',length=MyDriver.ticklength/2,width=MyDriver.tickwidth)
    if MyDriver.logScale[0] == False:
        New_Axes.ticklabel_format(style='sci',scilimits=(-3,4),axis='x')
    if MyDriver.logScale[1] == False:
        New_Axes.ticklabel_format(style='sci',scilimits=(-3,4),axis='y')

    plt.show(block=False)
    MyDriver.Store_Axes(New_Axes)
    MyDriver.axisInv = list(axisInv_save)

def Plot_colour(y,z,binz=0,s='',logs=False,plotif=['',''],ticks=[]):
    """Plots the input variable y as a function of the x variable entered with defX(Variable_name),
          and colour-coded as a function of the input variable z.
       By default, the colour map is 'gist_rainbow', but it can be modified
          through the command set_colourMap(NewMap).
       The limits on z values can be modified through the command CBLimits(min=..., max=...).
       the optional arguments are:
        - binz=n to limit the number of colours to n;
        - s='var' to resize the dots according to the value of 'var' (switches automatically to Points(True));
        - logs=True to take the log of the s variable;
        - plotif=['var','cond'] to limit the plot to a condition on a variable."""
    varsize = s!=''
    if varsize:
        pointsize = s
    else:
        pointsize = MyDriver.pointSize
    rc('text', usetex=MyDriver.LatexEnabled)
    if plotif == ['','']:
        masked = False
    else:
        masked = True

    NewFig,mySubplot = configPlot()
    if not MyDriver.keepplot:
        if NewFig:
            if MyDriver.closeFig:
                plt.close()
            MyDriver.AddFigure((8,8))
        MyDriver.current_Fig.subplots_adjust(wspace=MyDriver.subplotSep)
        New_Axes = MyDriver.current_Fig.add_subplot(mySubplot)
    else:
        if MyDriver.multiplot:
            New_Axes = MyDriver.Previous_Axe.twinx()
        else:
            New_Axes = MyDriver.Previous_Axe

    Star_list=MyDriver.list_keyOK(y,MyDriver.SelectedModels)
    Star_list=MyDriver.list_keyOK(MyDriver.Xvar,Star_list)
    Star_list=MyDriver.list_keyOK(z,Star_list)
    Star_list=MyDriver.Zero_LengthOK(y,Star_list)
    Star_list=MyDriver.Zero_LengthOK(MyDriver.Xvar,Star_list)
    Star_list=MyDriver.Zero_LengthOK(z,Star_list)
    if varsize:
        if not MyDriver.iPoints:
            Points(True)
        Star_list=MyDriver.list_keyOK(pointsize,Star_list)
        Star_list=MyDriver.Zero_LengthOK(pointsize,Star_list)

    if len(Star_list) == 0:
        print "Nothing left in the input list!"
        return

    myZ = {}
    myS = {}

    j = 0
    MinMap = 1.e90
    MaxMap = -1.e90
    for i in Star_list:
        if not masked:
            myMask = (np.zeros(len(MyDriver.Model_list[i].Variables[y][0])) == 0.)
        else:
            myMask = BuildMask(plotif[0],plotif[1],i)
            if all([v == False for v in myMask]):
                print 'Plotif: no points met the condition',plotif[0],plotif[1],' for star ',i
                if len(Star_list) == 1:
                    print 'Aborting...'
                    return
                else:
                    continue
        myZ[i] = MyDriver.Model_list[i].Variables[z][0][myMask]

        if MyDriver.ilog[2]:
            myZ[i][myZ[i]<=0.] = 1.e-30
            myZ[i] = np.log10(myZ[i])

        if not MyDriver.CBFlag[0]:
            if np.nanmin(myZ[i]) < MinMap:
                MinMap = np.nanmin(myZ[i])
        else:
            MinMap = MyDriver.CBLimits[0]
        if not MyDriver.CBFlag[1]:
            if np.nanmax(myZ[i]) > MaxMap:
                MaxMap = np.nanmax(myZ[i])
        else:
            MaxMap = MyDriver.CBLimits[1]
        if varsize:
            myS[i] = MyDriver.Model_list[i].Variables[pointsize][0]
            if logs:
                myS[i][myS[i]<=0.] = 1.e-30
                myS[i] = np.log10(myS[i])
            Smin = np.min(myS[i])
            Smax = np.max(myS[i])
            myS[i] = (myS[i]-Smin)/(Smax-Smin)*(MyDriver.PSmax-MyDriver.PSmin)+MyDriver.PSmin
            pointsize = myS[i]

    for i in Star_list:
        if not masked:
            myMask = (np.zeros(len(MyDriver.Model_list[i].Variables[y][0])) == 0.)
        else:
            myMask = BuildMask(plotif[0],plotif[1],i)
            if all([v == False for v in myMask]):
                print 'Plotif: no points met the condition',plotif[0],plotif[1],' for star ',i
                if len(Star_list) == 1:
                    print 'Aborting...'
                    return
                else:
                    continue
        if MyDriver.lineFlag == 'cycle_all':
            iLine = Rendering.Line_list[j % len(Rendering.Line_list)]
        else:
            iLine = MyDriver.lineFlag
        if MyDriver.axisFlag[0] == False:
            if j==0:
                MyDriver.axisLimits[0] = np.nanmin(MyDriver.Model_list[i].Variables[MyDriver.Xvar][0][myMask])
            else:
                if np.nanmin(MyDriver.Model_list[i].Variables[MyDriver.Xvar][0][myMask]) < MyDriver.axisLimits[0]:
                    MyDriver.axisLimits[0] = np.nanmin(MyDriver.Model_list[i].Variables[MyDriver.Xvar][0][myMask])
        if MyDriver.axisFlag[1] == False:
            if j==0:
                MyDriver.axisLimits[1] = np.nanmax(MyDriver.Model_list[i].Variables[MyDriver.Xvar][0][myMask])
            else:
                if np.nanmax(MyDriver.Model_list[i].Variables[MyDriver.Xvar][0][myMask]) > MyDriver.axisLimits[1]:
                    MyDriver.axisLimits[1] = np.nanmax(MyDriver.Model_list[i].Variables[MyDriver.Xvar][0][myMask])
        if MyDriver.axisFlag[2] == False:
            if j==0:
                MyDriver.axisLimits[2] = np.nanmin(MyDriver.Model_list[i].Variables[y][0][myMask])
            else:
                if np.nanmin(MyDriver.Model_list[i].Variables[y][0][myMask]) < MyDriver.axisLimits[2]:
                    MyDriver.axisLimits[2] = np.nanmin(MyDriver.Model_list[i].Variables[y][0][myMask])
        if MyDriver.axisFlag[3] == False:
            if j==0:
                MyDriver.axisLimits[3] = np.nanmax(MyDriver.Model_list[i].Variables[y][0][myMask])
            else:
                if np.nanmax(MyDriver.Model_list[i].Variables[y][0][myMask]) > MyDriver.axisLimits[3]:
                    MyDriver.axisLimits[3] = np.nanmax(MyDriver.Model_list[i].Variables[y][0][myMask])

        cmap=cm.get_cmap(MyDriver.colourMap)
        if binz != 0:
            bounds = np.linspace(MinMap,MaxMap,binz+1)
        else:
            bounds = np.linspace(MinMap,MaxMap)
        norm = colors.BoundaryNorm(bounds,cmap.N)

        if not MyDriver.iPoints:
            segments = MyDriver.Model_list[i].Get_Segments(MyDriver.Xvar,y,myMask)

            MyLineColl = LineCollection(segments,cmap=cmap,norm=norm)
            MyLineColl.set_array(myZ[i])
            MyLineColl.set_linewidth(MyDriver.lineWidth)

            New_Axes.add_collection(MyLineColl)

            if MyDriver.steps:
                x_step,y_step,z_step = Build_timestep(MyDriver.Model_list[i].Variables[MyDriver.Xvar][0][myMask],MyDriver.Model_list[i].Variables[y][0][myMask],MyDriver.Model_list[i].timestep,myZ[i])
                colour = plt.cm.jet((np.array(z_step)-MinMap)/(MaxMap-MinMap))
                plt.scatter(x_step,y_step,marker='o',s=80.,facecolors='none', edgecolors=colour)
        else:
            plt.scatter(MyDriver.Model_list[i].Variables[MyDriver.Xvar][0][myMask],MyDriver.Model_list[i].Variables[y][0][myMask],c=myZ[i],cmap=cmap,s=pointsize,linewidths=0,norm=norm)
        j += 1

        axisInv_save = list(MyDriver.axisInv)
        if MyDriver.Xvar in Rendering.Inversed_by_default:
            MyDriver.axisInv[0] = True

    Xmin,Xmax,Ymin,Ymax,MyDriver.axisLimits[0],MyDriver.axisLimits[1],MyDriver.axisLimits[2],MyDriver.axisLimits[3] = DefNewLimits(MyDriver.axisLimits)

    New_Axes.axis((Xmin,Xmax,Ymin,Ymax))
    Xlabel = MyDriver.Model_list[Star_list[0]].Variables[MyDriver.Xvar][1]
    if not MyDriver.axisLabel[0]:
        Ylabel = MyDriver.Model_list[Star_list[0]].Variables[y][1]
    else:
        Ylabel = MyDriver.axisLabel[1]
    if MyDriver.ilog[0]:
        Xlabel = 'log('+Xlabel+')'
    elif MyDriver.ilog[1]:
        Ylabel = 'log('+Ylabel+')'
    New_Axes.xaxis.labelpad = 0.1
    New_Axes.set_xlabel(Xlabel,fontsize = MyDriver.fontSize+4)
    New_Axes.set_ylabel(Ylabel,fontsize = MyDriver.fontSize+4)
    New_Axes.tick_params(axis='x', labelsize = MyDriver.fontSize)
    New_Axes.tick_params(axis='y', labelsize = MyDriver.fontSize)
    New_Axes.xaxis.set_minor_locator(mptick.AutoMinorLocator(4))
    New_Axes.yaxis.set_minor_locator(mptick.AutoMinorLocator(4))

    New_Axes.axes.xaxis.set_tick_params(which='major',length=MyDriver.ticklength,width=MyDriver.tickwidth)
    New_Axes.axes.xaxis.set_tick_params(which='minor',length=MyDriver.ticklength/2,width=MyDriver.tickwidth)
    New_Axes.axes.yaxis.set_tick_params(which='major',length=MyDriver.ticklength,width=MyDriver.tickwidth)
    New_Axes.axes.yaxis.set_tick_params(which='minor',length=MyDriver.ticklength/2,width=MyDriver.tickwidth)
    New_Axes.ticklabel_format(style='sci',scilimits=(-3,4),axis='both')
    ColorBarSettings = plt.cm.ScalarMappable(cmap=MyDriver.colourMap, norm=norm)
    ColorBarSettings._A = []
    if ticks==[]:
        CBticks = np.linspace(MinMap,MaxMap,MyDriver.CBticksN)
    else:
        CBticks = ticks
    MyCB = MyDriver.current_Fig.colorbar(ColorBarSettings,fraction=0.08,ticks=CBticks)
    if MyDriver.ilog[2]:
        MyCB.ax.set_ylabel('log('+MyDriver.Model_list[Star_list[0]].Variables[z][1]+')',fontsize=MyDriver.fontSize-2)
        MyCB.ax.yaxis.set_label_position('right')
    else:
        MyCB.ax.set_ylabel(MyDriver.Model_list[Star_list[0]].Variables[z][1],fontsize=MyDriver.fontSize-2)
        MyCB.ax.yaxis.set_label_position('right')
    MyDriver.get_CBlimits = MyCB.get_clim()
    print MyDriver.get_CBlimits

    MyDriver.lastXvar = MyDriver.Xvar
    MyDriver.lastYvar = y

    plt.draw()
    plt.show(block=False)
    MyDriver.Store_Axes(New_Axes)
    MyDriver.axisInv = list(axisInv_save)

def Histo(var,bins,cum=False):
    """Plots histograms in cluster mode.
       Usage: Histo('var',bins_number).
       The optional parameter cum allows for a cumulative distribution if set to True (default False)."""
    if MyDriver.modeplot != 'cluster':
        return 'Plotting histograms is only available in cluster mode.'
    Star_list = MyDriver.list_keyOK(var,MyDriver.SelectedModels)
    Colour_list = list(Rendering.Colours_list[MyDriver.colourSequence][0][1:])
    Colour_name = list(Rendering.Colours_list[MyDriver.colourSequence][1][1:])
    if MyDriver.colourSequence == 'contrast':
        Colour_list[0],Colour_list[1],Colour_list[2] = Colour_list[2],Colour_list[0],Colour_list[1]

    for i in Star_list:
        if not MyDriver.axisFlag[0]:
            if i == Star_list[0]:
                MyDriver.axisLimits[0] = np.nanmin(MyDriver.Model_list[i].Variables[var][0])
                if MyDriver.ilog[0]:
                    if MyDriver.axisLimits[0] > 0.:
                        MyDriver.axisLimits[0] = np.log10(MyDriver.axisLimits[0])
                    else:
                        MyDriver.axisLimits[0] = -30.
            else:
                if MyDriver.ilog[0]:
                    if np.log10(np.nanmin(MyDriver.Model_list[i].Variables[var][0])) < MyDriver.axisLimits[0]:
                        if np.isinf(np.log10(np.nanmin(MyDriver.Model_list[i].Variables[var][0]))):
                            MyDriver.axisLimits[0] = -30.
                        else:
                            MyDriver.axisLimits[0] = np.log10(np.nanmin(MyDriver.Model_list[i].Variables[var][0]))
                else:
                    if np.nanmin(MyDriver.Model_list[i].Variables[var][0]) < MyDriver.axisLimits[0]:
                        MyDriver.axisLimits[0] = np.nanmin(MyDriver.Model_list[i].Variables[var][0])
        if not MyDriver.axisFlag[1]:
            if i == Star_list[0]:
                MyDriver.axisLimits[1] = np.nanmax(MyDriver.Model_list[i].Variables[var][0])
                if MyDriver.ilog[0]:
                    if MyDriver.axisLimits[1] > 0.:
                        MyDriver.axisLimits[1] = np.log10(MyDriver.axisLimits[1])
                    else:
                        MyDriver.axisLimits[1] = -30.
            else:
                if MyDriver.ilog[0]:
                    if np.log10(np.nanmax(MyDriver.Model_list[i].Variables[var][0])) > MyDriver.axisLimits[1]:
                        if np.isinf(np.log10(np.nanmax(MyDriver.Model_list[i].Variables[var][0]))):
                            MyDriver.axisLimits[1] = -30.
                        else:
                            MyDriver.axisLimits[1] = np.log10(np.nanmax(MyDriver.Model_list[i].Variables[var][0]))
                else:
                    if np.nanmax(MyDriver.Model_list[i].Variables[var][0]) > MyDriver.axisLimits[1]:
                        MyDriver.axisLimits[1] = np.nanmax(MyDriver.Model_list[i].Variables[var][0])

    Bins = np.linspace(MyDriver.axisLimits[0],MyDriver.axisLimits[1],num=bins,endpoint=True)
    if np.size(Star_list) == 1 and not cum:
        type_hist = 'bar'
    else:
        type_hist = 'step'
    plt.figure()

    j = 0
    for i in Star_list:
        if MyDriver.colourFlag == 'cycle':
            iColour = Colour_list[j % len(Colour_list)]
            ColourName = Colour_name[j % len(Colour_name)]
            MyDriver.Link_ModelCurve = True
        else:
            iColour = MyDriver.colourFlag
            ColourName = MyDriver.colourFlag
            MyDriver.Link_ModelCurve = False
        n, Bins, patches = plt.hist(MyDriver.Model_list[i].Variables[var][0], Bins, histtype=type_hist, cumulative=cum, color=iColour)
        j += 1
    plt.xlim(MyDriver.axisLimits[0],MyDriver.axisLimits[1])
    plt.xlabel(MyDriver.Model_list[Star_list[0]].Variables[var][1])
    plt.ylabel('$N_\star$')
    plt.show()

def HRD_plot(corr=False,spectro=False,dark=False,ceph=True,zcol='',binz=256,plotif=['',''],ticks=[],forced_line=False):
    """Plots a HR diagram in L and Teff.
       The optional parameters are:
          corr=True, for the drawing with Teffcorr instead of Teff;
          spectro=True, for the spectroscopic HRD;
          dark=True, for the Teff and L modified by gravity (+limb) darkening (only in cluster mode);
          zcol='zvar' for a plot colour-coded by variable zvar;
          binz=n to set the number of colours for the colour plot;
          plotif=['var','cond'], for limiting the plot to a condition on a variable."""
    if MyDriver.modeplot != 'evol' and MyDriver.modeplot != 'cluster':
        print 'Wrong mode for HRD'
        return
    if dark and MyDriver.modeplot != 'cluster':
        return 'The gravity (+limb) darkening option is yet available only in cluster mode.'
    Xvar_save = MyDriver.Xvar
    if corr and not spectro and not dark:
        MyDriver.Xvar = 'Teffcorr'
    elif not corr or (spectro and not dark):
        MyDriver.Xvar = 'Teff'
    else:
        if MyDriver.modeplot != 'cluster':
            return 'Something went wrong with the options you chose.'
        else:
            MyDriver.Xvar = 'Teff_lgd'
    if not spectro and not dark:
        yvar = 'L'
    elif spectro:
        if not dark:
            yvar = 'sL'
        else:
            yvar = 'sLmean'
    else:
        yvar = 'L_lgd'
    if zcol:
        Plot_colour(yvar,zcol,binz=binz,plotif=plotif,ticks=ticks)
    else:
        Plot(yvar,plotif=plotif,forced_line=forced_line)
    if ceph and not spectro:
        Cepheid_strip()
    MyDriver.Xvar = Xvar_save
    no_axis_inv()

def CMD(c='',zcol='',binz=256,noised='',plotif=['',''],ticks=[],forced_line=False):
    """Plots a CMD for the colours entered in parameters. If called without argument, M_V versus B-V is plotted.
       Usage: CMD(), or CMD('VBV')"""
    if MyDriver.modeplot != 'evol' and MyDriver.modeplot != 'cluster':
        print 'Wrong mode for HRD'
        return
    if noised and MyDriver.modeplot != 'cluster':
        print 'Argument "noised" only available for clusters'
        noised = ''
    Xvar_save = MyDriver.Xvar
    if c == '':
        vary = 'M_V'
        varx = 'B-V'
    elif len(c) < 3:
        return "You have to enter either nothing (for M_V versus B-V), or a triplet like 'BUB' or 'VBV'."
    else:
        vary = 'M_'+c[0]
        varx = c[1]+'-'+c[2]
    if 'x' in noised.lower():
        varx = varx+'_noised'
    if 'y' in noised.lower():
        vary = vary+'_noised'

    defX(varx)
    axis_inv('y')
    if zcol:
        Plot_colour(vary,zcol,binz=binz,plotif=plotif,ticks=ticks)
    else:
        Plot(vary,plotif=plotif,forced_line=forced_line)
    no_axis_inv()

    MyDriver.Xvar = Xvar_save

def rhoT(deg=True,PISN=True,zcol='',binz=256,plotif=['',''],ticks=[],forced_line=False,*args):
    """Plots a T-rho diagram if in structure mode or a T_c-rho_c diagram if in evolution mode.
       Called with deg=True, it draws the limits between perfect gaz and degenerate gaz.
       Called with PISN=True, show the approximate region where pair instability occurs.
          If 'legend' is passed as an argument, it draws the legend of the degenerate line."""
    Xvar_save = MyDriver.Xvar
    if Xvar_save in Rendering.Inversed_by_default:
        MyDriver.axisInv[0] = False
    if MyDriver.modeplot == 'evol':
        MyDriver.Xvar = 'rhoc'
        yVar = 'Tc'
    elif MyDriver.modeplot == 'struc':
        MyDriver.Xvar = 'rho'
        yVar = 'T'
        logVar('xy')
    if zcol:
        Plot_colour(yVar,zcol,binz=binz,plotif=plotif,ticks=ticks)
    else:
        Plot(yVar,plotif=plotif,forced_line=forced_line)
    if deg:
        if 'legend' in args:
            degenerate_line('legend')
        else:
            degenerate_line()
    if PISN:
        PISN_zone()
    if MyDriver.modeplot == 'struc':
        no_logVar()
    MyDriver.Xvar = Xvar_save

def gTeff(dark=False,mean=False,surf=False,corr=False,noised='',zcol='',binz=256,plotif=['',''],ticks=[],forced_line=False):
    """Plots a diagram of g as a function of Teff."""
    if MyDriver.modeplot not in ['evol','cluster']:
        switch('evol')
    if MyDriver.modeplot != 'cluster' and (dark or mean):
        print 'arguments "dark", "mean", or "noised" available only for clusters'
        dark=False
        mean=False
        noised=False
    Xvar_save = MyDriver.Xvar
    if dark:
        MyDriver.Xvar = 'Teff_lgd'
    elif corr:
        MyDriver.Xvar = 'Teffcorr'
    else:
        MyDriver.Xvar = 'Teff'
    if mean:
        yvar = 'gmean'
    elif surf:
        yvar = 'gsurf'
    else:
        yvar = 'gpol'
    if 'x' in noised.lower():
        MyDriver.Xvar = MyDriver.Xvar+'_noised'
    if 'y' in noised.lower():
        yvar = yvar+'_noised'
    axis_inv('y')
    if zcol:
        Plot_colour(yvar,zcol,binz=binz,plotif=plotif,ticks=ticks)
    else:
        Plot(yvar,plotif=plotif,forced_line=forced_line)
    no_axis_inv()
    MyDriver.Xvar = Xvar_save

def YTeff(corr=False,zcol='',binz=256,plotif=['',''],ticks=[],forced_line=False):
    """Plots a diagram of Teff as a function of the central He abundance."""
    if MyDriver.modeplot not in ['evol','cluster']:
        switch('evol')
    Xvar_save = MyDriver.Xvar
    MyDriver.Xvar = 'He4c'
    if corr:
        yvar = 'Teffcorr'
    else:
        yvar = 'Teff'
    if zcol:
        Plot_colour(yvar,zcol,binz=binz,plotif=plotif,ticks=ticks)
    else:
        Plot(yvar,plotif=plotif,forced_line=forced_line)
    MyDriver.Xvar = Xvar_save

def Abund(where='x'):
    """Plots the abundance profiles of the main species.
       The input argument may take three values:
          in evol mode: 'c' for central abundances et 's' for surface abundances,
          in structure mode: 'p' for profile.
          in cluster mode: surface anyway, maybe omitted."""
    if where == 'x' and MyDriver.modeplot == 'cluster':
        where = 's'
    if where not in 'cCpPsS':
        print 'The argument should be "s,c, or p"'
        return
    Xvar_save = MyDriver.Xvar
    LineFlag_save = MyDriver.lineFlag
    ColourFlag_save = MyDriver.colourFlag
    MyDriver.Link_ModelCurve = False
    MyDriver.axisLabel[0] = True
    if not MyDriver.axisFlag[2]:
        if not MyDriver.ilog[1]:
            MyYmin = 0.
        else:
            MyYmin = -5.
    else:
        MyYmin = MyDriver.axisLimits[2]
    if not MyDriver.axisFlag[3]:
        if not MyDriver.ilog[1]:
            MyYmax = 1.
        else:
            MyYmax = 0.
    else:
        MyYmax = MyDriver.axisLimits[3]
    Limits(ymin=MyYmin,ymax=MyYmax)
    if where in 'sScC':
        MyDriver.lineFlag = 'cycle_all'
        if MyDriver.modeplot not in ['evol','cluster']:
            switch('evol')
        if where in 'sS':
            MyDriver.axisLabel[1] = 'Surface abund. [mass frac.]'
            set_colourFlag('Black')
            Plot('H1s')
            keep_plot(True)
            set_colourFlag('Gray')
            Plot('He4s')
            set_colourFlag('Red')
            Plot('C12s')
            set_colourFlag('ForestGreen')
            Plot('N14s')
            set_colourFlag('Blue')
            Plot('O16s')
            set_colourFlag('Turquoise')
            Plot('Ne20s')
        elif where in 'cC':
            MyDriver.axisLabel[1] = 'Central abund. [mass frac.]'
            set_colourFlag('Black')
            Plot('H1c')
            keep_plot(True)
            set_colourFlag('Gray')
            Plot('He4c')
            set_colourFlag('Red')
            Plot('C12c')
            set_colourFlag('ForestGreen')
            Plot('N14c')
            set_colourFlag('Blue')
            Plot('O16c')
            set_colourFlag('Turquoise')
            Plot('Ne20c')
            set_colourFlag('Orange')
            try:
                Plot('Si28c')
            except:
                pass
        print '\n H1:\t\t black\n He4:\t\t grey\n C12:\t\t red\n N14:\t\t green\n O16:\t\t blue\n Ne20:\t\t cyan\n Si28:\t\t orange'
    elif where in 'pP':
        MyDriver.axisLabel[1] = 'Abund. profile [mass frac.]'
        if MyDriver.modeplot != 'struc':
            switch('struc')
        if len(MyDriver.SelectedModels) > 1:
            multiplot = True
            MyDriver.lineFlag = 'cycle_all'
        else:
            multiplot = False
        set_colourFlag('Black')
        Plot('H1')
        keep_plot(True)
        set_colourFlag('Gray')
        Plot('He4')
        set_colourFlag('Red')
        Plot('C12')
        if not multiplot:
            MyDriver.lineFlag = '--'
        else:
            set_colourFlag('Coral')
        Plot('C13')
        if not multiplot:
            MyDriver.lineFlag = '-'
        set_colourFlag('ForestGreen')
        Plot('N14')
        if not multiplot:
            MyDriver.lineFlag = '--'
        else:
            set_colourFlag('Green')
        Plot('N15')
        if not multiplot:
            MyDriver.lineFlag = '-'
            set_colourFlag('Blue')
        else:
            set_colourFlag('DarkBlue')
        Plot('O16')
        if not multiplot:
            MyDriver.lineFlag = '--'
        else:
            set_colourFlag('Blue')
        Plot('O17')
        if not multiplot:
            MyDriver.lineFlag = ':'
        else:
            set_colourFlag('DodgerBlue')
        Plot('O18')
        if not multiplot:
            MyDriver.lineFlag = '-'
        set_colourFlag('Turquoise')
        Plot('Ne20')
        if not multiplot:
            MyDriver.lineFlag = '--'
        else:
            set_colourFlag('PaleTurquoise')
        Plot('Ne22')
        if not multiplot:
            MyDriver.lineFlag = '-'
            set_colourFlag('MediumOrchid')
        else:
            set_colourFlag('Purple')
        Plot('Mg24')
        if not multiplot:
            MyDriver.lineFlag = '--'
        else:
            set_colourFlag('MediumOrchid')
        Plot('Mg25')
        if not multiplot:
            MyDriver.lineFlag = ':'
        else:
            set_colourFlag('Orchid')
        Plot('Mg26')
        set_colourFlag('orange')
        if not multiplot:
            MyDriver.lineFlag = '-'
        else:
            set_colourFlag('Orchid')
        Plot('Si28')
        if not multiplot:
            print '\n H:\t\t black\n He:\t\t grey\n C:\t\t red\n N:\t\t green\n O:\t\t blue\n Ne:\t\t cyan\n Mg:\t\t purple\n Si:\t\t orange'
        else:
            print '\n H:\t\t black\n He:\t\t grey\n C:\t\t red\n N:\t\t green\n O:\t\t blue\n Ne:\t\t cyan\n Mg:\t\t purple'

    keep_plot(False)
    set_colourFlag(ColourFlag_save)
    MyDriver.lineFlag = LineFlag_save
    MyDriver.Xvar = Xvar_save
    MyDriver.axisLabel[0] = False
    MyDriver.Link_ModelCurve = True
    noLimits()

def NCNO(plotif=['',''],forced_line=False):
    """Plots a diagram of N/C as a function of N/O"""
    if MyDriver.modeplot != 'evol' and MyDriver.modeplot != 'cluster':
        switch('evol')
    Xvar_save = MyDriver.Xvar
    MyDriver.Xvar = 'NO'
    Plot('NC',plotif=plotif,forced_line=forced_line)
    MyDriver.Xvar = Xvar_save

def eps(mode=1,conv=True):
    """Plots the energy generation for H, He, and C as well as the one released by neutrinos.
        The optional argument mode=n defines the x-axis:
            1: Mr/Mtot
            2: r
            3: free choice, defined by defX()
        By default, it also draws the convective zones if only one structure is plotted
        (can be changed with 'conv=False')"""
    if MyDriver.modeplot != 'struc':
        switch('struc')
    Xvar_save = MyDriver.Xvar
    if mode == 1:
        defX('Mfrac')
    elif mode == 2:
        defX('r')
    lineFlag_save = MyDriver.lineFlag
    colourFlag_save = MyDriver.colourFlag
    logVar('y')
    num_star = list(MyDriver.SelectedModels)
    if len(num_star) > 1:
        set_lineStyle('cycle_all')
        if conv:
            print 'More than one structure plotted, no convective zones will be plotted.'
            print 'You can plot them later with convZones(num,colour).'
            conv = False
    else:
        set_lineStyle('-')
    set_colourFlag('k')
    Plot('epsH')
    keep_plot(True)
    set_colourFlag('g')
    Plot('epsHe')
    set_colourFlag('r')
    Plot('epsC')
    set_colourFlag(0.60)
    if len(num_star) == 1:
        set_lineStyle(':')
    Plot('epsnu')
    if conv:
        convZones(num_star[0])
    keep_plot(False)
    no_logVar()
    MyDriver.Xvar = Xvar_save
    MyDriver.lineFlag = lineFlag_save
    MyDriver.colourFlag = colourFlag_save

def Nablas():
    """In structure mode, plots the three nablas: ad, rad, and mu."""
    if MyDriver.modeplot != 'struc':
        switch('struc')
    Xvar_save = MyDriver.Xvar
    lineflag_save = MyDriver.lineFlag
    colourflag_save = MyDriver.colourFlag
    set_lineStyle('cycle_all')
    MyDriver.Link_ModelCurve = False
    set_colourFlag('Blue')
    Plot('Nabad')
    keep_plot(True)
    set_colourFlag('Red')
    Plot('Nabrad')
    set_colourFlag('Green')
    Plot('Nabmu')
    change_label('y',r'Nablas: $\nabla_\mathrm{ad},\nabla_\mathrm{rad},\nabla_\mu$')
    keep_plot(False)
    set_colourFlag(colourflag_save)
    set_lineStyle(lineflag_save)
    MyDriver.Xvar = Xvar_save
    MyDriver.axisLabel[0] = False
    MyDriver.Link_ModelCurve = True

def j_profiles(*args):
    """In structure mode, plots the profiles of j_r, j_Kerr, j_Schwarzschild, and j_Kerr,max.
       If 'legend' is passed as an argument, it draws the legend of the lines."""
    if MyDriver.modeplot != 'struc':
        switch('struc')
    norot = np.all(np.array([i for j in MyDriver.SelectedModels for i in MyDriver.Model_list[j].Variables['Omega'][0]])==0.)
    if norot:
        return 'No rotating models, this plot has no sense'
    Xvar_save = MyDriver.Xvar
    LineFlag_save = MyDriver.lineFlag
    ColourFlag_save = MyDriver.colourFlag
    set_lineStyle('cycle_all')
    MyDriver.Link_ModelCurve = False
    logVar('y')
    Limits(ymin=10.)
    set_colourFlag('Blue')
    Plot('jr')
    keep_plot(True)
    set_colourFlag('Red')
    Plot('jS')
    set_colourFlag('Green')
    Plot('jK')
    set_colourFlag('Cyan')
    Plot('jKmax')
    if 'legend' in args:
        put_legend(loc=4,fontsize=MyDriver.fontSize)
    change_label('y',r'$\mathscr{j}_r,\ \mathscr{j}_\mathrm{Schw.},\ \mathscr{j}_\mathrm{Kerr}, \mathscr{j}_\mathrm{Kerr}^\mathrm{max}$')
    no_logVar('y')
    noLimits()
    keep_plot(False)
    set_colourFlag(ColourFlag_save)
    set_lineStyle(LineFlag_save)
    MyDriver.Xvar = Xvar_save
    MyDriver.axisLabel[0] = False
    MyDriver.Link_ModelCurve = True

def Kippen(num_star,burn=False,shift=1,hatch='',noshade=False):
    """Plots a Kippenhahn diagram for the model number entered as input argument.
       The optional parameter burn=True allows for the plotting of the burning zones.
          It needs a file .burn which is seeked by default in the same location as the evolution file,
          and prompts for a new location if not found.
       The optional parameters are:
        - shift = NN to allow to plot the convective structure only once over NN time steps;
        - hatch='/','\','-','|','+','x','O','o','.','*' to hatch the convective zones
                (repeat a symbol for a denser hatching: '//','+++');
        - noshade=True to leave only the hatches to mark the cconvective zones."""
    if MyDriver.modeplot != 'evol':
        switch('evol')
    if not num_star in MyDriver.Model_list.keys():
        print 'please chose a model in the following list:'
        for i in MyDriver.Model_list.keys():
            print MyDriver.Model_list[i].Variables['FileName'],'\t\t',i
        return
    elif MyDriver.Model_list[num_star].Variables['format'][0][0] not in ['o2013','bin']:
        print 'This format does not contain informations on convective zones.'
        return
    else:
        rc('text', usetex=MyDriver.LatexEnabled)
        NewFig,mySubplot = configPlot()
        myMask = (np.zeros(len(MyDriver.Model_list[num_star].Variables['M'][0])) == 0.)
        if not MyDriver.keepplot:
            if NewFig:
                if MyDriver.closeFig:
                    plt.close()
                if mySubplot == 111:
                    MyDriver.AddFigure((11.5,8))
                else:
                    MyDriver.AddFigure((8,8))
            KippenSub = MyDriver.current_Fig.add_subplot(mySubplot)
        Xvar_save = MyDriver.Xvar
        if not MyDriver.Xvar in ['t','t6','t9','ageadv','line']:
            MyDriver.Xvar = 'ageadv'
        if MyDriver.Xvar == 'ageadv':
            MyDriver.axisInv[0] = True
        myLegend1 = MyDriver.Model_list[num_star].Variables['M'][1]
        myLegend2 = MyDriver.Model_list[num_star].Variables['Mcc'][1]
        if hatch=='' and noshade:
            hatch='///'
        MyFig = Kippenhahn()
        MyFig.init_Kipp(MyDriver.Model_list[num_star].Variables['M'][0][0])
        MyFig.findCZ(MyDriver.Model_list[num_star],MyDriver.Model_list[num_star].Variables[MyDriver.Xvar][0],shift)
        MyFig.plot_Kippen(KippenSub,MyDriver.Model_list[num_star].Variables[MyDriver.Xvar][0],hatch,noshade)
        MyDriver.Model_list[num_star].Plot(MyDriver.Xvar,'M',myMask,'Red','-',myLegend1,[])
        MyDriver.Model_list[num_star].Plot(MyDriver.Xvar,'Mcc',myMask,'Black','-',myLegend2,[])

        if MyDriver.axisFlag[0] == False:
            MyDriver.axisLimits[0] =  KippenSub.axis()[0]
        if MyDriver.axisFlag[1] == False:
            MyDriver.axisLimits[1] =  KippenSub.axis()[1]
        if MyDriver.axisFlag[2] == False:
            MyDriver.axisLimits[2] =  KippenSub.axis()[2]
        if MyDriver.axisFlag[3] == False:
            MyDriver.axisLimits[3] =  KippenSub.axis()[3]

        Xmin,Xmax,Ymin,Ymax,MyDriver.axisLimits[0],MyDriver.axisLimits[1],MyDriver.axisLimits[2],MyDriver.axisLimits[3] = DefNewLimits(MyDriver.axisLimits)
        KippenSub.axis((Xmin,Xmax,Ymin,Ymax))

        plt.xlabel(MyDriver.Model_list[num_star].Variables[MyDriver.Xvar][1],fontsize = MyDriver.fontSize+4)
        plt.ylabel('$M_r\ [M_\odot]$',fontsize = MyDriver.fontSize+4)
        if burn:
            Evol_file = MyDriver.Model_list[num_star].Variables['FileName'][0]
            i_ext = Evol_file.rfind('.')
            rootName = Evol_file[:i_ext]
            lineB,ageB,massB,epsH,epsHe,epsC,epsNe,epsO,epsSi = MyDriver.Model_list[num_star].read_BurnFile(rootName+'.burn')
            marine = (0,0,0.4)
            if not isinstance(lineB,float):
                if MyDriver.Xvar == 't6':
                    ageBplot = ageB/1.e6
                elif MyDriver.Xvar == 't9':
                    ageBplot = ageB/1.e9
                elif MyDriver.Xvar == 'ageadv':
                    ageadvB = ageB[-1] - ageB
                    mask = ageadvB<=0.
                    ageadvB[mask] = 1.e-2
                    ageBplot = np.log10(ageadvB)
                plt.plot(ageBplot,epsH[0],c=marine,ls='-')
                plt.plot(ageBplot,epsH[1],ls='--',c=marine)
                plt.plot(ageBplot,epsH[2],ls='--',c=marine)
                plt.plot(ageBplot,epsHe[0],'g-')
                plt.plot(ageBplot,epsHe[1],'g--')
                plt.plot(ageBplot,epsHe[2],'g--')
                if not all(epsC[1]==0.):
                    plt.plot(ageBplot,epsC[0],'r-')
                    plt.plot(ageBplot,epsC[1],'r--')
                    plt.plot(ageBplot,epsC[2],'r--')
                if not all(epsNe[1]==0.):
                    plt.plot(ageBplot,epsNe[0],'c-')
                    plt.plot(ageBplot,epsNe[1],'c--')
                    plt.plot(ageBplot,epsNe[2],'c--')
                if not all(epsO[1]==0.):
                    plt.plot(ageBplot,epsO[0],'b-')
                    plt.plot(ageBplot,epsO[1],'b--')
                    plt.plot(ageBplot,epsO[2],'b--')
                if not all(epsSi[1]==0.):
                    plt.plot(ageBplot,epsSi[0],c='orange',ls='-')
                    plt.plot(ageBplot,epsSi[1],c='orange',ls='--')
                    plt.plot(ageBplot,epsSi[2],c='orange',ls='--')

        KippenSub.tick_params(axis='x', labelsize = MyDriver.fontSize)
        KippenSub.tick_params(axis='y', labelsize = MyDriver.fontSize)
        KippenSub.xaxis.set_minor_locator(mptick.AutoMinorLocator(4))
        KippenSub.yaxis.set_minor_locator(mptick.AutoMinorLocator(4))

        KippenSub.axes.xaxis.set_tick_params(which='major',length=MyDriver.ticklength,width=MyDriver.tickwidth)
        KippenSub.axes.xaxis.set_tick_params(which='minor',length=MyDriver.ticklength/2,width=MyDriver.tickwidth)
        KippenSub.axes.yaxis.set_tick_params(which='major',length=MyDriver.ticklength,width=MyDriver.tickwidth)
        KippenSub.axes.yaxis.set_tick_params(which='minor',length=MyDriver.ticklength/2,width=MyDriver.tickwidth)
        KippenSub.ticklabel_format(style='sci',scilimits=(-3,4),axis='both')

        plt.show(block=False)

        MyDriver.Xvar = Xvar_save

def plotRatio(var1,var2,index=-9999,plotif=['',''],forced_line=False):
    """Plots the ratio between variable_1 and variable_2.
       If an index is provided, for example PlotRatio("M","M",index=0),
          it will plot variable_1 divided by the value of variable_2[index]."""
    abort = False
    if MyDriver.plotmode == 'evol':
      lenvar = 'line'
    elif MyDriver.plotmode == 'struc':
      lenvar = 'shell'
    elif MyDriver.plotmode == 'cluster':
      lenvar = 'Mini'
    if index == 0:
        ilabel = '$_\mathrm{ini}$'
    elif index == -1:
        ilabel = '$_\mathrm{fin}$'
    else:
        ilabel = ''
    for star in MyDriver.Model_list.keys():
        MyStar = MyDriver.Model_list[star]
        MyStar.Variables['ratio'] = [np.zeros(len(MyStar.Variables[lenvar][0])),var1+'/'+var2+ilabel,'']
        if index == -9999:
            mask = MyStar.Variables[var2][0] == 0.
            MyStar.Variables['ratio'][0][np.logical_not(mask)] = MyStar.Variables[var1][0][np.logical_not(mask)]/MyStar.Variables[var2][0][np.logical_not(mask)]
            MyStar.Variables['ratio'][0][mask] = 0.
        else:
            if MyStar.Variables[var2][0][int(index)] != 0.:
                MyStar.Variables['ratio'][0] = MyStar.Variables[var1][0]/MyStar.Variables[var2][0][int(index)]
            else:
                print 'ratio not computable, division by zero.'
                abort = True
    if not abort:
        Plot('ratio',plotif=plotif,forced_line=forced_line)
    for star in MyDriver.Model_list.keys():
        MyDriver.Model_list[star].Variables.pop('ratio')

def Summary_plots(ixaxis=0,*args,**kwargs):
    """Plots a series of figures summarising a model.
       Based on Raphael Hirschi's dhr14.py if in evol mode and structure10.py if in structure mode.
       The first argument ixaxis can be 0 (age), 1 (ageadv), or 2 (model number) in evol mode
          and 0 (Mfrac), 1 (Mr), 2 (r_cm), or 3 (shell number) in struc mode
          default = 0
       If 'legend' is passed as an optional argument, it draws the legend of the lines."""
    autorised_args = ['shift']
    shift = 1
    for arg in kwargs.keys():
        if arg not in autorised_args:
            print 'Bad argument for function Summary_plots. Should be shift=... .'
            return
        if arg == 'shift':
            shift = kwargs[arg]

    linestyle_save = MyDriver.lineFlag
    colourflag_save = MyDriver.colourFlag
    set_lineStyle('cycle_all')
    MyDriver.Link_ModelCurve = False
    fontSize_save = MyDriver.fontSize
    MyDriver.closeFig = False

    if MyDriver.modeplot == 'evol':
        save_Xvar = MyDriver.Xvar
        current_Xvar=save_Xvar
        if ixaxis == 0:
          Xvariable = 'age'
          current_Xvar='t6'
        elif ixaxis == 1:
          Xvariable =  'time left'
          current_Xvar='ageadv'
        elif ixaxis == 2:
          Xvariable = 'model number'
          current_Xvar='line'
        MyDriver.Xvar=current_Xvar

        print 'Evolution plots, x-axis is '+Xvariable
        multiPlot(4)
        set_fontSize(12)
        print '-----------------------------------------------'
        print 'DHR1: HRD, Abund(c), kippenhahn, L-Teff vs time'
        print '-----------------------------------------------'
        HRD_plot()
        Abund('c')
        MyDriver.Link_ModelCurve = False
        Kippen(MyDriver.SelectedModels[0],shift=shift)
        set_colourFlag('Blue')
        Plot('Teff')
        ymin = plt.axis()[2]
        ymax = plt.axis()[3]
        keep_plot(True)
        set_colourFlag('Red')
        Plot('L')
        if 'legend' in args:
            put_legend(3)
        change_label('y','$\log(T_\mathrm{eff},\,L)$')
        keep_plot(False)
        set_colourFlag('Black')
        print '-----------------------------------------------'
        print 'DHR2: Vsurf, OOc, Mdot, Oc/Os'
        print '-----------------------------------------------'
        Plot('Vsurf')
        Plot('OOc')
        Plot('Mdot')
        logVar('y')
        plotRatio('Omega_surf','Omega_cen')
        change_label('y','$\log(\Omega_\mathrm{surf}/\Omega_\mathrm{cen})$')
        no_logVar('y')
        print '-----------------------------------------------'
        print 'DHR3: Abund(s), N/O, N/H, N/C'
        print '-----------------------------------------------'
        Abund('s')
        MyDriver.Link_ModelCurve = False
        Plot('NO')
        Plot('NH')
        Plot('NC')
        print '-----------------------------------------------'
        print 'DHR4: T_c vs rho_c, T_c-rho_c vs time'
        print '-----------------------------------------------'
        multiPlot(2)
        set_fontSize(18)
        if 'legend' in args:
            rhoT('legend')
        else:
            rhoT()
        set_colourFlag('Blue')
        Plot('Tc')
        ymin = plt.axis()[2]
        ymax = plt.axis()[3]
        keep_plot(True)
        set_colourFlag('Red')
        Plot('rhoc')
        if 'legend' in args:
            put_legend(6,fontsize=MyDriver.fontSize/1.5)
        change_label('y',r'$\log(T_\mathrm{c},\,\rho_\mathrm{c})$')
        keep_plot(False)
        MyDriver.Xvar = save_Xvar
        no_logVar("x")

    elif MyDriver.modeplot == 'struc':
        save_Xvar = MyDriver.Xvar
        current_Xvar=save_Xvar
        if ixaxis == 0:
          Xvariable = 'Mr/Mtot'
          current_Xvar = 'Mfrac'
        elif ixaxis == 1:
          Xvariable = 'Mr [Mo]'
          current_Xvar = 'Mr'
        elif ixaxis == 2:
          Xvariable = 'radius [cm]'
          current_Xvar = 'r_cm'
          logVar("x")
        elif ixaxis == 3:
          Xvariable = 'shell number'
          current_Xvar = 'shell'
        MyDriver.Xvar=current_Xvar

        norot = np.all(np.array([i for j in MyDriver.SelectedModels for i in MyDriver.Model_list[j].Variables['Omega'][0]])==0.)

        subplotSep_save = MyDriver.subplotSep
        pointSize_save = MyDriver.pointSize
        print 'Structure plots, x-axis is '+Xvariable
        print '-----------------------------------------------'
        print 'STR1: Abund(p)'
        print '-----------------------------------------------'
        logVar('y')
        Abund('p')
        no_logVar('y')
        MyDriver.Link_ModelCurve = False
        print '-----------------------------------------------'
        print 'STR2: T, r, P, rho'
        print '-----------------------------------------------'
        logVar('y')
        set_colourFlag('Blue')
        Plot('T')
        keep_plot(True)
        set_colourFlag('Green')
        Plot('r')
        set_colourFlag('Red')
        Plot('P')
        set_colourFlag('Cyan')
        Plot('rho')
        no_logVar('y')
        if 'legend' in args:
            put_legend(loc=1,fontsize=MyDriver.fontSize/1.5)
        change_label('y',r'$\log(T,\,r,\,P,\,\rho)$')
        keep_plot(False)
        print '-----------------------------------------------'
        print 'STR3: L+eps, T vs rho, eps_reac+epsgrav, nablas+kappa'
        print '-----------------------------------------------'
        multiPlot(4)
        MyDriver.subplotSep = 0.3
        set_fontSize(12)
        set_colourFlag('Orange')
        Plot('L')
        handles,labels = MyDriver.Previous_Axe.get_legend_handles_labels()
        plot2var(mode='double')
        logVar('y')
        Limits(ymin=0.)
        set_colourFlag('Black')
        Plot('epsH')
        plot2var(mode='same')
        set_colourFlag('Grey')
        Plot('epsHe')
        set_colourFlag('Red')
        Plot('epsC')
        set_colourFlag('Green')
        Plot('epsnu')
        myXlim = MyDriver.Previous_Axe.axis()[:2]
        handles2,labels2 = MyDriver.Previous_Axe.get_legend_handles_labels()
        handles = handles + handles2
        labels = labels + labels2
        if 'legend' in args:
            put_legend(loc=4,fontsize=MyDriver.fontSize,handle=handles,label=labels)
        MyDriver.Previous_Axe.yaxis.set_label_coords(1.05, 0.5)
        change_label('y',r'$\log(\epsilon)$')
        noLimits()
        no_logVar('y')
        plot1var()
        set_colourFlag('Blue')
        if 'legend' in args:
            rhoT('legend')
        else:
            rhoT()
        if 'legend' in args:
            constant_entropy('legend')
        else:
            constant_entropy()
        logVar('y')
        Limits(ymin=-4.)
        Plot('eps_reac',plotif=['eps_reac','>=0.'])
        keep_plot(True)
        for i in MyDriver.SelectedModels:
            Set_Var(-Get_Var('eps_reac',i),'eps_reac_neg',i,label=r'$-(\epsilon_\mathrm{nucl}+\epsilon_\nu)\,[\mathrm{erg\,g}^{-1}\mathrm{s}^{-1}]$')
            Set_Var(-Get_Var('epsgrav',i),'epsgrav_neg',i,label='-'+MyDriver.Model_list[i].Variables['epsgrav'][1])
        set_colourFlag('Orange')
        Plot('eps_reac_neg',plotif=['eps_reac_neg','>0.'])
        set_colourFlag('Green')
        Plot('epsgrav',plotif=['epsgrav','>=0.'])
        set_colourFlag('Red')

        Plot('epsgrav_neg',plotif=['epsgrav_neg','>0.'])
        if 'legend' in args:
            put_legend(loc=3,fontsize=MyDriver.fontSize)
        change_label('y',r'$\log(\epsilon_\mathrm{reac},\,\epsilon_\mathrm{grav})$')
        for i in MyDriver.SelectedModels:
            Del_Var('eps_reac_neg',i,True)
            Del_Var('epsgrav_neg',i,True)
        no_logVar('y')
        keep_plot(False)
        noLimits()
        Limits(ymin=-10.,ymax=10.)
        Nablas()
        handles,labels = MyDriver.Previous_Axe.get_legend_handles_labels()
        MyDriver.Link_ModelCurve = False
        plot2var(mode='double')
        noLimits()
        logVar('y')
        set_colourFlag('Grey')
        Plot('kappa')
        handles2,labels2 = MyDriver.Previous_Axe.get_legend_handles_labels()
        handles = handles + handles2
        labels = labels + labels2
        if 'legend' in args:
            put_legend(loc=4,fontsize=MyDriver.fontSize,handle=handles,label=labels)
        MyDriver.subplotSep = subplotSep_save
        no_logVar('y')
        plot1var()
        print '-----------------------------------------------'
        print 'STR4: D, N2, c_s+V_MLT, magn.'
        print '-----------------------------------------------'
        MyDriver.subplotSep = 0.4
        logVar('y')
        Limits(ymin=0.)
        set_colourFlag('Blue')
        Plot('Dconv')
        keep_plot(True)
        set_colourFlag('Green')
        Plot('Dshear')
        set_colourFlag('Cyan')
        Plot('Dh')
        set_colourFlag('Red')
        Plot('Kther')
        if 'legend' in args:
            put_legend(loc=3,fontsize=MyDriver.fontSize)
        change_label('y',r'$D,\,K_\mathrm{ther}$')
        keep_plot(False)
        no_logVar('y')
        noLimits()
        set_colourFlag('Blue')
        Plot('N2')
        keep_plot(True)
        set_colourFlag('Cyan')
        Plot('NT2')
        set_colourFlag('Green')
        Plot('Nmu2')
        if norot:
            set_colourFlag('Red')
            Plot('N2mag')
        if 'legend' in args:
            put_legend(loc=4,fontsize=MyDriver.fontSize)
        change_label('y',r'$N^2$')
        keep_plot(False)
        logVar('y')
        Limits(ymin=0.)
        set_colourFlag('Blue')
        Plot('cs')
        keep_plot(True)
        set_colourFlag('Red')
        Plot('V_MLT')
        if 'legend' in args:
            put_legend(loc=3,fontsize=MyDriver.fontSize)
        change_label('y','$\log(c_\mathrm{s},\ V_\mathrm{MLT})$')
        no_logVar('y')
        noLimits()
        keep_plot(False)
        logVar('y')
        set_colourFlag('Blue')
        Plot('Bphi')
        keep_plot(True)
        set_colourFlag('Green')
        Plot('Br')
        set_colourFlag('Red')
        Plot('alfven')
        if 'legend' in args:
            put_legend(loc=3,fontsize=MyDriver.fontSize)
        change_label('y',r'$log(B_\phi,\,B_r,\,\omega_\mathrm{A})$')
        no_logVar('y')
        keep_plot(False)
        if not norot:
            print '-----------------------------------------------'
            print 'STR5: Omega, Omega/Omega_c, V_eq, j, U+V.'
            print '-----------------------------------------------'
            logVar('y')
            set_colourFlag('Blue')
            Plot('Omega')
            handles,labels = MyDriver.Previous_Axe.get_legend_handles_labels()
            plot2var(mode='double')
            no_logVar('y')
            set_colourFlag('Red')
            Plot('OOc')
            handles2,labels2 = MyDriver.Previous_Axe.get_legend_handles_labels()
            handles = handles + handles2
            labels = labels + labels2
            if 'legend' in args:
                put_legend(loc=3,fontsize=MyDriver.fontSize,handle=handles,label=labels)
            plot1var()
            set_colourFlag('Blue')
            Plot('Veq')
            if 'legend' in args:
                j_profiles('legend')
            else:
                j_profiles()
            MyDriver.Link_ModelCurve = False
            set_colourFlag('Blue')
            Plot('Ur')
            keep_plot(True)
            set_colourFlag('Red')
            Plot('Vr')
            if 'legend' in args:
                put_legend(loc=3,fontsize=MyDriver.fontSize)
            change_label('y','$U,\,V$')
            keep_plot(False)
        MyDriver.subplotSep = subplotSep_save
        MyDriver.Xvar = save_Xvar
        no_logVar("x")
    else:
        print'this command needs the following modes: "evol", or "struc". Please change the actual mode using switch().'
    MyDriver.Link_ModelCurve = True
    MyDriver.closeFig = True
    multiPlot(1)
    set_fontSize(fontSize_save)
    set_lineStyle(linestyle_save)
    set_colourFlag(colourflag_save)

def Coeff():
    """Plots the diffusion coefficients Dconv, Dshear, Dh, and Deff, as well as Kther."""
    if MyDriver.modeplot != 'struc':
        print 'This plot is available only in struc mode'
        return

    LineFlag_save = MyDriver.lineFlag
    ColourFlag_save = MyDriver.colourFlag
    MyDriver.Link_ModelCurve = False
    MyDriver.axisLabel[0] = True

    if not MyDriver.axisFlag[2]:
        myYmin = -5.
    else:
        myYmin = MyDriver.axisLimits[2]
    Limits(ymin=myYmin)
    logVar('y')
    set_lineStyle('cycle_all')
    MyDriver.axisLabel[1] = 'Diffusion coeff.'
    set_colourFlag('b')
    Plot('Dconv')
    keep_plot(True)
    set_colourFlag('g')
    Plot('Dshear')
    set_colourFlag('c')
    Plot('Dh')
    set_colourFlag('m')
    Plot('Deff')
    set_colourFlag('k')
    Plot('Kther')
    print '\n Dconv:\t\t blue\n Dshear:\t green\n Dh:\t\t cyan\n Deff:\t\t magenta\n Kther:\t\t black'

    no_logVar('y')
    keep_plot(False)
    set_colourFlag(ColourFlag_save)
    MyDriver.lineFlag = LineFlag_save
    MyDriver.axisLabel[0] = False
    MyDriver.Link_ModelCurve = True
    noLimits()

def degenerate_line(*args):
    """Plots the limit between perfect gas and degenerate gas (NR limit).
       Included by default in the rhoT() plot.
       If 'legend' is passed as an argument, it draws the legend of the lines."""
    rhoDNR = np.arange(-7,9.,0.1)
    TDNR = (2./3.)*rhoDNR+np.log10(1.207e5*1.8/(2.**(5./3.)))
    plt.plot(rhoDNR,TDNR,'-.',color='0.6',label=r'$P_{\mathrm{ion}}=P_{\mathrm{el. deg.}}\ (T\sim \rho^{2/3})$')
    if 'legend' in args:
        put_legend(loc=2,fontsize=MyDriver.fontSize)

def constant_entropy(*args):
    """Adds constant radiation entropy lines (S_gamma/R_gaz=0.1,1.,10.) in a T-rho plot.
       If 'legend' is passed as an argument, it draws the legend of the lines."""
    rho_Sg = np.arange(-7,7.,0.1)
# Arnett: Supernovae & Nucleosynthesis, Eq. (7.66), Fig. 7.5
    T_Sg01 = (1./3.)*(np.log10(3.*0.1/4.)+rho_Sg-np.log10(Cst.a)+np.log10(Cst.R_gaz))
    T_Sg1 = (1./3.)*(np.log10(3./4.)+rho_Sg-np.log10(Cst.a)+np.log10(Cst.R_gaz))
    T_Sg10 = (1./3.)*(np.log10(3.*10./4.)+rho_Sg-np.log10(Cst.a)+np.log10(Cst.R_gaz))
    plt.plot(rho_Sg,T_Sg01,'--',color='0.6',label=r'$S_\gamma/N_Ak\ (T\sim\rho^{1/3})=0.1$')
    plt.plot(rho_Sg,T_Sg1,'-',color='0.6',label=r'$S_\gamma/N_Ak\ (T\sim\rho^{1/3})=1$')
    plt.plot(rho_Sg,T_Sg10,'--',color='0.6',label=r'$S_\gamma/N_Ak\ (T\sim\rho^{1/3})=10$')
    if 'legend' in args:
        put_legend(loc=2,fontsize=MyDriver.fontSize/1.5)

def isoRadius(colour='0.80',line=':',fontsize=0):
    """Plots iso-radius lines in a HRD"""
    if fontsize==0:
        fontsize=MyDriver.fontSize
    teff_min,teff_max,lum_min,lum_max = get_limits()
    teff_range=np.arange(teff_min,teff_max,0.1)
    teff_range=np.hstack((teff_range,teff_max))
    for i in [0.01,0.1,1.,10.,100.,1000.,10000.]:
        L_range = 4.*math.pi*Cst.sigma* 10.**(4.*teff_range) *(i*Cst.Rsol)**2.
        L_range = np.log10(L_range/Cst.Lsol)
        plt.plot(teff_range,L_range,color=colour,ls=line)
        if L_range[-1] < lum_max:
            lpos = L_range[-1]
            tpos = teff_max
            add_label(tpos,lpos,str(i)+'$\,R_\odot$',fontsize=fontsize)
        else:
            lpos = lum_max
            ind = np.where(L_range<lum_max)[0]
            print ind
            if len(ind)>0:
                tpos = teff_range[ind[-1]]
                add_label(tpos,lpos,str(i)+'$\,R_\odot$',fontsize=fontsize)

def Cepheid_strip(Zzone=''):
    """Plots the limits of the instability strip in the HRD. The limits are those given by Tammann+ 2003,
       except at Zsol where we have the borders determined consistently on our models by H. Saio.
       Included by default in the HRD_tot() plot."""
    StripDef = {'MW':[[-4.595e-2,3.940],[-5.989e-2,3.921]],'LMC':[-0.059,3.960],'SMC':[-0.059,3.953]}
    deltaStrip = 0.04
    CephL_mid = np.array([2.,5.])
    Zzone_star = ''
    mCeph = False
    test_multiZ = False
    if not Zzone:
        for star in MyDriver.SelectedModels:
            MyStar = MyDriver.Model_list[star]
            if MyDriver.modeplot == 'evol':
                if MyStar.Variables['Mini'][0] >= 2. and MyStar.Variables['Mini'][0] <= 18.:
                    mCeph = True
            elif MyDriver.modeplot == 'cluster':
                mCeph = True
            if MyDriver.modeplot == 'evol':
                if MyStar.Variables['Zsurf'][0][0] <= 0.004:
                    Zzone_star = 'SMC'
                elif MyStar.Variables['Zsurf'][0][0] <= 0.010:
                    Zzone_star = 'LMC'
                else:
                    Zzone_star = 'MW'
            elif MyDriver.modeplot == 'cluster':
                if MyStar.Variables['Zini'][0][0] <= 0.004:
                    Zzone_star = 'SMC'
                elif MyStar.Variables['Zini'][0][0] <= 0.010:
                    Zzone_star = 'LMC'
                else:
                    Zzone_star = 'MW'
            if Zzone != '' and Zzone_star != Zzone:
                test_multiZ = True
            Zzone = Zzone_star
    else:
        mCeph = True
    if mCeph and not test_multiZ:
        if Zzone == 'MW':
            CephT_blue = StripDef[Zzone][0][0]*CephL_mid + StripDef[Zzone][0][1]
            CephT_red = StripDef[Zzone][1][0]*CephL_mid[::-1] + StripDef[Zzone][1][1]
        else:
            CephT_blue = StripDef[Zzone][0]*CephL_mid + StripDef[Zzone][1] + deltaStrip
            CephT_red = StripDef[Zzone][0]*CephL_mid[::-1] + StripDef[Zzone][1] - deltaStrip
        CephT = np.concatenate((CephT_blue,CephT_red))
        CephL = np.concatenate((CephL_mid,CephL_mid[::-1]))
        shade(CephT,CephL)
    else:
        if not mCeph:
            print 'Cepheid strip not drawn, masses out of range.'
        if test_multiZ:
            print 'Cepheid strip not drawn, more than one metallicity detected.'

def mark_phase(fuel='',marker=['o','x'],colour='k',quiet=False):
    """Marks the beginning and end of a given burning phase in the current plot.
       The x and y variables have to be entered (Teff and L by default).
       The default markers are ['o','x'], but they can be modified by the optional argument marker=['',''].
       Other optional parameters are:
        - marker=['',''] to modify the default markers (['o','x']);
        - colour='', to modify the default colour (black)."""
    if MyDriver.modeplot != 'evol':
        print 'Possible only in evol mode.'
        return
    burn_seq = np.array(['H','He','C','Ne','O','Si'])
    if fuel not in burn_seq:
        print 'Unknown burning phase, please check your input.'
        return
    failed = []
    ind_beg_all = []
    ind_end_all = []
    xpos_beg_all = []
    ypos_beg_all = []
    xpos_end_all = []
    ypos_end_all = []
    for i in MyDriver.SelectedModels_evol:
        currentModel = MyDriver.Model_list[i]
        try:
            ind_beg = np.where(currentModel.Variables['phase'][0] == fuel)[0][0]
            ind_end = np.where(currentModel.Variables['phase'][0] == fuel)[0][-1]
            xpos_beg = currentModel.Variables[MyDriver.lastXvar][0][ind_beg]
            ypos_beg = currentModel.Variables[MyDriver.lastYvar][0][ind_beg]
            xpos_end = currentModel.Variables[MyDriver.lastXvar][0][ind_end]
            ypos_end = currentModel.Variables[MyDriver.lastYvar][0][ind_end]
            if marker[0] in ['.',',','+','x','|','_']:
                plt.scatter(xpos_beg,ypos_beg,marker=marker[0],c=colour)
            else:
                plt.scatter(xpos_beg,ypos_beg,marker=marker[0],facecolors='none',edgecolors=colour)
            if marker[1] in ['.',',','+','x','|','_']:
                plt.scatter(xpos_end,ypos_end,marker=marker[1],c=colour)
            else:
                plt.scatter(xpos_end,ypos_end,marker=marker[1],facecolors='none',edgecolors=colour)
            ind_beg_all = ind_beg_all + [ind_beg]
            ind_end_all = ind_end_all + [ind_end]
            xpos_beg_all = xpos_beg_all + [xpos_beg]
            ypos_beg_all = ypos_beg_all + [ypos_beg]
            xpos_end_all = xpos_end_all + [xpos_end]
            ypos_end_all = ypos_end_all + [ypos_end]
        except:
            failed = failed + [i]
    if not quiet:
        print '-----\n'+fuel+'-b beginning and end marked by',marker[0],'and',marker[1]
        if failed != []:
            print 'Star(s)',failed,'do(es) not have a phase of',fuel,'burning.'
    #return ind_beg_all,ind_end_all,xpos_beg_all,ypos_beg_all,xpos_end_all,ypos_end_all

def PISN_zone():
    """Plots the limits of the zone where pair-creation instability should occur in the Tc-rhoc
       plan. Data from Chatzopoulos et al. ApJ 799 1 (2015), extracted woth Dexter."""
    rho_data = np.array([  692.9,  835.6,  984.5,  1168.,  1366.,  1584.,  1838.,  2251.,  2632. , 3077., \
                           3596.,  4337.,  5070.,  6068.,  7148.,  8356. ,10230., 11870., 14650., 17260., \
                          20660., 23590., 27370., 31990., 36530., 42700. ,49150., 56120., 64590., 74910., \
                          86890.,100700.,115900.,140900.,164700.,191100.,221600.,259100.,291300.,324900., \
                         365300.,410700.,447500.,487600.,535500.,574500.,602000.,621100.,650900.,650900., \
                         640800.,626000.,606800.,579000.,543900.,483800.,430400.,376900.,300500.,203400., \
                         139800., 90350., 67160., 48760. ,37690., 29590., 21150. ,14540., 10310.,  7038., \
                           4838.,  3405.,  1956.,  1273.,  903.5,  698.3])
    T_data = np.array([6.803e8,6.949e8,7.123e8,7.249e8,7.378e8,7.509e8,7.589e8,7.751e8,7.917e8,8.115e8,8.259e8, \
                       8.436e8,8.586e8,8.801e8,9.053e8,9.247e8,9.478e8,9.715e8,9.993e8,1.031e9,1.053e9,1.076e9, \
                       1.103e9,1.134e9,1.163e9,1.200e9,1.226e9,1.257e9,1.293e9,1.325e9,1.368e9,1.412e9,1.463e9, \
                       1.521e9,1.587e9,1.650e9,1.703e9,1.764e9,1.834e9,1.907e9,1.983e9,2.061e9,2.128e9,2.197e9, \
                       2.276e9,2.349e9,2.425e9,2.495e9,2.576e9,2.650e9,2.716e9,2.795e9,2.855e9,2.926e9,2.979e9, \
                       3.043e9,3.097e9,3.153e9,3.187e9,3.222e9,3.257e9,3.257e9,3.258e9,3.270e9,3.282e9,3.294e9, \
                       3.295e9,3.295e9,3.296e9,3.297e9,3.297e9,3.298e9,3.287e9,3.288e9,3.288e9,3.289e9])
    log_rho_data = np.log10(rho_data)
    log_T_data = np.log10(T_data)
    shade(log_rho_data,log_T_data)

def get_lifetimes(num_star=0):
    """Prints the lifetimes of the different stages."""
    if MyDriver.modeplot != 'evol':
        print 'The lifetimes display is possible only in evol mode. Please change with switch("evol").'
        return
    if num_star == 0:
        if len(MyDriver.Model_list_evol) > 1:
            answer = raw_input('Enter the id number of the star you want to display:\n')
            num_star = int(answer)
        else:
            num_star = MyDriver.Model_list_evol.keys()[0]
    print '---------------------------------------------------------------------'
    print 'LIFETIMES FOR MODEL ' + MyDriver.Model_list_evol[num_star].Variables['FileName'][0]
    print '---------------------------------------------------------------------'
    print 'H-b:  ' + '{0:,}'.format(MyDriver.Model_list_evol[num_star].Variables['tau'][0][0]).replace(',',"'") + ' yr'
    print 'He-b: ' + '{0:,}'.format(MyDriver.Model_list_evol[num_star].Variables['tau'][0][1]).replace(',',"'") + ' yr'
    print 'C-b:  ' + '{0:,}'.format(MyDriver.Model_list_evol[num_star].Variables['tau'][0][2]).replace(',',"'") + ' yr'
    print 'Ne-b: ' + '{0:,}'.format(MyDriver.Model_list_evol[num_star].Variables['tau'][0][3]).replace(',',"'") + ' yr'
    print 'O-b:  ' + '{0:,}'.format(MyDriver.Model_list_evol[num_star].Variables['tau'][0][4]).replace(',',"'") + ' yr'
    print '---------------------------------------------------------------------'

def convZones(num_star,colour='0.80'):
    """Shades the convective zones in a structure plot."""
    if MyDriver.modeplot != 'struc':
        print 'The drawing of convective zones is possible only in structure mode. Please change with switch().'
        return
    selected_models_save = list(MyDriver.SelectedModels)
    select_model(num_star)
    ymin = MyDriver.Previous_Axe.axis()[2]
    ymax = MyDriver.Previous_Axe.axis()[3]
    ZCy = [ymin,ymax,ymax,ymin]
    currentX = MyDriver.Xvar
    currentModel = MyDriver.Model_list[num_star]
    for i in range(len(currentModel.ConvectiveZones)):
        Edge1X = currentModel.Variables[currentX][0][currentModel.ConvectiveZones[i][0]]
        Edge2X = currentModel.Variables[currentX][0][currentModel.ConvectiveZones[i][1]]
        ZCx = [Edge1X,Edge1X,Edge2X,Edge2X]
        shade(ZCx,ZCy,colour=colour)
    MyDriver.SelectedModels = list(selected_models_save)

def colours_calc(num_star=0):
    """Computes the colours and magnitudes of models in evol mode."""
    if MyDriver.modeplot != 'evol':
        print 'This command is valid only in evol mode'
        return
    if num_star == 0:
        num_star = MyDriver.Model_list_evol.keys()
    for i in flatten([num_star]):
        if 'M_K' not in MyDriver.Model_list[i].Variables.keys():
            MyDriver.Model_list[i].ColoursCalc()
        else:
            print 'colours already exist for model',i

def colour_corr(excess,dist_mod,num_star=0):
    """Corrects the M_V and B-V for a distance modulus and a colour excess.
       Usage: colour_corr(excess,dist_mod,num_star)
              Note that num_star might be a list of models."""
    if MyDriver.modeplot != 'cluster':
        print 'This command is valid only in cluster mode'
        return
    if num_star == 0:
        num_star = MyDriver.Model_list_cluster.keys()
    [MyDriver.Model_list[i].Colour_correction(excess,dist_mod) for i in flatten([num_star]) if i in MyDriver.Model_list_cluster.keys()]
    if len([i for i in flatten([num_star]) if i not in MyDriver.Model_list_cluster.keys()]) !=0:
        print 'Model(s) ',[i for i in flatten([num_star]) if i not in MyDriver.Model_list_cluster.keys()],' do(es) not exist in cluster list.'

def add_noise(var,value,type='',num_star=0):
    """Adds a noise to a variable (cluster mode only).
       Usage: add_noise(var,value,num_star)."""
    if MyDriver.modeplot != 'cluster':
        print 'This command is valid only in cluster mode'
        return
    if num_star == 0:
        num_star = MyDriver.Model_list_cluster.keys()
    for i in flatten([num_star]):
        if i in MyDriver.Model_list_cluster.keys():
            try:
                try:
                    Del_Var(var+'_noised',i,quiet=True)
                except:
                    pass
                var_nonoise = Get_Var(var,i)
                if type == 'linlog':
                    var_nonoise = np.log10(var_nonoise)
                elif type == 'loglin':
                    var_nonoise = 10.**var_nonoise
                var_noised = var_nonoise + np.random.normal(0.,value,len(var_nonoise))
                if type == 'linlog':
                    var_noised = 10.**var_noised
                elif type == 'loglin':
                    var_noised = np.log10(var_noised)
                Set_Var(var_noised,var+'_noised',i,label=MyDriver.Model_list_cluster[i].Variables[var][1],category=MyDriver.Model_list_cluster[i].Variables[var][2])
            except KeyError:
                print 'Variable '+var+' not known in model '+str(i)+': skipped...'
    if len([i for i in flatten([num_star]) if i not in MyDriver.Model_list_cluster.keys()]) !=0:
        print 'Model(s) ',[i for i in flatten([num_star]) if i not in MyDriver.Model_list_cluster.keys()],' do(es) not exist in cluster list.'


def put_legend(loc=1,label=[],fontsize=''):
    """Draws a frame with the curves legend
          at the location given by loc (default loc=1)
             1: top right
             2: top left
             3: bottom left
             4: bottom right
             5: middle right
             6: middle left
             7: middle right again
             8: bottom centre
             9: top centre
             10: middle centre
          with the fontsize given by fontsize (default fontsize=MyDriver.fontSize/1.5).
       The optional parameter label=['...','...'] allows to customize the curve's label.
       Usage: put_legend(1[,label=['line 1','line 2'],fontsize=18])"""
    handles,labels = MyDriver.Previous_Axe.get_legend_handles_labels()
    if label != []:
        labels = label
    if fontsize == '':
        fontsize = MyDriver.fontSize/1.5
    plt.legend(handles,labels,loc=loc,fontsize=fontsize)

def BuildMask(var,cond,i):
    """Needed by Plot() to limit the plotting to conditions."""
    if not isinstance(var,list):
        var = [var]
        cond = [cond]
    Mask = (np.zeros(len(MyDriver.Model_list[i].Variables[var[0]][0])) == 0.)
    for myVar,myCond in zip(var,cond):
        cond_var = MyDriver.Model_list[i].Variables[myVar][0]
        myMask = eval('cond_var'+myCond)
        Mask = np.logical_and(Mask,myMask)
    return Mask

def Build_timestep(x,y,timestep,z=[]):
    """Builds the vectors used to print timesteps on a curve."""
    myX = [ x[i[0]]+i[1]*(x[i[0]+1]-x[i[0]]) for i in timestep ]
    myY = [ y[i[0]]+i[1]*(y[i[0]+1]-y[i[0]]) for i in timestep ]
    myZ = []
    if z!=[]:
        myZ = [ z[i[0]]+i[1]*(z[i[0]+1]-z[i[0]]) for i in timestep ]
    return myX,myY,myZ

def set_deltat(deltat,num_list=[]):
    """Allows to change the default timestep computed while reading the file (1.e6)."""
    if MyDriver.modeplot !='evol':
        print 'Timesteps plotting only available in evol mode'
        return
    if num_list == []:
        num_list = MyDriver.SelectedModels
    local_num_list = [i for i in flatten([num_list]) if i in MyDriver.Model_list.keys()]
    print 'Timesteps computed for star(s) ',local_num_list
    if len([i for i in flatten([num_list]) if i not in MyDriver.Model_list.keys()]) !=0:
        print 'Model(s) ',[i for i in flatten([num_list]) if i not in MyDriver.Model_list.keys()],' is (are) not loaded.'
    for num_star in flatten(local_num_list):
        print 'Timesteps of ',deltat,' years computing for star ',num_star
        if deltat == MyDriver.Model_list[num_star].deltat:
            print 'Model ',num_star,' is already set with the wanted time step.'
            pass
        current_time = MyDriver.Model_list[num_star].Variables['t'][0][0]
        MyDriver.Model_list[num_star].timestep = []
        MyDriver.Model_list[num_star].deltat = deltat
        i=0
        while current_time <= MyDriver.Model_list[num_star].Variables['t'][0][-1]:
            if MyDriver.Model_list[num_star].Variables['t'][0][i] > current_time:
                current_index = i-1
                current_factor = (current_time-MyDriver.Model_list[num_star].Variables['t'][0][current_index])/(MyDriver.Model_list[num_star].Variables['t'][0][i]-MyDriver.Model_list[num_star].Variables['t'][0][current_index])
                MyDriver.Model_list[num_star].timestep.append([current_index,current_factor])
                current_time = current_time+deltat
            if current_time >= MyDriver.Model_list[num_star].Variables['t'][0][i]:
                i+=1

def timesteps(value):
    """Switch on or off for the drawing of the timesteps (default=False)."""
    if not isinstance(value,bool):
        print 'Boolean value expected'
        return
    MyDriver.steps = value

def DefNewLimits(CurrentLimits):
    """Needed by Plot."""
    Xmin = CurrentLimits[0]
    Xmax = CurrentLimits[1]
    Ymin = CurrentLimits[2]
    Ymax = CurrentLimits[3]

    Xmin_save = Xmin
    Xmax_save = Xmax
    Ymin_save = Ymin
    Ymax_save = Ymax
    dX = (Xmax-Xmin)/20.
    dY = (Ymax-Ymin)/20.
    if not MyDriver.axisFlag[0]:
        Xmin = Xmin-dX
    if not MyDriver.axisFlag[1]:
        Xmax = Xmax+dX
    if not MyDriver.axisFlag[2]:
        Ymin = Ymin-dY
    if not MyDriver.axisFlag[3]:
        Ymax = Ymax+dY

    if (MyDriver.axisInv[0] and Xmax > Xmin) or Xmax < Xmin:
        Temp = Xmax
        Xmax = Xmin
        Xmin = Temp
    if (MyDriver.axisInv[1] and Ymax > Ymin) or Ymax < Ymin:
        Temp = Ymax
        Ymax = Ymin
        Ymin = Temp

    return Xmin,Xmax,Ymin,Ymax,Xmin_save,Xmax_save,Ymin_save,Ymax_save

def get_limits(quiet=False):
    """Returns the limits of the actual figure."""
    actualLimits = []
    xmin = plt.gca().get_xbound()[0]
    xmax = plt.gca().get_xbound()[1]
    ymin = plt.gca().get_ybound()[0]
    ymax = plt.gca().get_ybound()[1]
    actualLimits = [xmin,xmax,ymin,ymax]
    if not quiet:
        print 'To use these limits:\n Limits(xmin='+str(xmin)+',xmax='+str(xmax)+',ymin='+str(ymin)+',ymax='+str(ymax)+')'
    return actualLimits

def Limits(**args):
    """Defines axis limits manually.
       Usage: Limits(xmin=2.,xmax=4.5,ymin=0.,ymax=1.)
       All arguments are optional."""
    for arg in args.keys():
        if arg.lower() == 'xmin':
            MyDriver.axisFlag[0] = True
            MyDriver.axisLimits[0] = args[arg]
        elif arg.lower() == 'xmax':
            MyDriver.axisFlag[1] = True
            MyDriver.axisLimits[1] = args[arg]
        elif arg.lower() == 'ymin':
            MyDriver.axisFlag[2] = True
            MyDriver.axisLimits[2] = args[arg]
        elif arg.lower() == 'ymax':
            MyDriver.axisFlag[3] = True
            MyDriver.axisLimits[3] = args[arg]
        else:
            print('Bad argument for function Limits. Should be xmin=..., xmax=... ,ymin=... ,or ymax=... .')

def noLimits(*args):
    """Returns to automatically defined axis limits.
       Usage: noLimits("axis") with axis = 'x', 'y', 'xy'."""
    authorised = ['x','y','xy','yx']
    if not args:
        MyDriver.axisFlag = [False,False,False,False]
    else:
        for arg in args:
            if 'x' in arg.lower():
                MyDriver.axisFlag[0] = False
                MyDriver.axisFlag[1] = False
            if 'y' in arg.lower():
                MyDriver.axisFlag[2] = False
                MyDriver.axisFlag[3] = False
            if arg not in authorised:
                print('Bad argument for function noLimits. Should be "x", "y", or "xy".')

def keep_limits(choice=None):
    """Fixes the limits to the actual ones if set to True."""
    if choice == True or choice == None:
        [xmin,xmax,ymin,ymax] = get_limits()
        Limits(xmin=xmin,xmax=xmax,ymin=ymin,ymax=ymax)
    elif choice == False:
        noLimits()
    else:
        print('Wrong value: should be True or False.')

def Points(NewValue):
    """Switches from plotting with line to plotting with points if set at True"""
    if NewValue in [True,False]:
        MyDriver.iPoints = NewValue
    else:
        print('Wrong value: should be True or False.')

def emptyPoints(choice):
    """Switches from plotting with line to plotting with points if set at True"""
    if choice in [True,False]:
        MyDriver.emptyPoint = choice
    else:
        print('Wrong value: should be True or False.')

def set_lineStyle(NewValue,width=1):
    """Sets the line style for plotting.
       The allowed values are the following: 'cycle_all', 'cycle_colour', '-', '--', ':', '-.' """
    MyDriver.lineWidth = width
    if NewValue in Rendering.Authorised_LineStyle:
        MyDriver.lineFlag = NewValue
    else:
        print 'The value you entered is not correct, please choose one of the following: ',Rendering.Authorised_LineStyle

def setLine_style(NewValue,width=1):
    """Retrocompatibility command"""
    set_lineStyle(NewValue,width=1)

def set_pointStyle(NewValue):
    """Sets the point style for plotting.
       The allowed values are the following:
            'cycle_all', 'cycle_colour', 'o', '^', '*', 's', 'p', 'v', 'd', '>', '<' """
    if NewValue in Rendering.Authorised_PointStyle:
        MyDriver.pointFlag = NewValue
    elif isinstance(NewValue,tuple):
        if isinstance(NewValue[0],int) and isinstance(NewValue[1],int):
            MyDriver.pointFlag = NewValue
        elif isinstance(NewValue[0],int) and isinstance(NewValue[1],int) and isinstance(NewValue[2],int):
            MyDriver.pointFlag = NewValue
    else:
        print 'The value you entered is not correct, please choose one of the following:',\
               Rendering.Authorised_PointStyle,'\nor a tuple (numsides,style,angle)'

def setPoint_style(NewValue):
    """Retrocompatibility command"""
    set_pointStyle(NewValue)

def set_pointSize(NewValue=0,f=1.):
    """Sets the point size for plotting.
       If a simple value is entered, it defines the point size.
       If f=x is entered, the actual size is multiplied by x."""
    if NewValue != 0:
        if isinstance(NewValue,str):
            if NewValue == 'default':
                MyDriver.pointSize = 24
            else:
                print 'The argument should be "default" or an integer for the sze in points.'
        elif isinstance(NewValue,int) or isinstance(NewValue,float):
            MyDriver.pointSize = NewValue
    else:
        MyDriver.pointSize = f*MyDriver.pointSize

def setPoint_size(NewValue=0,f=1.):
    """Retrocompatibility command"""
    set_pointSize(NewValue=0,f=1.)

def set_PSminmax(min=0,max=0):
    """Sets the min and max size of points when the size is defined by a variable.
       Used in plotExternal(). Back to default values with set_PSminmax('default')."""
    if min != 0:
        if isinstance(min,str):
            if min == 'default':
                MyDriver.PSmin = 5
                MyDriver.PSmax = 200
                print 'min and max point size set to default values (5,200)'
        if isinstance(min,int) or isinstance(min,float):
            MyDriver.PSmin = min
    if max != 0:
        MyDriver.PSmax = max

def timestep_marker(NewValue):
    """Sets the point style for overplotting the timesteps.
       The allowed values are the following:
          'o', '^', 's', 'p', 'v', 'd', '>', '<' """
    if NewValue in ['o','^','s','p','v','d','>','<']:
        MyDriver.timestep_marker = NewValue
    else:
        print 'The value you entered is not correct, please choose one of the following: o,^,s,p,v,d,>,<'

def set_colourSequence(NewValue):
    """Sets the colour sequence when plotting more than one model.
       The allowed values are the following: 'c' for contrast, 'i' for iris,
       'p' to create a new sequence (following instructions), or any existing sequence name."""
    if NewValue == 'c':
        MyDriver.colourSequence = 'contrast'
    elif NewValue == 'i':
        MyDriver.colourSequence = 'iris'
    elif NewValue == 'p':
        print 'Personnalised colour sequence'
        cseq_key = raw_input('Enter new sequence name: ')
        cseq_list = raw_input('Enter new list (format: [[colours],[names]]): ')
        Rendering.Colours_list[cseq_key] = eval(cseq_list)
        MyDriver.colourSequence = cseq_key
    else:
        if NewValue not in Rendering.Colours_list.keys():
            print 'The value you entered is not correct. Existing sequences are:'
            for i in Rendering.Colours_list.keys():
                print i+': '+ str(Rendering.Colours_list[i][1])
        else:
            MyDriver.colourSequence = NewValue

def set_colourMap(NewValue):
    """Sets the colour map for plots with Plot_colour.
       Matplotlib available colour maps are presented at
          http://www.physics.ox.ac.uk/Users/msshin/science/code/matplotlib_cm/"""
    MyDriver.colourMap = NewValue

def set_colourFlag(NewValue):
    """Sets the colour for the plot.
       The value entered can be a string for the colour name,
           or a float for shades of grey
           or a triplet for RGB definition."""
    if isinstance(NewValue,str):
        if NewValue.lower() in Rendering.Authorised_Colours:
            MyDriver.colourFlag = NewValue
        else:
            print 'The name you entered does not exist. Check and try again'
    elif isinstance(NewValue,tuple):
        if isinstance(NewValue[0],float) and isinstance(NewValue[1],float) and isinstance(NewValue[2],float):
            MyDriver.colourFlag = NewValue
    elif isinstance(NewValue,float):
        MyDriver.colourFlag = (NewValue,NewValue,NewValue)
    else:
        print 'The value you entered is not correct'

def CBLimits(**args):
    """Defines the limits for the colourbar manually.
       Usage: CBLimits(min=2.,max=4.5)
       All arguments are optional."""
    for arg in args.keys():
        if arg == 'min':
            MyDriver.CBFlag[0] = True
            MyDriver.CBLimits[0] = args[arg]
        elif arg == 'max':
            MyDriver.CBFlag[1] = True
            MyDriver.CBLimits[1] = args[arg]
        else:
            print('Bad argument for function CBLimits. Should be min=..., or max=... .')

def noCBLimits(*args):
    """Returns to automatically defined limits for the colourbar.
       Usage: noCBLimits("value") with value = 'min', 'max', or none for both."""
    if not args:
        MyDriver.CBFlag = [False,False]
    else:
        for arg in args:
            if arg == 'min':
                MyDriver.CBFlag[0] = False
            if arg == 'max':
                MyDriver.CBFlag[1] = False

def keep_CBlimits(choice=None):
    """Fixes the limits of the colourbar to the actual ones"""
    if choice == True or choice == None:
        [min,max] = MyDriver.get_CBlimits
        print 'colour limits:',min,max
    elif choice == False:
        noCBLimits()
    else:
       print('Wrong value: should be True or False.')

def CB_tickN(ticks=10):
    """Resets the number of ticks in the colour bar"""
    MyDriver.CBticksN = ticks

def axis_inv(*args):
    """Inversion of axis.
       Usage: axis_inv("axis") with axis = 'x', 'y', 'xy'."""
    if not args:
        print 'You need to precise wich axis you want to invert: x, y, or both (xy)?'
    else:
        for arg in args:
            if 'x' in arg.lower():
                MyDriver.axisInv[0] = True
            if 'y' in arg.lower():
                MyDriver.axisInv[1] = True

def no_axis_inv(*args):
    """Returns to normal sense of axis.
       Usage: no_axis_inv("axis") with axis = 'x', 'y', 'xy'."""
    if not args:
        MyDriver.axisInv = [False,False]
    else:
        for arg in args:
            if 'x' in arg.lower():
                MyDriver.axisInv[0] = False
            if 'y' in arg.lower():
                MyDriver.axisInv[1] = False

def logVar(*args):
    """Plots the variable in log.
       Usage: logVar("axis") with axis = 'x', 'y', 'z', or any combination such as 'xy'."""
    if not args:
        print 'You need to precise for wich axis you want the logarithmic value: x, y, z, or anycombination (xy)?'
    else:
        for arg in args:
            if 'x' in arg.lower():
                MyDriver.ilog[0] = True
            if 'y' in arg.lower():
                MyDriver.ilog[1] = True
            if 'z' in arg.lower():
                MyDriver.ilog[2] = True

def log_Var(*args):
    """Retrocompatibility command"""
    logVar(*args)

def no_logVar(*args):
    """Returns to plotting the variable in no log value.
       Usage: no_logVar("axis") with axis = 'x', 'y', 'z', or any combination such as 'xy'."""
    if not args:
        MyDriver.ilog = [False,False,False]
    else:
        for arg in args:
            if 'x' in arg.lower():
                MyDriver.ilog[0] = False
            if 'y' in arg.lower():
                MyDriver.ilog[1] = False
            if 'z' in arg.lower():
                MyDriver.ilog[2] = False

def no_log_Var(*args):
    """Retrocompatibility command"""
    no_logVar(*args)


def logScale(*args):
    """Plots the variable on a log scale (ticks).
       Usage: logScale("axis") with axis = 'x', 'y', 'xy'."""
    if not args:
        print 'You need to precise for wich axis you want the logarithmic scale: x, y, or both (xy)?'
    else:
        for arg in args:
            if 'x' in arg.lower():
                MyDriver.logScale[0] = True
            if 'y' in arg.lower():
                MyDriver.logScale[1] = True

def no_logScale(*args):
    """Returns to plotting the variable in linear scale.
       Usage: no_logScale("axis") with axis = 'x', 'y', 'xy'."""
    if not args:
        MyDriver.logScale = [False,False]
    else:
        for arg in args:
            if 'x' in arg.lower():
                MyDriver.logScale[0] = False
            if 'y' in arg.lower():
                MyDriver.logScale[1] = False

def configPlot():
    """Used by Plot() and Kippen().
       Determines the part of the window where the actual plot will be drawn in case of multiPlot(2 or 4)."""
    if MyDriver.plotConfig[0] == 1:
        if MyDriver.plotConfig[1] in [1]:
            if MyDriver.plotConfig[1] == 1:
                NewFig = True
            else:
                NewFig = False
            mySubplot = 111
        else:
            print 'il y a une couille dans le potage'
            return True,111
    elif  MyDriver.plotConfig[0] == 2:
        if  MyDriver.plotConfig[1] in [1,2]:
            if MyDriver.plotConfig[1] == 1:
                NewFig = True
            else:
                NewFig = False
            mySubplot = 210 + MyDriver.plotConfig[1]
            if not MyDriver.keepplot:
                print 'Plot ',mySubplot
                MyDriver.plotConfig[1] = MyDriver.plotConfig[1] % 2 + 1
        else:
            print 'il y a une couille dans le potage'
            return True,111
    elif  MyDriver.plotConfig[0] == 4:
        if  MyDriver.plotConfig[1] in [1,2,3,4]:
            if MyDriver.plotConfig[1] == 1:
                NewFig = True
            else:
                NewFig = False
            mySubplot = 220 + MyDriver.plotConfig[1]
            if not MyDriver.keepplot:
                print 'Plot ',mySubplot
                MyDriver.plotConfig[1] = MyDriver.plotConfig[1] % 4 + 1
        else:
            print 'il y a une couille dans le potage'
            return True,111
    return NewFig,mySubplot

def keep_plot(value):
    """Keeps the same figure for plotting another curve."""
    if value in [False,True]:
        MyDriver.keepplot = value
    else:
        print 'Needs to be True or False.'
        return

def plot2var(mode = 'same'):
    """Allows for the superposition of several plots. Optional argument mode: "same" plots all the variables
       on the same axis. "double" plot one variable on each y-axis.
       Back to normal through the plot1var() command."""
    if mode == 'same':
        MyDriver.multiplot = False
    elif mode == 'double':
        MyDriver.multiplot = True
    else:
        print 'Mode should be "same" or "double"...'
        return

    keep_plot(True)

def plot1var():
    """Returns to the normal behaviour of plotting only one variable."""
    keep_plot(False)
    MyDriver.multiplot = False

def multiPlot(plot_num):
    """Switches to a 2-fig or 4-fig mode on one window. Usage: multiPlot(4)."""
    if plot_num in [1,2,4]:
        MyDriver.plotConfig = [plot_num,1]
    else:
        print 'Sorry, we didn\'t code for anything else than 1-, 2-, or 4-plots windows.'

def defX(varX):
    """Allows to change the default value for the x axis:
          in evolution mode: t6
          in structure mode: Mfrac."""
    MyDriver.Xvar = varX

def default_settings():
    """Restores the default settings as when initialised."""
    MyDriver.fontSize = 24
    MyDriver.ticklength = 8
    MyDriver.tickwidth = 1
    MyDriver.minorLoc = 0
    MyDriver.subplotSep = 0.2
    MyDriver.logScale = [False,False]
    MyDriver.lineFlag = 'cycle_colour'
    MyDriver.lineWidth = 1
    MyDriver.colourFlag = 'cycle'
    MyDriver.colourSequence = 'contrast'
    MyDriver.colourMap = 'gist_rainbow'
    MyDriver.pointSize = 18
    MyDriver.PSmin = 5
    MyDriver.PSmax = 200
    MyDriver.pointFlag = 'cycle_colour'
    MyDriver.emptyPoint = False
    MyDriver.axisFlag = [False,False,False,False]
    MyDriver.axisLimits = [0.,0.,0.,0.]
    MyDriver.CBFlag = [False,False]
    MyDriver.CBLimits = [0.,0.]
    MyDriver.CBticksN = 11
    MyDriver.axisInv = [False,False]
    MyDriver.ilog = [False,False,False]
    MyDriver.keepplot = False
    MyDriver.multiplot = False
    MyDriver.plotConfig = [1,1]
    MyDriver.axisLabel = [False,'']
    MyDriver.Link_ModelCurve = True
    MyDriver.Kipp_tol = 0.005
    MyDriver.steps = False
    MyDriver.deltat = 1.e6
    MyDriver.timestep_marker = 'o'

    if MyDriver.modeplot == 'evol':
        MyDriver.Xvar = 't6'
        MyDriver.iPoints = False
    elif MyDriver.modeplot == 'struc':
        MyDriver.Xvar = 'Mfrac'
        MyDriver.iPoints = False
    elif MyDriver.modeplot == 'cluster':
        MyDriver.Xvar = 'Teff'
        MyDriver.iPoints = True
    else:
        print 'Wrong mode, should be one of the following:\n\t evol\n\t struc\n\t cluster.\n'
        print 'The default x variable could not be recovered.'

def fit_poly(deg=1,y='',colour='0.80'):
    """Returns the factor of the polynomial fit of the degree entered as deg=... (default 1).
       By default, the fit runs on the last y plotted."""
    fit_x = MyDriver.lastX
    if y == '':
        fit_y = MyDriver.lastY
    elif isinstance(y,str):
        fit_y = MyDriver.Model_list[MyDriver.SelectedModels[-1]].Variables[y][0]
    else:
        fit_y = y
    fit = np.polyfit(fit_x,fit_y,deg)
    eq_str = ''
    for i in range(len(fit)-2):
        eq_str =  eq_str + '{:+f}x^{:d} '.format(fit[i],len(fit)-i-1)
    eq_str = eq_str + '{:+f}x {:+f}'.format(fit[-2],fit[-1])
    print '--------------------------------------------------------------------'
    print 'FIT equation:',eq_str
    print '--------------------------------------------------------------------'
    xinf,xsup = plt.gca().get_xbound()
    draw_x = np.linspace(xinf,xsup,100)
    draw_y = np.zeros(len(draw_x))
    for i in range(len(fit)):
        draw_y = draw_y + fit[i]*draw_x**float(len(fit)-i-1)
    plt.plot(draw_x,draw_y,c=colour,ls=':')
    plt.show()

def xline(xpos,colour='0.80',line='-'):
    """Draws a vertical line at the x position entered as input argument.
       The optional arguments are:
          colour=... to choose the colour (default grey 0.80)
          line=... to chose the linestyle (default '-')"""
    plt.axvline(x=xpos,color=colour,ls=line)

def yline(ypos,colour='0.80',line='-'):
    """Draws a horizontal line at the y position entered as input argument.
       The optional arguments are:
          colour=... to choose the colour (default grey 0.80)
          line=... to chose the linestyle (default '-')"""
    plt.axhline(y=ypos,color=colour,ls=line)

def line(x1,x2,y1,y2,colour='0.80',line='-'):
    """Draws a line from (x1,y1) to (x2,y2).
       The optional arguments are:
          colour=... to choose the colour (default grey 0.80)
          line=... to chose the linestyle (default '-')
       Usage: line(x1,x2,y1,y2)."""
    plt.plot([x1,x2],[y1,y2],color=colour,ls=line)

def slope(value,centre=[0.,0.],colour='0.80',line='-'):
    """Draws a line of slope 'value' on an existing graph.
       The optional parameter centre=[x,y] allows to centre the line on point (x,y)"""
    print 'slope : ',value
    xinf,xsup,yinf,ysup = get_limits(quiet=True)
    if centre == [0.,0.]:
        centre = [xinf+(xsup-xinf)/2.,yinf+(ysup-yinf)/2.]
    y1 = centre[1] + value*(xinf-centre[0])
    y2 = centre[1] + value*(xsup-centre[0])
    plt.plot([xinf,xsup],[y1,y2],color=colour,ls=line)
    plt.show()

def dotxy(x,y,style='',err=[],size=0,f=0,label='',pos='right',fontsize=0):
    """Puts a dot at the (x,y) position entered as input argument.
       The optional arguments are:
        - 'style' for setting the style of the dot;
        - err=[xerr,yerr] for plotting errorbars. The errors can be asymmetric:
             err=[[xerr_left,xerr_right],[yerr_up,yerr_down]];
        - size=n for changing directly the point size to n;
        - f=float for applying factor f to the actual size of points;
        - label='string' for writing 'string' beside the point;
        - pos='pos' for setting the position of the string wrt point ('left','center', or 'right');
        - fontsize=n for setting the fontsize of the string."""
    colourFlag_save = MyDriver.colourFlag
    pointFlag_save = MyDriver.pointFlag
    pointSize = MyDriver.pointSize
    if err != []:
        if np.size(err[0]) > 1:
            err[0] = [[err[0][0]],[err[0][1]]]
        if np.size(err[1]) > 1:
            err[1] = [[err[1][0]],[err[1][1]]]
    if size != 0:
        pointSize = size
    elif f != 0:
        pointSize = pointSize * f
    if style != '':
        if err != []:
            plt.errorbar(x,y,xerr=err[0],yerr=err[1],ecolor='k')
        plt.plot(x,y,style,markeredgecolor='none',markersize=pointSize)
    else:
        if MyDriver.colourFlag == 'cycle':
            set_colourFlag(0.80)
        if 'cycle' in MyDriver.pointFlag:
            set_pointStyle('o')
        if err != []:
            plt.errorbar(x,y,xerr=err[0],yerr=err[1],ecolor='k')
        plt.scatter(x,y,marker=MyDriver.pointFlag,c=MyDriver.colourFlag,s=pointSize,edgecolors='none')
    if label:
    	if pos == 'left':
    		ha = 'right'
    	elif pos == 'center' or pos == 'centre':
    		ha = 'center'
    	elif pos == 'right':
    		ha = 'left'
    	else:
    		print "wrong position, should be 'left', 'center', or 'right'. Set to 'right'."
    		pos = 'right'
    		ha = 'left'
        if fontsize == 0:
            fontsize = MyDriver.fontSize
        else:
            fontsize = fontsize
        xmin,xmax,ymin,ymax=get_limits(quiet=True)
        delta_x = (xmax-xmin)*0.03
        if pos == 'left' and not MyDriver.axisInv[0]:
        	new_x = x - delta_x
        elif pos == 'right' or MyDriver.axisInv[0]:
        	new_x = x + delta_x
        elif pos == 'center' or pos == 'centre':
        	new_x = x
        else:
        	new_x = x + delta_x
        add_label(new_x,y,label,va='center',ha=ha,fontsize=fontsize)

    MyDriver.colourFlag = colourFlag_save
    MyDriver.pointFlag = pointFlag_save

def shade(x,y,colour='0.80',alpha=0.20,hatch=''):
    """Shades the zone defined between vectors x and y.
          The colour of the shade can be set with the argument colour='colour' (default: grey 80%).
          The degree of transparency can be set by the argument alpha=value (default: 0.20).
          The optional parameter hatch='/','\','-','|','+','x','O','o','.','*' is accepted."""
    if x[-1] != x[0] and y[-1] != y[0]:
        if isinstance(x,list):
            x.append(x[0])
        elif isinstance(x,np.ndarray):
            x = np.hstack((x,x[-1]))
        else:
            print "Problem with the kind of data in shade."
        if isinstance(y,list):
            y.append(y[0])
        elif isinstance(y,np.ndarray):
            y = np.hstack((y,y[-1]))
        else:
            print "Problem with the kind of data in shade."
    plt.fill(x,y,color=colour,alpha=alpha,hatch=hatch)
    plt.draw()

def shade_x(x1,x2,colour='0.80',alpha=0.20,hatch=''):
	"""Shades the zone between x1 and x2 in the actual limits of the window."""
	xmin,xmax,ymin,ymax=get_limits(quiet=True)
	shade([x1,x1,x2,x2,x1],[ymin,ymax,ymax,ymin,ymin],colour=colour,alpha=alpha,hatch=hatch)

def shade_y(y1,y2,colour='0.80',alpha=0.20,hatch=''):
	"""Shades the zone between y1 and y2 in the actual limits of the window."""
	xmin,xmax,ymin,ymax=get_limits(quiet=True)
	shade([xmin,xmin,xmax,xmax,xmin],[y1,y2,y2,y1,y1],colour=colour,alpha=alpha,hatch=hatch)

def iLatex(NewValue):
    """Enables LaTeX strings if set to True.
       Included by default in the MyFig command."""
    MyDriver.LatexEnabled = NewValue

def set_fontSize(size=0,f=1.):
    """Allows to change the size of the fonts for the labels."""
    if size != 0:
        if isinstance(size,str):
            if size == 'default':
                MyDriver.fontSize = 24
            else:
                print 'The argument should be "default" or an integer for the sze in points.'
        elif isinstance(size,int) or isinstance(size,float):
            MyDriver.fontSize = size
    else:
        MyDriver.fontSize = MyDriver.fontSize * f

def ChangeFontSize(size=0,f=1.,*args):
    """Retrocompatibility command"""
    set_fontSize(size=0,f=1.,*args)

def set_tickSize(length=2,width=1):
    """Allows to change the size of the ticks on the axes.
       Usage: set_tickSize(length=...,width=...)
       By default: length=2 and width=1."""
    MyDriver.ticklength = length
    MyDriver.tickwidth = width

def ChangeTickSize(length=2,width=1):
    """Retrocompatibility command"""
    set_tickSize(length=2,width=1)

def set_tickNumber(tick=5):
    """Allows to change the number of the minor ticks on the axes.
       Usage: set_tickNumber(num)
       By default: num=5 (automatic behaviour: num=0)"""
    MyDriver.minorLoc = tick

def Margins(top=0.1,right=0.1,bottom=0.2,left=0.2):
    """Allows to modify the margins of a plot.
       The optional arguments are top, right, bottom, left."""
    rcParams['figure.subplot.top'] = top
    rcParams['figure.subplot.right'] = right
    rcParams['figure.subplot.bottom'] = bottom
    rcParams['figure.subplot.left'] = left

def ChangeKippenTolerence(new_tol):
    """Allows to change the tolerence used to generate the
       Kippenhahn diagram. Put 0 if no filtering is wanted.
       Typical value is 0.005."""
    MyDriver.Kipp_tol = new_tol

def MyFig(name,path='',format='svg',layout=''):
    """Save the current figure under the name given as argument.
       If not specified (path="..."), the path to the figure is the one set
          in the config file ~/.Origin_Tools.ini.
       If not specified (format="..."), the format is .svg.
       The figure dimension is squared (11.,11.),
          but it can be changed to a landscape (or portrait) orientation by setting
             the optional argument layout='land' (or 'port')."""
    iLatex_save = MyDriver.LatexEnabled
    iLatex(True)
    CurrentAxes = MyDriver.Previous_Axe
    CurrentAxes.xaxis.labelpad = 0.
    plt.show
    if path == '':
        path=MyDriver.Config.get('Paths','FigPath')
    myFormat=format
    if layout == 'port':
        MyDriver.current_Fig.set_figwidth(5.66)
        orientation='Portrait'
    elif layout == 'land':
        MyDriver.current_Fig.set_figheight(5.66)
        orientation='Landscape'
    else:
        orientation='Squared'
    print orientation+' figure: dimensions ',MyDriver.current_Fig.get_size_inches()
    plt.savefig(path+name+'.'+myFormat,format=myFormat,bbox_inches='tight',edgecolor='none')
    print('Figure '+path+name+'.'+myFormat+' created successfully')
    MyDriver.LatexEnabled = iLatex_save

def change_label(axe,label):
    """Allows to customise the axis label. Usage: change_label('axe','label')."""
    if axe in 'xX':
        MyDriver.Previous_Axe.set_xlabel(label)
    elif axe in 'yY':
        MyDriver.Previous_Axe.set_ylabel(label)
    plt.draw()

def add_label(x,y,string,**args):
    """Allows to add a string at location (x,y).
       The optional arguments are:
        - fontsize (default: 24)
        - align (default: left)
       Usage: add_label(x,y,string[,fontsize=20,align='center'])"""
    myFontsize = MyDriver.fontSize
    myHAlignment = "left"
    myVAlignment = "bottom"
    colour='k'
    for arg in args.keys():
        if arg == 'colour':
            colour = args[arg]
        elif arg == 'fontsize':
            myFontsize = args[arg]
        elif arg == 'ha':
            myHAlignment = args[arg]
        elif arg == 'va':
            myVAlignment = args[arg]
        else:
            print 'Argument ',arg,' not valid'
    plt.text(x,y,string,color=colour,fontsize=myFontsize,ha=myHAlignment,va=myVAlignment)

def top_label(string,**args):
    """Adds a title to the current figure.
       If not specified (fontsize=...), the fontsize is the default one (24)
       or the one set by set_fontSize()."""
    myFontsize = MyDriver.fontSize
    for arg in args.keys():
        if arg == 'fontsize':
            myFontsize = args[arg]
        else:
            print 'Argument ',arg,' not valid'
    plt.suptitle(string,fontsize=myFontsize)

def blabla(string):
    """Creates an svg file in the FigPath containing the string entered as input argument."""
    x = [0,1]
    y = [0,1]
    plt.figure()
    rc('text', usetex=True)
    plt.plot(x,y,'o')
    plt.text(0.05,0.1,string)
    plt.show()
    plt.savefig(MyDriver.Config.get('Paths','FigPath')+'blabla.svg', format='svg')

def clickcursor(event):
    """Needed by the command cursor()."""
    global coords
    coords=[]
    coords.append((event.xdata,event.ydata))
    print 'x=%f, y=%f'%(event.xdata, event.ydata)
    Points = plt.plot(event.xdata,event.ydata,'ob')

def cursor():
    """Retrieves the position of mouseclicks on the plot."""
    MyDriver.Cursor_Event_ID=MyDriver.current_Fig.canvas.mpl_connect('button_press_event', clickcursor)
    raw_input('Press enter when finished.\n')
    return coords[-1]

def clickdist(event):
    """Needed by the command dist()."""
    print 'x=%f, y=%f'%(event.xdata, event.ydata)
    MyDriver.cursor_position.append([event.xdata,event.ydata])
    Points = plt.plot(event.xdata,event.ydata,'or')
    Pts = Points.pop(0)
    MyDriver.cursor_points.append(Pts)

def dist():
    """Allows to measure the distance and the slope between two clics on a plot."""
    MyDriver.cursor_position = []
    for Point in MyDriver.cursor_points:
        Point.remove()
    MyDriver.cursor_points = []
    MyDriver.Cursor_Event_ID=MyDriver.current_Fig.canvas.mpl_connect('button_press_event', clickdist)
    raw_input('Press enter when finished.\n')
    xdist = float(MyDriver.cursor_position[-1][0]) - float(MyDriver.cursor_position[-2][0])
    ydist = float(MyDriver.cursor_position[-1][1]) - float(MyDriver.cursor_position[-2][1])
    print 'Distance along x-axis = ', xdist
    print 'Distance along y-axis = ', ydist
    print 'Absolute distance = ', math.sqrt(xdist**2. + ydist**2.)
    if xdist!= 0.:
        print 'dy/dx = ',ydist/xdist
    else:
        print 'dy/dx = infinity'

def closest_line(Xvar='',Yvar='',printline=False):
    """Finds the closest line from a cursor selection.
       The optional parameter printline=True prints the whole line from the file,
       otherwise only the number is returned (default behaviour)."""
    if not Xvar:
        Xvar = MyDriver.lastXvar
    if not Yvar:
        Yvar = MyDriver.lastYvar
    xclic,yclic = cursor()
    distance_all = 9999999.
    best_i = 0
    line_i = {}
    for i in MyDriver.SelectedModels:
        myX = Get_Var(Xvar,i)
        myY = Get_Var(Yvar,i)
        myline = Get_Var('line',i)
        norm_x = (myX-min(myX))/(max(myX)-min(myX))
        norm_y = (myY-min(myY))/(max(myY)-min(myY))
        dist_x = (xclic-min(myX))/(max(myX)-min(myX))
        dist_y = (yclic-min(myY))/(max(myY)-min(myY))
        distance = (norm_x - dist_x)**2. + (norm_y - dist_y)**2.
        closest = np.argmin(distance)
        if np.min(distance) < distance_all:
            distance_all = np.min(distance)
            best_i = i
        line_i[i] = myline[closest]
    if MyDriver.modeplot == 'evol' and os.path.splitext(MyDriver.Model_list[best_i].Variables['FileName'][0])[1] != '.wg':
        print 'Beware: the line will not be as accurate as if you used the complete .wg file.\n'
    if not printline:
        return line_i[best_i]
    else:
        with open(MyDriver.Model_list[best_i].Variables['FileName'][0],'r') as myfile:
            for file_line in myfile:
                current_model = int(file_line.split()[0])
                if current_model == line_i[best_i]:
                    print file_line
                    return line_i[best_i]

def file_len(fname):
    """Finds the length of a file. Needed by Structure.read()"""
    p = subprocess.Popen(['wc', '-l',fname],stdout=subprocess.PIPE,stderr=subprocess.PIPE)
    result,err = p.communicate()
    if p.returncode != 0:
        raise IOError(err)
    return int(result.strip().split()[0])

def plotExternal(fileName,colX,colY,*argus,**args):
    """Offers the possibility to overplot some external data.
       Usage: plotExternal(file_name,col_x,col_y[,skip=skip_header_lines,style=myStyle,log='xy']).
       The optional parameters are:
         - 'new' (to generate a new figure, False by default).
         - 'invS' (to get point size that are 1./cols)
         - skip = n (to skip n lines at the beginning of the file)
         - last = n (last line to be read)
         - colz = n (to colour-code the points with the value of a variable at column n)
         - cols = n (to resize the points with the value of a variable at column n)
         - style = style (for changing the line/point style)
         - log = x,y,z, and/or s (for getting the log of the value read for x,y,z, or s)
         - clim = 'new' or 'old' to define new colour limits or keep the previous ones
         - zlabel = str to set the colour bar label."""
    skip = 0
    last = -1
    myStyle = ''
    logx = False
    logy = False
    logz = False
    logs = False
    newFig = False
    zcolour = False
    varsize = False
    invS = False
    zlabel = ''
    binz = 0
    clim = 'new'
    iColour = MyDriver.colourFlag
    points = MyDriver.pointSize
    lineFlag_save = MyDriver.lineFlag
    pointFlag_save = MyDriver.pointFlag
    point_save = MyDriver.iPoints
    mycols = [colX,colY]
    if 'cycle' in MyDriver.colourFlag:
        iColour = 'Black'
    if 'cycle' in MyDriver.lineFlag:
        MyDriver.lineFlag = '-'
    if 'cycle' in MyDriver.pointFlag:
        MyDriver.pointFlag = 'o'
    for arg in args.keys():
        if arg == 'skip':
            skip = args[arg]
        if arg == 'last':
            last = args[arg]
        if arg == 'style':
            myStyle = args[arg]
        if arg == 'log':
            if 'x' in args[arg] or 'X' in args[arg]:
                logx = True
            if 'y' in args[arg] or 'Y' in args[arg]:
                logy = True
            if 'z' in args[arg] or 'Z' in args[arg]:
                logz = True
            if 's' in args[arg] or 'S' in args[arg]:
                logs = True
        if arg == 'colz':
            colZ = args[arg]
            zcolour = True
            if not MyDriver.iPoints:
                Points(True)
            mycols.append(colZ)
            indz = mycols.index(colZ)
        if arg == 'cols':
            colS = args[arg]
            varsize = True
            if not MyDriver.iPoints:
                Points(True)
            mycols.append(colS)
            inds = mycols.index(colS)
        if arg == 'zlabel':
            zlabel = args[arg]
        if arg == 'binz':
            binz=args[arg]
        if arg == 'clim':
            clim = args[arg]
    for arg in argus:
        if arg == 'new':
            newFig = True
        if arg == 'invS':
            invS = True
    if newFig:
        if MyDriver.closeFig:
            plt.close()
        MyDriver.AddFigure((11,11))
        MyDriver.current_Fig.subplots_adjust(wspace=MyDriver.subplotSep)
        New_Axes = MyDriver.current_Fig.add_subplot(111)
    else:
        New_Axes = MyDriver.Previous_Axe

    rawfile = open(fileName,'r')
    table = np.loadtxt(rawfile,skiprows=skip,comments='#',usecols=(mycols))
    myX = table[:last,0]
    myY = table[:last,1]
    if zcolour:
        myZ = table[:last,indz]
        if logz:
            myZ = np.log10(myZ)
    if varsize:
        myS = table[:last,inds]
        if invS:
            myS = 1./myS
        if logs:
            myS = np.log10(myS)
        Smin = np.min(myS)
        Smax = np.max(myS)
        myS = (myS-Smin)/(Smax-Smin)*(MyDriver.PSmax-MyDriver.PSmin)+MyDriver.PSmin
    if logx:
        myX = np.log10(myX)
    if logy:
        myY = np.log10(myY)

    if zcolour:
        iColour = myZ
    	if clim == 'old':
    	    minZ,maxZ = MyDriver.get_CBlimits
    	else:
    	    if MyDriver.CBFlag[0]:
    	        minZ = MyDriver.CBLimits[0]
    	    else:
    	        minZ = np.min(myZ)
    	    if MyDriver.CBFlag[1]:
    	        maxZ = MyDriver.CBLimits[1]
    	    else:
    	        maxZ = np.max(myZ)
    if varsize:
        points = myS

    if MyDriver.iPoints:
        if myStyle != '':
            New_Axes.scatter(myX,myY,myStyle,s=MyDriver.pointSize)
        else:
            if zcolour:
                cmap=cm.get_cmap(MyDriver.colourMap)
                if binz != 0:
                    bounds = np.linspace(minZ,maxZ,binz+1)
                else:
                    bounds = np.linspace(minZ,maxZ)
                norm = colors.BoundaryNorm(bounds,cmap.N)
                if newFig or clim == 'new':
                    ColorBarSettings = plt.cm.ScalarMappable(cmap=cmap, norm=norm)
                    ColorBarSettings._A = []
                    MyCB = MyDriver.current_Fig.colorbar(ColorBarSettings,fraction=0.08)
                    MyCB.locator = mptick.MaxNLocator(nbins=MyDriver.CBticksN)
                    MyCB.update_ticks()
                    if zlabel:
                        MyCB.ax.set_ylabel(zlabel,fontsize=MyDriver.fontSize/1.5)
                        MyCB.ax.yaxis.set_label_position('right')
                New_Axes.scatter(myX,myY,c=iColour,marker=MyDriver.pointFlag,cmap=cmap,norm=norm,s=points,edgecolors='none')
            else:
                New_Axes.scatter(myX,myY,c=iColour,marker=MyDriver.pointFlag,s=points,edgecolors='none')
    else:
        if myStyle != '':
            New_Axes.plot(myX,myY,myStyle)
        else:
            New_Axes.plot(myX,myY,color=iColour,ls=MyDriver.lineFlag)

    if newFig:
        MyLimits = list(New_Axes.axis())
        for i,axisDef,axisLim in zip([0,1,2,3],MyDriver.axisFlag,MyDriver.axisLimits):
            if axisDef:
                MyLimits[i] = axisLim
        Xmin,Xmax,Ymin,Ymax,MyDriver.axisLimits[0],MyDriver.axisLimits[1],MyDriver.axisLimits[2],MyDriver.axisLimits[3] = DefNewLimits(MyLimits)
        New_Axes.axis((Xmin,Xmax,Ymin,Ymax))
        MyDriver.Store_Axes(New_Axes)
    plt.draw()

    set_lineStyle(lineFlag_save)
    Points(point_save)
    set_pointStyle(pointFlag_save)

MyDriver = Driver()
MyData = Analysis()
